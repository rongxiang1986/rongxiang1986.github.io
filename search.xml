<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小米路由器MT工具箱配置]]></title>
    <url>%2F2020%2F03%2F22%2F2020-03-22-%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8MT%E5%B7%A5%E5%85%B7%E7%AE%B1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 装备工作 第二部分 配置MT工具箱 参考文献及资料 背景家庭使用的小米路由器，需要折腾一下，开始全局小飞机。 第一部分 准备工作首先需要小米路由器准备好下面的配置前提： 安装了开发版的rom，获得root权限； 路由器开启了ssh； 路由器默认的IP地址为“192.168.31.1”； 具体可以参考文献中文章《小米路由器安装MT工具箱》。 第二部分 配置MT工具箱使用SSH登录小米路由器，执行下面的安装命令： 1curl -s -k https://beta.misstar.com/download/$(uname -m)/mtinstall -o /tmp/mtinstall &amp;&amp; chmod +x /tmp/mtinstall &amp;&amp; /tmp/mtinstall 选择网络安装（选项2），按照提示配置用户和密钥。提示安装Misstar tools 3.0beta版成功： 1http://192.168.31.1:1314/ 但是提示页面url并不能打开。事实上监听的端口是1024。 12root@XiaoQiang:~# netstat -ant|grep 1024tcp 0 0 :::1024 :::* LISTEN 0 0 使用下面的url进入MT工具箱： 1http://192.168.31.1:1024 然后部署你的小飞机吧。新建节点等不再赘述。 参考文献及资料1、小米路由器安装MT工具箱，链接：https://whrr.blog/2019/01/06/install-mt-tools-on-a-xiaomi-router/]]></content>
      <categories>
        <category>路由器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch集群升级指引]]></title>
    <url>%2F2020%2F03%2F07%2F2020-03-07-Elasticsearch%E9%9B%86%E7%BE%A4%E5%8D%87%E7%BA%A7%E6%8C%87%E5%BC%95%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 版本升级指引 第二部分 升级方法和具体步骤 总结 参考文献及资料 背景Elasticsearch集群的版本升级是一项重要的集群维护工作。本篇文章参考官方文档，将详细介绍相关细节。 第一部分 版本升级指引1.1 同步升级Elastic Stack组件对于Elasticsearch的生态圈组件需要同步升级，具体配套版本可以参考官方提供的升级指南。 https://www.elastic.co/cn/products/upgrade_guide 1.2 索引兼容性Elasticsearch对于老版本的索引（index）兼容性如下： Elasticsearch 6.x兼容Elasticsearch 5.x中创建的索引，但不兼容Elasticsearch 2.x或更旧版本的索引。 Elasticsearch 5.x兼容Elasticsearch 2.x中创建的索引，但不不兼容Elasticsearch1.x或更旧版本的索引。 如果升级过程中遇到索引不兼容场景，升级后集群将无法正常启动。 1.3 版本升级路线Elasticsearch版本升级具体路线总结如下： 序号 原版本 升级目标版本 支持的升级类型 1 5.x 5.y 滚动升级（其中 y &gt; x） 2 5.6 6.x 滚动升级 3 5.0-5.5 6.x 集群重启 4 &lt;5.x 6.x reindex升级 5 6.x 6.y 滚动升级（其中 y &gt; x） 6 1.x 5.x reindex升级 7 2.x 2.y 滚动升级（其中 y &gt; x） 8 2.x 5.x 集群重启 9 5.0.0 pre GA 5.x 集群重启 10 5.x 5.y 滚动升级（其中 y &gt; x） 关于Elasticsearch的版本序列需要特别说明一下。Elasticsearch版本序列不是连续递增的，从2.4.x版本后直接跳跃到5.0.x。所以对于5.x版本，如果按照严格顺序递增编号，应该是3.x。之所以没有连续编号，主要是为了保持ELK（Elasticsearch 、 Logstash 、 Kibana）整体版本的统一。 其中第4种情况，小于5.x其实就是2.x和1.x。由于6.x对于更低版本的索引不兼容，所以需要对原集群的中索引实施reindex。方案分别为： 1.3.1 2.x升级到6.x按照上面的升级路线有两种升级方案： 方案1：先由2.x升级到5.6版本（reindex升级索引版本），然后由5.6升级到6.x（滚动升级）； 方案2：创建全新的6.x集群，然后将旧集群中的索引数据远程reindex到新集群中； 1.3.2 1.x升级到6.x同样有两个方案： 方案1：先由1.x升级到2.4.x版本（reindex升级索引版本），最后按照上面2.x升级到6.x的方案实施； 方案2：创建全新的6.x集群，然后将旧集群中的索引reindex到新集群中； 第二部分 升级方法和具体步骤集群升级路线中，针对不同的版本之间升级，一共有三种升级方案：滚动升级、集群重启、reindex。下面将分别介绍。 2.1 滚动升级所谓滚动升级指的是集群中节点逐个将版本升级至目标（高）版本，升级期间集群保持对外服务不中断。这种升级方案都是针对同一个大版本内的升级，即x.y升级到x.z（z&gt;y）。特别的，5.6升级到6.x也是支持使用滚动升级方式的。 https://www.elastic.co/guide/en/elasticsearch/reference/current/rolling-upgrades.html 通常滚动升级的步骤如下： 第1步 禁用副本分片（shards）分配在下宕升级节点前，需要提前禁止副本分片的分配。 节点下宕后，副本分配进程会等待index.unassigned.node_left.delayed_timeout（默认情况下为1分钟），然后再开始将该节点上的分片复制到群集中的其他节点，这会导致大量I/O。由于节点很快将重新启动，所以并不需要重新分配。 API命令如下： 123456PUT _cluster/settings&#123; "persistent": &#123; "cluster.routing.allocation.enable": "primaries" &#125;&#125; 第2步 执行同步刷新 重启集群时如果translog过大，日志回放恢复数据耗时较长，建议手动同步刷新，减少translog。 注意：这个过程较为缓慢。 1POST _flush/synced 第3步 停止机器学习作业如果集群中运行了机器学习任务，需要停止任务运行。 参考：https://www.elastic.co/guide/en/elastic-stack-overview/6.8/stopping-ml.html 第4部 下宕待升级节点并安装主版本和插件对升级节点实施下宕，开始文件系统的升级。 第5步 启动节点启动节点，并用下面的API检查节点是否加入集群。 1GET _cat/nodes 第6步 重启分片分配节点加入集群后，设置启用分片分配开始使用该节点。 123456PUT _cluster/settings&#123; "persistent": &#123; "cluster.routing.allocation.enable": null &#125;&#125; 在升级下一个节点前，等待集群分片完成。可以通过下面的API检查集群状态： 1GET _cat/health?v 等待集群的状态由red变成yellow，再到green。说明集群完成所有主分片和副分片的分配。 第7步 重复升级其他节点重复滚动升级集群其他节点。 第8步 重启机器学习任务如果集群中有机器学习任务，需要从新启动。 2.2 集群整体重启集群整体重启指的是升级前将集群所有节点均下宕，集群停止对外服务，待所有节点完成升级后，整体启动集群，恢复对外服务。例如：5.6之前的版本升级到6.x需要重启集群实施升级。 https://www.elastic.co/guide/en/elasticsearch/reference/current/restart-upgrade.html 集群重启升级步骤和滚动方式相似，主要步骤如下： 第1步 禁用副本分片（shards）分配下宕升级节点前需要，提前禁止副本分片的分配。（参考滚动升级） 第2步 停止不必要的索引并执行同步刷新参考滚动升级。 第3步 停止机器学习作业参考滚动升级 第4部 下宕所有节点并安装主版本和插件对集群所有节点实施下宕，开始文件系统版本升级。 第5步 启动节点并等待集群状态为yellow启动所有节点，并用下面的API检查所有节点是否加入集群。 1GET _cat/nodes 第6步 重启分片分配节点加入集群后，设置启用分片分配开始使用该节点。 123456PUT _cluster/settings&#123; "persistent": &#123; "cluster.routing.allocation.enable": null &#125;&#125; 在升级下一个节点前，等待集群分片完成。可以通过下面的API检查集群状态： 1GET _cat/health?v 等待集群的状态由yellow变为green。说明集群完成所有主分片和副分片的分配。 第7步 重启机器学习任务参考滚动升级 2.3 reindexElasticsearch中相邻版本的index具有兼容性，但是跨度较大的版本不再向下兼容。在上文（1.2 索引兼容性）中已做介绍。而在ElasticSearch中，索引的field设置是不能被修改的，如果要修改一个field，那么应该重新按照新的mapping，建立一个index，然后将数据批量查询出来，重新用bulk api写入新index中。 批量查询的时候，建议采用scroll api，并且采用多线程并发的方式来reindex数据，每次scroll就查询指定日期的一段数据，交给一个线程即可。 第1步 搭建新版本集群申请服务器资源，搭建全新版本的ElasticSearch集群。将对外服务全部指向新集群。 第2步 将老集群中数据reindex到新集群在老集群上使用reindex API将老集群中index历史数据逐步迁移至新集群。 如果集群数据量较大，迁移过程是一个很缓慢的过程。 API案例（下面是简单的配置）： 12345678910111213141516171819202122POST _reindex&#123; "source": &#123; "remote": &#123; "host": "http://otherhost:9200", "username": "user", "password": "pass" &#125;, "index": "source", "query": &#123; "match": &#123; "test": "data" &#125; &#125; &#125;, "dest": &#123; "index": "dest" &#125;&#125;//host为远程集群（新集群）的地址。//username和password针对安全集群的密钥验证。//"index": "source"为旧集群中index名，dest的所对应的是新集群目标index名。 迁移完成后，可以对旧集群中数据实施清理。清理完成后根据情况需要，旧节点可以离线升级文件系统，最后作为全新的节点加入新集群。 如果旧集群中历史数据不重要，可以删除数据后，搭建全新的集群。 2.4 分步升级对于跨度较大的版本升级，如果不采用新建集群再实施reindex方式，那么就需要分步升级。例如A、B、C依次为三个版本，版本级别A&lt;B&lt;C，其中index数据B兼容A，C兼容B，但是C不兼容A。这种情况需要分步升级： A升级到B，使用滚动升级或者集群整体重启方式。 对于B版本的集群，将A版本的所有数据reindex到B版本。这个过程较为耗时。 等到集群中所有历史index（新建的index自然是B版本）均为B版本后，升级集群版本到C版本。 如果index数据是时间序列类的数据，可以不实施reindex，等到历史数据生命周期结束后（集群中不在有A版本的index数据），再从B版本升级到C版本。 总结（1）一般Elasticsearch大版本之间跨度升级需要重启整体集群。 （2）部分ElasticSearch大版本间index并不兼容，需要对数据重索引（reindex）。 （3）大版本中的小版本升级，通常只需要滚动重启方式即可。 参考材料1、Elasticsearch官网 链接：https://www.elastic.co/cn/]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kafka系列文章（第五篇 Kafka安全集群）]]></title>
    <url>%2F2020%2F03%2F02%2F2020-01-01-Kafka%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%EF%BC%88%E7%AC%AC%E4%BA%94%E7%AF%87Kafka%E5%AE%89%E5%85%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 Kafka集群加密传输 第二部分 Kafka集群权限认证 第三部分 加密认证集群的客户端 第四部分 加密认证集群的性能压测 第五部分 总结 参考文献及资料 背景Kafka在0.9.0.0版本前没有安全机制功能。Kafka Client程序可以通过连接Zookeeper来获取存储在Zookeeper中的Kafka集群元数据信息。拿到Kafka Broker地址后，连接到Kafka集群，可以完全操作集群上的所有topic。另外集群节点通讯、broker和zookeeper通讯、客户端和集群的网络层通信都是无加密的。集群的数据存在极大的安全风险。 自0.9.0.0版本开始，Kafka社区逐步添加了较多功能用于提高Kafka群集的安全性。目前Kafka安全集群安全机制主要有：通信加密（encryption）、身份认证（authentication）和授权（authorization）。 本文重点介绍生产安全集群的一种配置方案。数据通讯传输配置SSL，认证配置SASL，授权通过ACL接口命令来完成的，即：SSL+SASL/SCRAM+ACL。 第一部分 Kafka集群加密传输1.1 背景知识介绍涉及的技术知识不做详细介绍。 1.1.1 密码学基础加密算法分为两类： 对称密钥算法（Symmetric Cryptography）：数据加密和解密时使用相同的密钥。例如常用的DES就是对称加密算法。 非对称密钥算法（Asymmetric Cryptography）：数据加密和解密时使用不同的密钥，分为：公开的公钥（public key）和用户保存的私钥（private key），私钥和公钥在数学上是相关的。利用公钥（或私钥）加密的数据只能用相应的私钥（或公钥）才能解密。举一个例子：客户在银行网银上做一笔交易，首先向银行申请公钥，银行分发公钥给用户，用户使用公钥对请求数据进行加密。银行收到加密数据后通过银行侧保存的私钥进行解密处理，并处理后更新后台数据库。这个通讯过程中银行不需要通过互联网分发私钥。因此保证了私钥的安全。目前最常用的非对称加密算法是RSA算法。 非对称密钥算法中，私钥来解密公钥加密的数据，公钥来解密私钥加密的数据。 两种加密算法的比较： 对称密钥的强度和密钥长度成正比，但是解密效率和密钥长度成反比。另外私钥的分发存在安全风险。 非对称加密保证了私钥的安全性，但是加密和解密的效率比对称加密低。 所以通常加密场景是两种密钥结合使用。使用数据主体使用对称秘钥算法，但是私钥的传输使用非对称算法在互联网环境分发非对称密钥。最常见的就是SSL/TLS。 1.1.2 CA数字证书对于非对称密钥算法存在一个安全风险点，那就是公钥的分发存在中间人攻击。还是以客户和银行的通信为例（例子简单化处理）。客户和银行分别有自己的公钥和私钥，私钥各自保留本地。公钥通过互联网分发给对方。那么公钥就是有安全风险的。存在被黑客截取风险。客户向银行申请银行公钥，结果被黑客截取，黑客伪装成银行，返回给用户自己的黑客公钥，用户收到黑客公钥后，将信息加密发给黑客。黑客用黑客私钥进行解密，获取到真实信息。这时候黑客伪装成客户用相同的方法完成和银行的数据交互。这就是中间人攻击的案例。 所以非对称加密算法的公钥传输同样存在风险。当然如果使用原始的离线方式交换密钥是安全的，但是随着互联网通信的爆炸式增长，这是落后低效的。为了保证公钥的真实性和安全性，这时候我们引入第三个角色：公开密钥认证（Public key certificate，简称CA），又称数字证书（digital certificate）或身份证书（identity certificate）。 通常CA是一家第三方权威机构。负责管理和签发证书。整个实现原理也是非对称加密算法： 机构将自己的公钥以及身份信息交给CA机构（安全的），CA使用自己的私钥对各机构的公钥进行加密。这个过程称为验签。输出的加密后的公钥及身份信息称为数字证书。 当其他机构请求A机构公钥的时候，返回的是A机构的数字证书。其他机构可以使用CA的公钥对该数字证书中加密公钥进行解密获取A机构的通信公钥。 那么新得安全问题又来了，如何保证CA机构的公钥不被伪造？通常CA的公钥是集成在浏览器或者操作系统中，并且被很好的保护起来。 当然CA证书还涉及更多的安全细节设计（Hash算法防篡改、信任链等大量细节），这里只是简单的介绍。详细介绍可以查看：维基（证书颁发机构） 对于企业内部的应用系统就没必要花钱购买CA机构的证书服务了，可以自建 Root CA，自己给自己颁发证书，充当内网的CA机构。当然这时候客户端就需要导入CA的证书了（浏览器和操作系统没有自建的CA证书）。 1.1.3 SSL/TLS加密协议SSL（Secure Sockets Layer）是一种安全协议，目的是为保障互联网上数据传输安全，利用数据加密技术，确保数据在网络上之传输过程中不会被截取。 从网络协议层看，SSL协议位于TCP/IP协议与应用层协议之间，为数据通讯提供安全支持。SSL协议自身可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。例如HTTPS就是在HTTP应用层上增加了SSL加密协议支持（HTTP over SSL）。 TLS(Transport Layer Security，传输层安全协议)，同样用于两个应用程序之间提供保密性和数据完整性。 TLS 1.0建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，即是SSL的升级版。TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。另外,TLS版本号也与SSL的不同(TLS的版本1.0使用的版本号为SSLv3.1) SSL通过握手过程在client和server之间协商会话參数，并建立会话。一共有三种方式： 仅仅验证server的SSL握手过程（单向SSL） 验证server和client的SSL握手过程（双向SSL） 恢复原有会话的SSL握手过程 第一种：单向SSL通信过程如下（SSL 客户端和SSL 服务端通信）： (1)SSL客户端向SSL服务端发起请求，请求信息包括SSL版本号、加密算法、密钥交换算法、MAC算法等信息； (2)SSL服务端确定本次通话的SSL版本和加密套件后，将携带公钥信息的证书回给客户端。如果通话可从重用，还会返回会话ID； (3)SSL服务端发送Server Hello Done消息。通知SSL客户端版本号和加密套件协商结束，开始进行密钥交换； (4)SSL客户端对CA证书进行验证，证书合法则继续、不成功弹出选择页面； (5)SSL客户端生产随机私有对称密钥key，并使用服务端公开密钥进行加密后，发给服务端； (6)SSL服务端使用自己的私钥解密，获取对称密钥key； (7)最后SSL客户端与SSL服务端将使用该对称密钥key进行加密通信。 第二种：单向认证，仅仅是客户端需要检验服务端证书是否是正确的。双向SSL和单向认证几乎一样，只是在客户端认证完服务器证书后，客户端会将自己的证书传给服务器。服务器验证通过后，才开始秘钥协商。 第三种：协商会话参数、建立会话的过程中，需要使用非对称密钥算法来加密密钥、验证通信对端的身份，计算量较大，占用了大量的系统资源。为了简化SSL握手过程，SSL允许重用已经协商过的会话。即可以重用会话ID。这就是第三种建立会话方式。 1.1.4 Openssl工具对于企业内部（内部局域网）的应用系统通讯，如果需要CA证书服务，可以使用Openssl自建CA，并完成证书签发。 先说一下常用密钥类文件的规范： 后缀名规范 通常约定后缀含义：crt或者cert 表示证书, key表示私钥, req和csr表示请求文件。 文件格式 pem表示pem格式（经过加密的文本文件），der表示der格式（经过加密的二进制文件）。所有证书和私钥可以是pem,也可以是der格式，取决于需要。两个格式可以转换。 Openssl的配置文件（openssl.cnf）定义CA的默认参数，例如ubuntu系统中配置文件位置在/usr/lib/ssl/openssl.cnf。如果不适用默认参数需要在命令中重新指定。 CA证书的制作 首先生成CA的私钥，使用下面的命令： 1$ openssl genrsa -out private/ca.key.pem 2048 private/ca.key.pem是CA私钥,格式为pem，长度（加密位数）为2048。 前面密码学知识知道CA使用一对密钥的（私钥和公钥），并且两个密钥是数学相关的。公钥可以通过私钥算出来。 CA证书自签发 参考命令如下： 1$ openssl req -new -x509 -key private/ca.key.pem -out certs/ca.cert.pem certs/ca.cert.pem 即CA的自签证书。部署导入到客户端（例如浏览器）。 用户证书签发 用户证书的签发和CA自签相同，用户证书由CA私钥签发。用户需要提供请求文件。 1$ openssl ca -in app.csr -out app.crt -days 365 app.crt为签发的证书。部署在应用服务器上。 1.1.5 Keytool工具介绍在密钥证书管理时，通常使用JAVA的Keytool工具程序。Keytool 是一个JAVA数据证书的管理工具 ,Keytool 将密钥（key）和证书（certificates）存在一个称为keystore的文件中，通常称为密钥库文件。文件的扩展名通常使用：jks，全名java key store file。 Keytool是一个Java数据证书的管理工具，所以节点需要配置JAVA_HOME环境变量。 这里列举了命令支持的参数含义及注意点（供后续使用查阅）： keystore 参数指定保存证书的文件（密钥库二进制文件）。密钥库文件包含证书的私钥，必须对其进行安全保存。 validity 参数指定密钥有效期，单位是天。默认为90天。 keyalg 参数指定密钥使用的加密算法（例如RSA，如果不指定默认采用DSA）。 keysize 参数指定密钥的长度。该参数是选项参数，默认长度是1024位。为了保证密钥安全强度，建议密码长度设置为2048位。 keypass 参数指定生成密钥的密码（私钥密码）。 storepass 指定密钥库的密码(获取keystore信息所需的密码)。另外密钥库创建后，要对其做任何修改都必须提供该密码，以便访问密钥库。 alias 参数指定密钥别名。每个密钥文件有一个唯一的别名，别名不区分大小写。 dname 参数指定证书拥有者信息。例如： “CN=名字与姓氏,OU=组织单位名称,O=组织名称,L=城市或区域名称,ST=州或省份名称,C=单位的两字母国家代码”。 list 参数显示密钥库中的证书信息。keytool -list -v -keystore 指定keystore -storepass 密码 v 参数显示密钥库中的证书详细信息。 export 将别名指定的证书导出到文件。keytool -export -alias 需要导出的别名 -keystore 指定keystore -file 指定导出的证书位置及证书名称 -storepass 密码。 file 参数指定导出到文件的文件名。 delete 删除密钥库中某条目。keytool -delete -alias 指定需删除的别名 -keystore 指定keystore -storepass 密码 printcert 查看导出的证书信息。keytool -printcert -file yushan.crt keypasswd 修改密钥库中指定条目口令。keytool -keypasswd -alias 需修改的别名 -keypass 旧密码 -new 新密码 -storepass keystore密码 -keystore sage storepasswd 修改keystore口令。keytool -storepasswd -keystore e:/yushan.keystore(需修改口令的keystore) -storepass 123456(原始密码) -new newpasswd(新密码) import 将已签名数字证书导入密钥库。keytool -import -alias 指定导入条目的别名 -keystore 指定keystore -file 需导入的证书 关于Keytool工具的详细介绍，可以参考oracle的官网。 1.2 Kafka集群配置SSL加密Apache Kafka允许客户端通过SSL连接。默认情况下，SSL是禁用的，可以根据需要打开。 1.2.1 集群环境准备为了后文讲解方便，我们部署了Kafka集群（3节点）和Zookeeper集群（3节点）测试环境。其中zookeeper和kafka混合部署。 节点编号 hostname IP地址 1 kafka.app.node1 192.168.1.5 2 kafka.app.node2 192.168.1.6 3 kafka.app.node3 192.168.1.7 Kafka集群节点对外服务端口为：9092；Zookeeper集群节点对外服务端口为：2181。 1.2.2 配置主机名验证从Kafka 2.0.0版开始，默认会为客户端连接以及broker之间的连接启用服务器的主机名验证（SSL端点识别算法），以防止中间人攻击。可以通过设置参数ssl.endpoint.identification.algorithm为空字符串来禁用服务器主机名验证。例如: 1ssl.endpoint.identification.algorithm= 另外高版本支持不停集群服务下，进行动态配置，使用脚本kafka-configs.sh，参考命令如下： 1bin/kafka-configs.sh --bootstrap-server localhost:9093 --entity-type brokers --entity-name 0 --alter --add-config "listener.name.internal.ssl.endpoint.identification.algorithm=" 对于较旧的Kafka版本，ssl.endpoint.identification.algorithm默认情况下未定义，因此不会启用主机名验证。若该属性设置HTTPS，则启用主机名验证，例如： 1ssl.endpoint.identification.algorithm=HTTPS 需要注意的是，一旦启用主机名验证，客户端将根据以下两个字段之一验证服务器的完全限定域名（FQDN）： 通用名称（CN，Common Name） 主题备用名称（SAN，Subject Alternative Name） 两个字段都有效，但RFC-2818建议使用SAN。 SAN也更灵活，允许声明多个DNS条目。 另一个优点是，CN可以设置为更有意义的值用于授权。如要添加SAN字段，需要将以下参数-ext SAN = DNS：{FQDN}添加到keytool命令中，例如： 1$ keytool -keystore server.keystore.jks -alias localhost -validity &#123;validity&#125; -genkey -keyalg RSA -ext SAN=DNS:&#123;FQDN&#125; 更通俗一点讲，SSL 握手期间验证主机名时，它会检查服务器证书是否具有 SAN 集。如果检测到 SAN 集，那么只使用 SAN 集中的名称或 IP 地址。如果未检测到 SAN 集，那么只使用主题专有名称 (DN) 最重要的属性，通常是通用名称(CN)。将该值与客户端尝试连接的服务器启的主机名进行比较。如果它们相同，主机名验证成功，允许建立连接。 1.2.3 生成SSL密钥和证书为了方便管理证书密钥，我们使用统一的路径保存。例如统一放在/usr/ca作为文件目录。 1$ mkdir -p /usr/ca/&#123;root,server,client,trust&#125; 这里各文件夹的功能是：root：存储CA私钥和证书；server：存储服务端的私钥和证书；client：存储客户端私钥和证书；trust：存储信任库文件； 节点1（kafka.app.node1） 1$ keytool -keystore /usr/ca/server/server.keystore.jks -alias kafka.app -validity 3650 -genkey -keypass app123 -keyalg RSA -dname "CN=kafka.app.node1,OU=depart,O=org,L=shanghai,S=shanghai,C=cn" -storepass app123 -ext SAN=DNS:kafka.app.node1 其中dname参数的含义参考Keytool工具介绍，文件名为：server.keystore.jks，这是密钥库。 节点2（kafka.app.node2） 1$ keytool -keystore /usr/ca/server/server.keystore.jks -alias kafka.app -validity 3650 -genkey -keypass app123 -keyalg RSA -dname "CN=kafka.app.node1,OU=depart,O=org,L=shanghai,S=shanghai,C=cn" -storepass app123 -ext SAN=DNS:kafka.app.node2 节点3（kafka.app.node3） 1$ keytool -keystore /usr/ca/server/server.keystore.jks -alias kafka.app -validity 3650 -genkey -keypass app123 -keyalg RSA -dname "CN=kafka.app.node1,OU=depart,O=org,L=shanghai,S=shanghai,C=cn" -storepass app123 -ext SAN=DNS:kafka.app.node3 证书生成后可以通过下面的命令进行查询（需要输入密钥库管理密码，即keypass的参数）： 1$ keytool -list -v -keystore server.keystore.jks 1.2.4 创建Kafka集群CA证书集群中每个服务节点都有一对公钥和私钥，以及用于标识该节点的证书。但这个证书是未签名的，存在中间者攻击的风险。所以需要证书颁发机构（CA）负责签署颁发证书，使用openssl工具实现。 同一个集群的所有节点共用一个CA证书，所以只需要在集群的一个节点（集群外节点均可）生成CA证书，然后分发给集群其他节点。例如在kafka.app.node1节点上创建CA证书，命令如下： 1$ openssl req -new -x509 -keyout /usr/ca/root/ca.key.pem -out /usr/ca/root/ca.cert.pem -days 365 -passout pass:app123 -subj "/C=cn/ST=shanghai/L=shanghai/O=org/OU=depart/CN=kafka.app.node1" 然后使用scp命令分发给其他节点： 12$ scp /usr/ca/root/* root@kafka.app.node2:/usr/ca/root/$ scp /usr/ca/root/* root@kafka.app.node3:/usr/ca/root/ 生成两个文件，分别是私钥（ca.key.pem）和证书（ca.cert.pem），它用来签署其他证书。 1.2.5 集群服务节点签署证书首先给集群各服务节点签发证书（即签名）。步骤如下： 第一步 从密钥容器中提取和导出服务端证书（输出文件：server.cert-file，未签名） 1$ keytool -keystore /usr/ca/server/server.keystore.jks -alias kafka.itdw -certreq -file /usr/ca/server/server.cert-file -storepass app123 第二步 给服务端证书签名（输出文件：server.cert-signed，已签名） 1$ openssl x509 -req -CA /usr/ca/root/ca-cert -CAkey /usr/ca/root/ca-key -in /usr/ca/server/server.cert-file -out /usr/ca/server/server.cert-signed -days 365 -CAcreateserial -passin pass:app123 第三步 将CA证书导入服务端密钥容器中 1$ keytool -keystore /usr/ca/server/server.keystore.jks -alias CARoot -import -file /usr/ca/root/ca.cert.pem -storepass app123 第四步 将已签名的证书导入密钥容器中 1$ keytool -keystore /usr/ca/server/server.keystore.jks -alias kafka.app -import -file /usr/ca/server/server.cert-signed -storepass app123 需要注意集群上每个服务节点均需要签署。 1.2.6 生成服务端信任库如果kafka集群中配置中的参数ssl.client.auth设置为： requested或required，需要为集群节点提供一个信任库，这个库中需要包含所有CA证书。 使用下面的命令将CA证书导入服务端信任库，输出为信任库文件：server.truststore.jks 1$ keytool -keystore /usr/ca/trust/server.truststore.jks -alias CARoot -import -file /usr/ca/root/ca.cert.pem -storepass app123 将CA证书导入服务端信任库，意味着信任该CA证书签名的所有证书。此属性称为信任链，在大型Kafka群集上部署SSL时特别有用。您可以使用单个CA对群集中的所有证书进行签名，并使所有计算机共享信任该CA的同一信任库。这样，所有计算机都可以对所有其他计算机进行身份验证。 1.2.7 配置Kafka BrokersKafka Broker节点支持侦听多个端口上的连接。在server.properties中配置，多个端口类型使用逗号分隔，我们以集群中kafka.app.node1为例： 1listeners=SSL://kafka.app.node1:9092 代理端需要以下SSL配置 12345ssl.keystore.location=/usr/ca/server/server.keystore.jksssl.keystore.password=app123ssl.key.password=app123ssl.truststore.location=/usr/ca/trust/server.truststore.jksssl.truststore.password=app123 其他可选配置设置： ssl.client.auth（可选） 参数控制SSL认证模式。默认参数值为requested，默认使用单向认证，即客户端认证Kafka brokers。此时，没有证书的客户端仍然可以连接集群。参数值为required，指定开启双向验证(2-way authentication)。Kafka服务器同时会验证客户端证书。生成集群建议开始双向认证。 ssl.cipher.suites（可选） 密码套件是认证，加密，MAC和密钥交换算法的命名组合，用于协商使用TLS或SSL网络协议的网络连接的安全设置。（默认为空列表） ssl.enabled.protocols 建议参数值为TLSv1.2,TLSv1.1,TLSv1。列出支持的SSL协议。生成环境不建议使用SSL，建议使用TLS。 ssl.keystore.type和ssl.truststore.type` 文件格式：JKS security.inter.broker.protocol参数 kafka集群节点（brokers）之间启用SSL通讯，需要配置该配置参数为：SSL。 最后我们总结合并一下所有的配置参数： 123456789101112listeners=SSL://kafka.app.node1:9092ssl.keystore.location=/usr/ca/server/server.keystore.jksssl.keystore.password=app123ssl.key.password=app123ssl.truststore.location=/usr/ca/trust/server.truststore.jksssl.truststore.password=app123ssl.client.auth=requiredssl.enabled.protocols=TLSv1.2,TLSv1.1,TLSv1ssl.keystore.type=JKS ssl.truststore.type=JKS ssl.endpoint.identification.algorithm=HTTPSsecurity.inter.broker.protocol=SSL 1.2.8 初步验证正常启动集群的Zookeeper集群，然后依次启动集群的所有节点。使用下面的命令检查： 1$ openssl s_client -debug -connect kafka.app.node1:9092 -tls1 该命令检查服务器的密钥库和信任库是否正确设置。命令中tls1必须是集群配置参数ssl.enabled.protocols所支持的协议。 12345678910111213141516171819202122232425262728293031Certificate chain（省略）---Server certificate-----BEGIN CERTIFICATE-----（省略）-----END CERTIFICATE-----subject=（省略）issuer=（省略）---No client certificate CA names sent---SSL handshake has read 2029 bytes and written 264 bytes---New, TLSv1/SSLv3, Cipher is ECDHE-RSA-DES-CBC3-SHAServer public key is 2048 bitSecure Renegotiation IS supportedCompression: NONEExpansion: NONESSL-Session: Protocol : TLSv1 Cipher : ECDHE-RSA-DES-CBC3-SHA Session-ID: 5E580D610AEB5DDD8BCD0D31E88180F45391109792CA3CDD1E861EB87C704261 Session-ID-ctx: Master-Key: E544FF34B993B2C3B7F7CB28D8166213F8D3A9864A82247F6948E33B319CD1A8943127DDF9B528EA73435EBC73B0DD55 Key-Arg : None Start Time: 1582828897 Timeout : 7200 (sec) Verify return code: 7 (certificate signature failure)---（省略） 如果证书未显示或有其他错误消息，则说明设置不正确。 1.3 配置kafka客户端kafka集群需要支持集群内外的客户端交互访问。安全集群的客户端同样需要进行相关安全配置。这里客户端指的是Console客户端。 1.3.1 签发客户端证书类似集群内部服务端的证书签发步骤，客户端证书签发过程入下： 生成客户端SSL密钥和证书，输出密钥容器：client.keystore.jks 12$ keytool -keystore /usr/ca/client/client.keystore.jks -alias kafka.app.node1 -validity 365 -genkey -keypass app123 -keyalg RSA -dname "CN=kafka.app.node1,OU=dccsh,O=icbc,L=shanghai,S=shanghai,C=cn" -ext SAN=DNS:kafka.app.node1 -storepass app123 从密钥容器中提取和导出客户端证书（输出文件：client.cert-file，未签名） 1$ keytool -keystore /usr/ca/client/client.keystore.jks -alias kafka.app.node1 -certreq -file /usr/ca/client/client.cert-file -storepass app123 给客户端证书签名（输出文件：client.cert-signed，已签名） 1$ openssl x509 -req -CA /usr/ca/root/ca.cert.pem -CAkey /usr/ca/root/ca.key.pem -in /usr/ca/client/client.cert-file -out /usr/ca/client/client.cert-signed -days 365 -CAcreateserial -passin pass:app123 将CA证书导入客户端密钥容器中 1$ keytool -keystore /usr/ca/client/client.keystore.jks -alias CARoot -import -file /usr/ca/root/client.cert-file -storepass app123 将已签名的证书导入密钥容器中 1$ keytool -keystore /usr/ca/client/client.keystore.jks -alias kafka.app.node1 -import -file /usr/ca/client/client.cert-signed -storepass app123 1.3.2 生成客户端信任库使用下面的命令将CA证书导入客户端信任库，输出为信任库文件：client.truststore.jks 1$ keytool -keystore /usr/ca/trust/client.truststore.jks -alias CARoot -import -file /usr/ca/root/ca.cert.pem -storepass app123 1.3.3 配置客户端客户端的console-producer和console-consumer命令需要添加相关安全配置。 如果kafka集群不需要客户端身份验证，只需配置下面的配置： 123security.protocol=SSLssl.truststore.location=/usr/ca/trust/client.truststore.jksssl.truststore.password=app123 如果需要客户端身份验证，还需要补充下面的配置信息： 123ssl.keystore.location=/usr/ca/client/client.keystore.jksssl.keystore.password=app123ssl.key.password=app123 根据我们的要求和代理配置，可能还需要其他配置设置： ssl.provider（可选）。用于SSL连接的安全提供程序的名称。 ssl.cipher.suites（可选）。密码套件是认证，加密，MAC和密钥交换算法的命名组合，用于协商使用TLS或SSL网络协议的网络连接的安全设置。 ssl.enabled.protocols = TLSv1.2，TLSv1.1，TLSv1。它应列出在代理方配置的至少一种协议 ssl.truststore.type = JKS ssl.keystore.type = JKS 最后我们总结合并一下所有的配置参数（编辑文件名为：client-ssl.properties）： 123456security.protocol=SSLssl.truststore.location=/usr/ca/trust/client.truststore.jksssl.truststore.password=app123ssl.keystore.location=/usr/ca/client/client.keystore.jksssl.keystore.password=app123ssl.key.password=app123 1.3.4 消费者生产者使用console-producer的命令： 1kafka-console-producer.sh --broker-list kafka.app.node1:9092,kafka.app.node2:9092,kafka.app.node3:9092 --topic test --producer.config client-ssl.properties 使用console-consumer的命令： 1kafka-console-consumer.sh --bootstrap-server kafka.app.node1:9092,kafka.app.node2:9092,kafka.app.node3:9092 --topic test --new-consumer --consumer.config client-ssl.properties 这里test为topic名称，在只有SSL通信加密集群中，topic的创建、删除、生产、消费并没有权限管理，依然存在安全问题。所以kafka集群需要进一步配置权限管理。 第二部分 Kafka集群权限认证Kafka集群的权限认证管理主要涉及： 身份认证（Authentication）。对客户端与服务器的连接进行身份认证，brokers和zookeeper之间的连接进行Authentication（producer 和 consumer）、其他 brokers、tools与 brokers 之间连接的认证。 权限控制（Authorization）。实现对于消息级别的权限控制，客户端的读写操作进行Authorization（生产、消费）管理。 通俗的讲，身份认证解决的是证明你是谁，而权限控制解决的是你能干什么。在Kafka中身份认证和权限控制是两套独立的安全配置。 2.1 集群权限认证策略Kafka从0.9.0.0版本后开始支持下面的SASL安全策略管理。这些安全功能为Kafka通信安全、多租户管理、集群云化提供了安全保障。截止目前Kafka 2.3版本，一共支持5种SASL方式。 验证方式 版本 说明 SASL/PLAIN 0.10.0.0 不能动态增加用户 SASL/SCRAM 0.10.2.0 可以动态增加用户。有两种方式：SASL/SCRAM-SHA-256 和SASL/SCRAM-SHA-512 SASL/GSSAPI 0.9.0.0 需要独立部署验证服务（即Kerberos服务） SASL/OAUTHBEARER 2.0.0 需自己实现接口实现token的创建和验证，需要额外Oauth服务 SASL/Delegation Token 1.1.0 补充现有 SASL 机制的轻量级认证机制 对于生产环境，SASL/PLAIN方式有个缺点：只能在JAAS文件KafkaServer参数中配置用户，集群运行期间无法动态新增用户（需要重启重新加载JAAS文件），这对维护管理带来不便。而SASL/SCRAM方式，将认证数据存储在Zookeeper中，可以动态新增用户并分配权限。 SASL/GSSAPI方式需要依赖Kerberos服务。对于一些已经部署了集中式的Kerberos服务的大厂，只需要申请一个principal即可。如果生产Kerberos认证中出现TGT分发性能瓶颈，可以使用SASL/Delegation Token模式。使用 Kafka 提供的 API 去获取对应的 Delegation Token。Broker 和客户端在做认证的时候，可以直接使用这个 token，不用每次都去 KDC 获取对应的 ticket（Kerberos 认证），减少性能压力。 同样SASL/OAUTHBEARER方式需要Oauth服务。 各种方式引入版本不同，使用依赖各有差异，需要结合自身业务特点选择合适的架构方式。 2.2 SASL/SCRAM策略配置介绍SASL/SCRAM方式将身份认证和权限控制的凭证（credential）数据均存储在Zookeeper中，需要对Zookeeper进行安全配置。 2.2.1 Zookeeper集群侧配置对Zookeeper集群中所有节点更新下面的策略后，重启集群生效。 配置zoo.cfg文件 文件尾部追加下面的配置： 123authProvider.1=org.apache.zookeeper.server.auth.SASLAuthenticationProviderrequireClientAuthScheme=sasljaasLoginRenew=3600000 新增zk_server_jaas.conf文件 配置文件内容如下： 123456Server &#123;org.apache.kafka.common.security.plain.PlainLoginModule requiredusername="admin"password="admin-secret"user_admin="admin-secret;&#125;; 其中username和password定义的用户和密钥，用于Zookeeper与Kafka集群进行认证。配置项user_admin=&quot;admin-secret&quot; 中 admin为用户名，admin-secret为密码，用于Zookeeper集群外客户端和集群内进行认证。 拷贝依赖包 将kafka文件系统中kafka/libs目录下的jar包拷贝到zookeeper/lib目录。 12345kafka-clients-2.1.1.jarlz4-java-1.5.0.jarosgi-resource-locator-1.0.1.jarslf4j-api-1.7.25.jarsnappy-java-1.1.7.2.jar 若没有引入依赖包，启动时会报找不到org.apache.kafka.common.security.plain.PlainLoginModule包的错误。 修改zookeeper启动参数 修改bin/zkEnv.sh文件, 在文件尾追加下面的配置内容。该配置完成引入的包的加载。变量CLASSPATH和SERVER_JVMFLAGS都会在Zookeeper启动时传给JVM虚拟机。 下面的配置中$ZOOKEEPER_HOME是zookeeper的环境变量，如果没有配置，使用绝对路径即可。 1234for i in $ZOOKEEPER_HOME/lib/*.jar; do CLASSPATH="$i:$CLASSPATH"doneSERVER_JVMFLAGS=" -Djava.security.auth.login.config=$ZOOKEEPER_HOME/conf/zk_server_jaas.conf" 2.2.2 kafka集群侧配置kafka集群中每一台节点均需要更新下面的配置。 新增kafka_server_scram_jaas.conf文件（在config目录中） 12345678910KafkaServer &#123;org.apache.kafka.common.security.scram.ScramLoginModule requiredusername="admin"password="admin-secret";# 自定义用户：# user_admin="admin-secret"# user_alice="alice-secret"# user_reader="reader-secret"# user_writer="writer-secret";&#125;; 其中配置username和password为Kafka集群之间通讯的SCRAM凭证，用户名为admin，密码为admin-secret。 配置中类似user_XXX格式的配置项为自定义用户。如果是SASL/PLAIN方式，用户只能在该文件中定义，不能动态新增。我们使用SASL/SCRAM方式，可以后续动态声明admin用户，不再此处进行配置。 更新Kafka的配置文件server.properties（在config目录中）： 12345678910111213141516171819#SASL CONFIGlisteners=SASL_SSL://kafka.app.node1:9092sasl.enabled.mechanisms=SCRAM-SHA-512sasl.mechanism.inter.broker.protocol=SCRAM-SHA-512authorizer.class.name=kafka.security.auth.SimpleAclAuthorizer#allow.everyone.if.no.acl.found=truesuper.users=User:admin#SSL CINFIGssl.keystore.location=/usr/ca/server/server.keystore.jksssl.keystore.password=app123ssl.key.password=app123ssl.truststore.location=/usr/ca/trust/server.truststore.jksssl.truststore.password=app123ssl.client.auth=requiredssl.enabled.protocols=TLSv1.2,TLSv1.1,TLSv1ssl.keystore.type=JKSssl.truststore.type=JKSssl.endpoint.identification.algorithm=HTTPSsecurity.inter.broker.protocol=SASL_SSL 需要注意参数allow.everyone.if.no.acl.found，如果开启参数开关，当客户端和集群交互时候未找到ACL策略时，允许所有类型的访问操作。建议该参数关闭（false）。 参数security.inter.broker.protocol指定集群brokers之间的通讯协议。不加密协议有：SASL_SSL、SASL_PLAINTEXT、PLAINTEXT；加密协议有：SSL。为了提高节点之间的交互性能，内部网络环境建议使用非加密协议。这里使用加密的SASL_SSL协议。 参数super.users指定了集群的超级用户为：admin。注意如果指定多个超级用户，每个用户使用分号隔开，例如：super.users=User:admin;User:alice 参数sasl.enabled.mechanisms列出支持的认证方式。即可以支持多种。 参数sasl.mechanism.inter.broker.protocol指定集群内部的认证方式。Kafka仅支持最小迭代次数为4096的强哈希函数SHA-256和SHA-512。所以有SCRAM-SHA-512和SCRAM-SHA-256两种方式。 配置kafka启动环境变量（bin目录下面的kafka-run-class.sh） 为 Kafka 添加 java.security.auth.login.config 环境变量（配置文件路径）。并且在启动模式中添加KAFKA_SASL_OPTS。 12345678# 截取配置文件片段：KAFKA_SASL_OPTS='-Djava.security.auth.login.config=/opt/software/kafka/config/kafka_server_scram_jaas.conf'# Launch modeif [ "x$DAEMON_MODE" = "xtrue" ]; then nohup $JAVA $KAFKA_HEAP_OPTS $KAFKA_JVM_PERFORMANCE_OPTS $KAFKA_GC_LOG_OPTS $KAFKA_SASL_OPTS $KAFKA_JMX_OPTS $KAFKA_LOG4J_OPTS -cp $CLASSPATH $KAFKA_OPTS "$@" &gt; "$CONSOLE_OUTPUT_FILE" 2&gt;&amp;1 &lt; /dev/null &amp;else exec $JAVA $KAFKA_HEAP_OPTS $KAFKA_JVM_PERFORMANCE_OPTS $KAFKA_GC_LOG_OPTS $KAFKA_SASL_OPTS $KAFKA_JMX_OPTS $KAFKA_LOG4J_OPTS -cp $CLASSPATH $KAFKA_OPTS "$@"fi 2.2.3 SCRAM认证管理在集群的配置文件kafka_server_scram_jaas.conf中，定义了集群内部的认证用户。对于客户端和集群之间认证可以使用kafka-configs.sh来动态创建。 创建用户SCRAM凭证 例如集群中的超级用户admin用户，使用下面的命令创建： 1$ kafka-configs.sh --zookeeper kafka.app.node1:2181,kafka.app.node2:2181,kafka.app.node3:2181 --alter --add-config 'SCRAM-SHA-256=[password=admin-secret],SCRAM-SHA-512=[password=admin-secret]' --entity-type users --entity-name admin 创建自定义普通用户alice。 1$ kafka-configs.sh --zookeeper kafka.app.node1:2181,kafka.app.node2:2181,kafka.app.node3:2181 --alter --add-config 'SCRAM-SHA-256=[iterations=8192,password=alice-secret],SCRAM-SHA-512=[password=alice-secret]' --entity-type users --entity-name alice 查看SCARM凭证 1$ kafka-configs.sh --zookeeper kafka.app.node1:2181,kafka.app.node2:2181,kafka.app.node3:2181 --describe --entity-type users --entity-name admin 删除SCRAM凭证 1$ kafka-configs.sh --zookeeper kafka.app.node1:2181,kafka.app.node2:2181,kafka.app.node3:2181 --alter --delete-config 'SCRAM-SHA-512' --entity-type users --entity-name alice 2.3 Kafka客户端配置Kafka集群配置了认证，那么对于Console客户端访问集群自然需要配置认证信息。可集群节点内部通讯凭证的认知，同样需要定义JAAS文件。加入我们自定义了用户alice，JAAS文件名为：kafka_console_client_jaas.conf，配置内容如下： 12345KafkaClient &#123;org.apache.kafka.common.security.scram.ScramLoginModule requiredusername="alice"password="alice-secret";&#125;; 然后更新kafka-console-producer.sh脚本和kafka-console-consumer.sh脚本的启动参数。 12345# 文件截取更新部分：if [ "x$KAFKA_OPTS" ]; thenexport KAFKA_OPTS="-Djava.security.auth.login.config=/opt/software/kafka/config/kafka_write_jaas.conf"fi 在配置SSL时候，我们新建了client-ssl.properties配置文件，作为Console客户端启动配置。在集群启用SASL_SSL后，我们同步更新如下： 123456security.protocol=SASL_SSLssl.truststore.location=/usr/ca/trust/client.truststore.jksssl.truststore.password=app123ssl.keystore.location=/usr/ca/client/client.keystore.jksssl.keystore.password=app123ssl.key.password=app123 至此Console客户端已经配置完毕，但目前Console客户端还不能通过命令方式和集群进行交互，因为我们指定的用户对于集群的资源还没有任何权限。需要对用户进行集群资源的ACL控制设置，赋予相关权限。 2.4 ACL控制Kafka权限资源包含Topic、Group、Cluster、TransactionalId（事务id），每个资源涉及的权限内容如下： 资源类型 权限类型 Topic Read,Write,Describe,Delete,DescribeConfigs,AlterConfigs,All Group Read,Describe,All Cluster Create,ClusterAction,DescribeConfigs,AlterConfigs,IdempotentWrite,Alter,Describe,All TransactionalId Describe,Write,All 对于常用类型进行说明： 权限 说明 Read 读取topic、group信息 Write 写topic、TransactionalId（存储在内部topic） Delete 删除topic Create 创建topic ALTER 修改topic Describe 获取topic、group、TransactionalId信息 ALL 所有权限 Kafka提供ACL管理脚本：kafka-acls.sh。 2.4.1 更新脚本配置认证数据均存储在Zookeeper集群中，需要和Zookeeper交互自然需要配置相关认证信息。 首先需要新建JAAS文件，文件名为：zk_client_jaas.conf。这里的用户已经在Zookeeper集群中进行定义。 12345Client &#123;org.apache.kafka.common.security.plain.PlainLoginModule requiredusername="admin"password="admin-secret";&#125;; 最后更新kafka-acls.sh脚本： 12345# 截取更新部分if [ "x$KAFKA_OPTS" ]; thenexport KAFKA_OPTS="-Djava.security.auth.login.config=/opt/software/kafka/config/zk_client_jaas.conf"fi 当然Kafka集群的配置文件中已经开启了ACL： 1authorizer.class.name=kafka.security.auth.SimpleAclAuthorizer 至此完成配置。 2.4.2 ACL配置根据官网的介绍，ACL的格式如下： “Principal P is [Allowed/Denied] Operation O From Host H On Resource R” 参数含义描述如下： principal：指定一个Kafka user； operation：指定一个具体的操作类型，例如：Read, Write, Delete等； Host：表示与集群交互的客户端IP地址，如果是通配符‘*’表示所有IP。目前不支持主机名（hostname）形式，只能是IP地址； Resource：指定一种Kafka资源类型（共有4种类型）； 例如下面的ACL命令： 1$ sh kafka-acls.sh --authorizer kafka.security.auth.SimpleAclAuthorizer --authorizer-properties zookeeper.connect=kafka.app.node1:2181,kafka.app.node2:2181,kafka.app.node3:2181 --add --allow-principal User:alice --allow-host '*' --operation ALL --topic test 赋权之后，用户alice对test具有全部权限，并且访问请求可以是来自任何IP的客户端。 常用参数的补充说明： 对主机IP的限制参数，allow-host指定允许的IP，deny-host指定禁用IP； 新增和删除一个赋权策略，分别使用：add和remove 2.4.3 ACL策略查看使用参数list参看ACL策略。例如： 1$ sh kafka-acls.sh --authorizer kafka.security.auth.SimpleAclAuthorizer --authorizer-properties zookeeper.connect=kafka.app.node1:2181,kafka.app.node2:2181,kafka.app.node3:2181 --list --topic test-topic 该查看命令显示test-topic资源相关的所有ACL策略。 2.4.4 超级用户kafka集群的配置文件server.properties中定义了超级用户（Super Users），超级用户不在ACL控制范围内，默认可以访问集群中所有资源，并具备所有权限。 2.5 权限认证数据访问集群的认证数据存储在Zookeeper，可以通过Zookeeper的console客户端访问认证数据。 （待补充） 2.6 SSL和SASL的说明SSL是传输层安全协议，是间于传输层（TCP/IP）和应用层（HTTP）的协议，SSL是对整个传输过程的加密，SSL是对客户端和服务器之间传输的所有数据进行加密。假如在配置的时候使用了SASL，但是没有使用SSL，那么除了账号密码外，所有的传输内容都是裸奔的。 所以生产集群采用SSL和SASL结合方式，即SSL_SASL方式。 第三部分 安全集群的客户端3.1 开发语言类3.1.1 Python客户端目前市面上kafka的python API常用的有三种： 第一种 kafka 该项目是kafka-python的老项目，2017年后调整为kafka-python项目。 第二种 kafka-python 最新版本为2.0，首先从客户端的密钥库中导出CA证书。 1$ keytool -exportcert -alias CARoot -keystore client.keystore.jks -rfc -file ca.cert.pem 生产者和消费者的案例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding: utf-8 -*-from kafka import KafkaConsumer, KafkaProducerimport kafkaimport sslimport loggingimport time#logging.basicConfig(level=logging.DEBUG)try: bootstrap_servers = 'kafka.itdw.node1:9092,kafka.itdw.node2:9092,kafka.itdw.node3:9092' topic = "test" sasl_mechanism = "SCRAM-SHA-512" username = "alice" password = "alice-secret" security_protocol = "SASL_SSL" # CA 证书路径 ssl_cafile = 'ca.cert.pem' # SSL context = ssl.SSLContext(ssl.PROTOCOL_SSLv23) context.verify_mode = ssl.CERT_NONE context.check_hostname = False context.load_verify_locations(ssl_cafile) # 消费者 consumer = KafkaConsumer(topic, bootstrap_servers=bootstrap_servers, api_version=(0, 10), security_protocol=security_protocol, ssl_context=context, sasl_mechanism = sasl_mechanism, sasl_plain_username = username, sasl_plain_password = password ) # 生产者 producer = KafkaProducer(bootstrap_servers=bootstrap_servers, api_version=(0, 10), acks='all', retries=1, security_protocol=security_protocol, ssl_context=context, sasl_mechanism=sasl_mechanism, sasl_plain_username=username, sasl_plain_password=password ) # 生产数据 for i in range(10): producer.send(topic, bytes("测试",encoding='utf8')) producer.flush() # 消费数据 for msg in consumer: print(msg)except Exception as e: print(e) 需要的注意的事项有： Kafka集群启用主机名模式，所以应用程序运行节点的hosts文件需要配置Kafka集群节点的域名映射。 ssl_context参数为包装套接字连接的预配置SSLContext。如果非None，将忽略所有其他ssl_ *配置。 主机名验证问题。如果证书中域名和主机名不匹配，客户端侧需要配置需要调整如下： 12ssl_ctx.check_hostname=Falsessl_ctx.verify_mode = CERT_NONE 如果不提前预配置SSLContext，还需要客户端的证书。 1$ keytool -exportcert -alias localhost -keystore client.keystore.jks -rfc -file client.cert.pem 生产者的参数需要添加： 1234567891011121314ssl_certfile = "client.cert.pem"ssl_cafile = "ca.cert.pem"producer = KafkaProducer(bootstrap_servers=bootstrap_servers, api_version=(0, 10), acks='all', retries=1, security_protocol=security_protocol, ssl_context=context, sasl_mechanism=sasl_mechanism, sasl_plain_username=username, sasl_plain_password=password, ssl_check_hostname=False, ssl_certfile=ssl_certfile, ssl_cafile=ssl_cafile) 第三种 confluent-kafka confluent-kafka包由confluent公司开源，主要是对C/C++客户端包（librdkafka）的封装。案例代码如下： 12345678910111213141516171819202122232425# -*- coding: utf-8 -*-from confluent_kafka import Producer# 回调函数def delivery_report(err, msg): """ Called once for each message produced to indicate delivery result. Triggered by poll() or flush(). """ if err is not None: print(’Message delivery failed: &#123;&#125;‘.format(err)) else: print(‘Message delivered to &#123;&#125; [&#123;&#125;]‘.format(msg.topic(), msg.partition()))if __name__ == ‘__main__‘: producerConfing = &#123;"bootstrap.servers": 'kafka.itdw.node1:9092,kafka.itdw.node2:9092,kafka.itdw.node3:9092', "security.protocol": 'SASL_SSL', "sasl.mechanisms": 'SCRAM-SHA-256', "sasl.username": 'alice', "sasl.password": 'alice-secret', "ssl.ca.location": 'ca.cert.pem' &#125; ProducerTest = Producer(producerConfing) ProducerTest.poll(0) ProducerTest.produce(‘testTopic‘, ‘confluent kafka test‘.encode(‘utf-8‘),callback=delivery_report) ProducerTest.flush() 3.1.2 Go客户端我们的Go语言中常用的Kafka的客户端包有： 1234"github.com/Shopify/sarama""github.com/bsm/sarama-cluster""github.com/confluentinc/confluent-kafka-go/kafka""github.com/segmentio/ksuid" 其中最常用的是sarama，案例参考github项目。 3.1.3 Java客户端生产者： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.kafka.security;import org.apache.kafka.clients.CommonClientConfigs;import org.apache.kafka.clients.producer.KafkaProducer;import org.apache.kafka.clients.producer.Producer;import org.apache.kafka.clients.producer.ProducerConfig;import org.apache.kafka.clients.producer.ProducerRecord;import org.apache.kafka.common.config.SaslConfigs;import org.apache.kafka.common.config.SslConfigs;import java.util.Properties;import java.util.Random;public class KafkaProducerWithSASL_SSL &#123; private static final String KAFKA_TOPIC = "topsec"; private static final String BOOTSTRAP_SERVER = "docker31:9092"; private static final String[] strs = new String[]&#123;"zhao", "qian", "sun", "li", "zhou", "wu", "zheng", "wang", "feng", "chen"&#125;; private static final Random r = new Random(); public static void main(String[] args) &#123; try &#123; producer(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private static void producer() throws InterruptedException &#123; Properties props = new Properties(); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, BOOTSTRAP_SERVER); //SASL_SSL加密 props.put(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, "SASL_SSL"); props.put(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG, "D:\\Download\\ca\\trust\\client.truststore.jks"); props.put(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, "hadoop"); // SSL用户认证 props.put(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG, "D:\\Download\\ca\\client\\client.keystore.jks"); props.put(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, "hadoop"); props.put(SslConfigs.SSL_KEY_PASSWORD_CONFIG, "hadoop"); //SASL用户认证 props.put(SaslConfigs.SASL_JAAS_CONFIG,"org.apache.kafka.common.security.scram.ScramLoginModule required username=\"admin\" password=\"admin-secret\";"); props.put(SaslConfigs.SASL_MECHANISM, "SCRAM-SHA-512"); props.put(ProducerConfig.ACKS_CONFIG, "all"); props.put(ProducerConfig.RETRIES_CONFIG, 0); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringSerializer"); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringSerializer"); props.put(ProducerConfig.BATCH_SIZE_CONFIG, 16384); props.put(ProducerConfig.LINGER_MS_CONFIG, 1); props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 33554432); Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props); while (true) &#123; producer.send(new ProducerRecord&lt;&gt;(KAFKA_TOPIC, strs[r.nextInt(10)],strs[r.nextInt(10)])); Thread.sleep(2000); &#125; &#125;&#125; 消费者： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.topsec.kafka.security;import org.apache.kafka.clients.CommonClientConfigs;import org.apache.kafka.clients.consumer.ConsumerConfig;import org.apache.kafka.clients.consumer.ConsumerRecord;import org.apache.kafka.clients.consumer.ConsumerRecords;import org.apache.kafka.clients.consumer.KafkaConsumer;import org.apache.kafka.common.config.SaslConfigs;import org.apache.kafka.common.config.SslConfigs;import java.util.Collections;import java.util.Properties;public class KafkaConsumerWithSASLAndSSL &#123; private static final String KAFKA_TOPIC = "topsec"; private static final String BOOTSTRAP_SERVER = "docker31:9092"; public static void main(String[] args) &#123; consumer(); &#125; private static void consumer() &#123; Properties props = new Properties(); //SASL_SSL加密配置 props.put(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, "SASL_SSL"); props.put(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG, "D:\\Download\\ca\\trust\\client.truststore.jks"); props.put(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, "hadoop"); //SSL身份验证配置 props.put(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG, "D:\\Download\\ca\\client\\client.keystore.jks"); props.put(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, "hadoop"); props.put(SslConfigs.SSL_KEY_PASSWORD_CONFIG, "hadoop"); //SASL身份验证 props.put(SaslConfigs.SASL_JAAS_CONFIG,"org.apache.kafka.common.security.scram.ScramLoginModule required username=\"admin\" password=\"admin-secret\";"); props.put(SaslConfigs.SASL_MECHANISM, "SCRAM-SHA-512"); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, BOOTSTRAP_SERVER); props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest"); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringDeserializer"); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringDeserializer"); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, "true"); props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, "1000"); props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, "6000"); KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props); consumer.subscribe(Collections.singletonList(KAFKA_TOPIC)); while (true) &#123; ConsumerRecords&lt;String, String&gt; records = consumer.poll(2000); for (ConsumerRecord&lt;String, String&gt; record : records) &#123; System.out.printf("offset = %d, key = %s, value = %s, partition = %d %n", record.offset(), record.key(), record.value(), record.partition()); &#125; &#125; &#125;&#125; 3.2 组件类3.2.1 Console客户端（待补充） 3.2.2 Flume客户端目前Flume项目还不支持SASL/SCRAM方式的认证方式，只支持下面三种方式： SASL_PLAINTEXT - 无数据加密的 Kerberos 或明文认证 SASL_SSL - 有数据加密的 Kerberos 或明文认证 SSL - 基于TLS的加密，可选的身份验证 3.2.3 Logstash客户端Logstash和Kafka交互使用Kafka output plugin插件实现。配置文件如下： 123456789101112131415161718output &#123; kafka &#123; id =&gt; "kafkaSLL_SASL" codec =&gt; "json" ssl_endpoint_identification_algorithm =&gt; "" bootstrap_servers =&gt; "kafka.app.node1:9092,kafka.app.node2:9092,kafka.app.node3:9092" ssl_keystore_location =&gt; "/etc/logstash/certificates/client.keystore.jks" ssl_keystore_password =&gt; "app123" ssl_keystore_type =&gt; "JKS" ssl_truststore_location =&gt; "/etc/logstash/certificates/client.truststore.jks" ssl_truststore_password =&gt; "app123" ssl_truststore_type =&gt; "JKS" sasl_mechanism =&gt; "SCRAM-SHA-512" security_protocol =&gt; "SASL_SSL" sasl_jaas_config =&gt; "org.apache.kafka.common.security.plain.PlainLoginModule required username='alice' password='alice-secret';" topic_id =&gt; "test" &#125;&#125; 第四部分 加密认证集群的性能压测启用SSL时性能会降低，其大小取决于CPU类型和JVM实现。 （待补充） 参考文献及资料1、Kafka官网对安全类功能介绍，链接：http://kafka.apache.org/documentation/#security 2、Kafka ACLs in Practice – User Authentication and Authorization，链接：https://developer.ibm.com/opentech/2017/05/31/kafka-acls-in-practice/ 3、维基百科（数字证书），链接：https://zh.wikipedia.org/wiki/公開金鑰認證 4、SSL技术白皮书，链接：https://blog.51cto.com/xuding/1732723 5、Kafka权限管理，链接：https://www.jianshu.com/p/09129c9f4c80 5、Flume文档，链接：https://flume.apache.org/FlumeUserGuide.html#kafka-sink]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习系列(一)Go语言Win开发环境部署]]></title>
    <url>%2F2020%2F01%2F31%2F2020-01-31-Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97(%E4%B8%80)Go%E8%AF%AD%E8%A8%80Win%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 windows下安装 第二部分 配置环境变量 第三部分 IDE配置 第四部分 HelloWorld案例 参考文献及资料 背景Go语言的官方网站：https://golang.org/ 由于防火墙原因，请大家在这个网站下载：https://studygolang.com/dl 第一部分 windows下安装下载的是msi包，直接执行安装即可。 go1.12.5.windows-amd64.msi 第二部分 配置环境变量Go 语言需要配置 GOROOT 和 Path 两个环境变量：GOROOT 和 GOPATH。如果使用msi包安装，那么会自动配置好两个环境变量。 可以使用下面的命令检查变量： 1234567891011121314151617181920212223242526272829C:\Users\rongxiang&gt;go envset GOARCH=amd64set GOBIN=set GOCACHE=C:\Users\rongxiang\AppData\Local\go-buildset GOEXE=.exeset GOFLAGS=set GOHOSTARCH=amd64set GOHOSTOS=windowsset GOOS=windowsset GOPATH=C:\Users\rongxiang\goset GOPROXY=set GORACE=set GOROOT=C:\Goset GOTMPDIR=set GOTOOLDIR=C:\Go\pkg\tool\windows_amd64set GCCGO=gccgoset CC=gccset CXX=g++set CGO_ENABLED=1set GOMOD=set CGO_CFLAGS=-g -O2set CGO_CPPFLAGS=set CGO_CXXFLAGS=-g -O2set CGO_FFLAGS=-g -O2set CGO_LDFLAGS=-g -O2set PKG_CONFIG=pkg-configset GOGCCFLAGS=-m64 -mthreads -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=C:\Users\RONGXI~1\AppData\Local\Temp\go-build030961398=/tmp/go-build -gno-record-gcc-switches 查看版本： 12C:\Users\rongxiang&gt;go versiongo version go1.12.5 windows/amd64 默认情况下，GOROOT = C:\Go；GOPATH = C:\Users\用户名\go。如果需要调整，修改环境变量参数即可。 第三部分 IDE配置使用Jetbrain公司的GoLand IDE（https://www.jetbrains.com/go/）。 下载安装成功后，打来GoLand。菜单File–&gt;Settings–&gt;GO中有两个配置项：GOROOT、GOPATH。 第四部分 HelloWorld案例配置好IDE环境，我们新建第一个项目（project）。 4.1 创建HelloWorld项目菜单栏File–&gt;New–&gt;Project,打开新建项目对话框。配置项目的文件位置（Location），例如我们配置为： D:\golang\workspace\HelloWorld，然后确定就新建Go项目。 在项目中新建main.go文件： 12345package mianimport "fmt"func main() &#123; fmt.Println("Hello World!") 4.2 编译并运行选中main.go文件，邮件选择运行。IDE将编译，并运行： 123Hello World!Process finished with exit code 0 控制台上打印上面的信息，说明执行成功。 参考文献及资料1、Go入门指南，https://github.com/Unknwon/the-way-to-go_ZH_CN 2、a tour of go，https://tour.golang.org/welcome/1]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一个Spring Boot练习项目]]></title>
    <url>%2F2020%2F01%2F11%2F2020-01-01-SpringBoot%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%EF%BC%88%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 开发环境准备 第二部分 使用Maven构建项目 第三部分 项目目录结构 第四部分 编写HelloWorld项目 参考文献及资料 背景第一次使用Spring Boot构建测试项目，实现一个简单的Http请求处理，通过这个例子对Spring Boot有一个初步的了解。 第一部分 开发环境准备 Maven版本：Maven 3，version 3.3.9 Java版本：Java 1.8（Java8） 第二部分 使用Maven构建项目Spring官网提供Spring Initializr工具生成项目 第一步：登录Spring Initializr网站： https://start.spring.io/ 第二步：配置项目的参数： Group ID是项目组织唯一的标识符，实际对应项目中的package包。 Artifact ID是项目的唯一的标识符，实际对应项目的project name名称，Artifact不可包含大写字母。 然后点击生成项目压缩文件，并下载到本地。 第三步：使用IDE加载项目（使用IntelliJ IDEA） 菜单中选择File–&gt;New–&gt;Project from Existing Sources... 选择解压后的项目文件夹，点击OK 点击Import project from external model并选择Maven，点击Next到底为止。 第三部分 项目目录结构开发环境是Win7环境，导入后，使用tree /f命令查看项目结构目录： 123456789101112131415161718192021222324252627282930313233# tree /f│ .gitignore│ HELP.md│ mvnw│ mvnw.cmd│ pom.xml├─.idea│ │ azureSettings.xml│ │ compiler.xml│ │ misc.xml│ │ workspace.xml│ └─inspectionProfiles│ Project_Default.xml├─.mvn│ └─wrapper│ maven-wrapper.jar│ maven-wrapper.properties│ MavenWrapperDownloader.java└─src ├─main │ ├─java │ │ └─com │ │ └─example │ │ └─demo │ │ DemoApplication.java │ └─resources │ application.properties └─test └─java └─com └─example └─demo DemoApplicationTests.java .gitignore文件是git控制文件。 mvnw(linux shell)和mvnw.cmd(windows),还有.mvn文件夹(包含Maven Wrapper Java库及其属性文件)。mvnw全名是Maven Wrapper,它的原理是在maven-wrapper.properties文件中记录你要使用的Maven版本，当用户执行mvnw clean 命令时，发现当前用户的Maven版本和期望的版本不一致，那么就下载期望的版本，然后用期望的版本来执行mvn命令，比如刚才的mvn clean。带有mvnw文件项目，只要有java环境，仅仅通过使用本项目的mvnw脚本就可以完成编译，打包，发布等一系列操作。 HELP.mdMaven的帮助文件。 pom.xmlProject Object Model 的缩写，即项目对象模型。maven 的配置文件，用以描述项目的各种信息。 .idea/文件夹来存放项目的配置信息。其中包括版本控制信息、历史记录等等。 src/main/java下的程序入口：DemoApplication.java。 src/main/resources下的配置文件：application.properties。 src/test/下的测试入口：DemoApplicationTests.java。 第四部分 编写HelloWorld项目引入Web模块，在pom.xml文件添加下面的依赖包： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 新建controller程序(HelloSpringBootController)： 123456789101112package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloSpringBootController &#123; @RequestMapping("/") public String hello()&#123; return "Hello, SpringBoot!"; &#125;&#125; 完成后项目的结构如下： 1234567891011121314151617181920├─src│ ├─main│ │ ├─java│ │ │ └─com│ │ │ └─example│ │ │ └─demo│ │ │ │ DemoApplication.java│ │ │ ││ │ │ └─controller│ │ │ HelloSpringBootController.java│ │ ││ │ └─resources│ │ application.properties│ ││ └─test│ └─java│ └─com └─example └─demo DemoApplicationTests.java 最后使用maven编译： 12mvn clean mvn package #编译项目 会生成编译结果，在项目根目录生成target文件目录。其中demo-0.0.1-SNAPSHOT.jar为编译后的入口程序。在IDEA中，或者使用java -jar demo-0.0.1-SNAPSHOT.jar命令在win CMD命令窗口中运行。 1234567891011121314151617181920"C:\Program Files\Java\jdk-10.0.2\bin\java.exe" -Dfile.encoding=GBK -jar C:\Users\rongxiang\Desktop\SpringBoot\demo\target\demo-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.2.RELEASE)2020-01-12 13:56:37.333 INFO 5060 --- [ main] com.example.demo.DemoApplication : Starting DemoApplication v0.0.1-SNAPSHOT on rongxiang-PC with PID 5060 (C:\Users\rongxiang\Desktop\SpringBoot\demo\target\demo-0.0.1-SNAPSHOT.jar started by rongxiang in C:\Users\rongxiang\Desktop\SpringBoot\demo)2020-01-12 13:56:37.338 INFO 5060 --- [ main] com.example.demo.DemoApplication : No active profile set, falling back to default profiles: default2020-01-12 13:56:40.479 INFO 5060 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)2020-01-12 13:56:40.497 INFO 5060 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]2020-01-12 13:56:40.497 INFO 5060 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.29]2020-01-12 13:56:40.598 INFO 5060 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2020-01-12 13:56:40.598 INFO 5060 --- [ main] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 3142 ms2020-01-12 13:56:40.945 INFO 5060 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService 'applicationTaskExecutor'2020-01-12 13:56:41.227 INFO 5060 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ''2020-01-12 13:56:41.233 INFO 5060 --- [ main] com.example.demo.DemoApplication : Started DemoApplication in 4.773 seconds (JVM running for 5.475) 在本地启了一个web服务（Tomcat started on port(s): 8080 (http)），对外服务端口为8080。 浏览器中输入url地址（http://localhost:8080/），网页显示“Hello, SpringBoot!”，说明服务服务正常。 注意： 如果运行工程，出现这个报错信息：Failed to clean project: Failed to delete 由于之前编译的工程还在运行，无法clean，导致maven生命周期无法继续进行。即由于已启动了另一个tomcat 进程，导致报错,关闭tomcat进程即可。可以在程序控制台中终止该进程即可。 参考文献及资料1、Spring官网，链接：https://spring.io/]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[外网环境访问内网（NAT）Kafka集群介绍]]></title>
    <url>%2F2019%2F09%2F07%2F2019-09-07-%E5%A4%96%E7%BD%91%E7%8E%AF%E5%A2%83%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%EF%BC%88NAT%EF%BC%89Kafka%E9%9B%86%E7%BE%A4%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 Kafka几个配置参数介绍 第二部分 外网环境访问内网（NAT）Kafka集群配置 第三部分 总结 参考文献及资料 背景其实这是一个踩坑笔记。首先介绍踩坑背景。生产环境我们有两个网络区域，记为网络区域A（内网）、网络区域B（外网），其中为了外网环境能访问内网环境，内网对内部IP实施了IP映射（NAT），将内网IP映射为外部IP。Kafka版本为：kafka_2.11-0.10.2.0。IP清单及网络数据流图如下： hostname 内网ip 外网Ip kafka.node1 192.168.1.1 10.0.0.1 kafka.node2 192.168.1.2 10.0.0.2 kafka.node3 192.168.1.3 10.0.0.3 整个架构图为： 外网网络区域的客户端开始使用NAT地址（10.0.0.1-3）地址访问内部kafka，发现无法生产和消费kafka数据（telnet netip 9092是通的），会报解析服务器hostname失败的错误。而内部网络的客户端使用内网地址（192.168.1.1-3）是可以正常生产和消费kafka数据。 原因：advertised.listeners配置的是内网实地址，这个地址注册到Zookeeper中，当消费者和生产者访问时，Zookeeper将该地址提供给消费者和生产者。由于是内网地址，外网根本看不到这个地址（路由寻址）。所以无法获取元数据信息，通信异常。 第一部分 Kafka几个配置参数介绍首先要了解一下几个配置： host.name已弃用。 仅当listeners属性未配置时被使用，已用listeners属性代替。表示broker的hostname。 advertised.host.name已弃用。仅当advertised.listeners或者listeners属性未配置时被使用。官网建议使用advertised.listeners。该配置的意思是注册到zookeeper上的broker的hostname或ip。是提供给客户端与kafka通信使用的。如果没有设置则使用host.name。 listeners监听列表，broker对外提供服务时绑定的IP和端口。多个以逗号隔开，如果监听器名称是一个安全的协议， listener.security.protocol.map也必须设置。主机名称设置0.0.0.0绑定所有的接口，主机名称为空则绑定默认的接口。如： 1listeners = PLAINTEXT://myhost:9092,SSL://:9091 CLIENT://0.0.0.0:9092,REPLICATION://localhost:9093 如果未指定该配置，则使用java.net.InetAddress.getCanonicalHostName()函数的的返回值。 advertised.listeners客户端使用。发布至zookeeper的监听，broker会上送此地址到zookeeper，zookeeper会将此地址提供给消费者和生产者，消费者和生产者根据此地址获取消息。如果和上面的listeners不同则以此为准，在IaaS环境，此配置项可能和 broker绑定的接口主机名称不同，如果此配置项没有配置则以上面的listeners为准。 第二部分 外网环境访问内网（NAT）Kafka集群配置2.1 配置hosts方式 Kafka集群节点配置 每一台Kafka节点的hosts节点配置内部地址映射： 192.168.1.1 kafka.node1192.168.1.2 kafka.node2192.168.1.3 kafka.node3 Kafka中的配置文件（config/server.properties配置文件） advertised.listeners=PLAINTEXT://kafka.node1:9092 advertised.listeners=PLAINTEXT://kafka.node2:9092 advertised.listeners=PLAINTEXT://kafka.node3:9092 客户端节点配置 客户端的hosts文件也需要配置外部地址映射： 10.0.0.1 kafka.node110.0.0.2 kafka.node210.0.0.3 kafka.node3 应用程序使用 bootstrap.servers: [‘kafka.node1:9092’,’kafka.node2:9092’,’kafka.node3:9092’] 配置完成后，重启Kafka集群，重新使用客户端链接，测试客户端可以正常向Topic生产和消费数据。 2.2 内外部流量分离通常对于外部网络访问内网安全区域，架构使用安全套接字层 (SSL) 来保护外部客户端与 Kafka 之间的流量。而使用明文进行内部网络的broker间的通信。当 Kafka 侦听器绑定到用于内部和外部通信的网络接口时，配置侦听器就非常简单了。但在许多情况下，例如在云原生环境上部署时，集群中 Kafka broker 的外部通告地址将与 Kafka 使用的内部网络接口不同。在此情况下，可以 server.properties 中的参数 advertised.listeners 进行如下配置： 1234567891011# Configure protocol maplistener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:SSL# Use plaintext for inter-broker communicationinter.broker.listener.name=INTERNAL# Specify that Kafka listeners should bind to all local interfaceslisteners=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:9093# Separately, specify externally visible addressadvertised.listeners=INTERNAL://kafkabroker-n.mydomain.com:9092,EXTERNAL://kafkabroker-n.mydomain.com:9093 内部使用9092端口，而外部网络使用9093端口。 第三部分 总结Kafka集群在内外网网络环境下，需要关注地址映射。使用hosts 本地DNS进行主机名和内外地址的映射。至此爬出该坑。 参考文献及资料1、kafka - advertised.listeners和listeners，链接：https://www.cnblogs.com/fxjwind/p/6225909.html 2、Kafka从上手到实践-Kafka集群：Kafka Listeners，链接：http://www.devtalking.com/articles/kafka-practice-16/ 3、使用 Cloud Dataflow 处理来自 Kafka 的外部托管消息 链接：https://cloud.google.com/solutions/processing-messages-from-kafka-hosted-outside-gcp?hl=zh-cn 4、Kafka Listeners - Explained 链接：https://rmoff.net/2018/08/02/kafka-listeners-explained/]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Helm简介和安装部署]]></title>
    <url>%2F2019%2F08%2F08%2F2019-08-08-Helm%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 Minikube集群启动 第一部分 Kubernetes中StatefulSet介绍 第三部分 部署Zookeeper集群 第四部分 部署Kafka集群 第五部分 总结 参考文献及资料 背景Application deployment management for Kubernetes。 第一部分 Helm的部署Helm是由helm CLI和Tiller组成，是典型的C/S应用。helm运行与客户端，提供命令行界面，而Tiller应用运行在Kubernetes内部。 1.1 部署Helm CLI客户端helm客户端是一个单纯的可执行文件，我们从github上直接下载压缩包（由于墙的原因可能很慢）： 1root@deeplearning:/data/helm# wget https://get.helm.sh/helm-v2.14.3-linux-amd64.tar.gz 解压缩介质文件： 123456root@deeplearning:/data/helm# tar -zxvf helm-v2.14.3-linux-amd64.tar.gz linux-amd64/linux-amd64/helmlinux-amd64/README.mdlinux-amd64/LICENSElinux-amd64/tiller 部署： 1root@deeplearning:/data/helm# mv linux-amd64/helm /usr/local/bin 检查： 123root@deeplearning:/data/helm# helm versionClient: &amp;version.Version&#123;SemVer:"v2.14.3", GitCommit:"0e7f3b6637f7af8fcfddb3d2941fcc7cbebb0085", GitTreeState:"clean"&#125;Error: could not find tiller 提示未连接到服务端tiller。下面我们部署服务端。 1.2 部署服务端Helm 的服务器端部分 Tiller 通常运行在 Kubernetes 集群内部。但是对于开发，它也可以在本地运行，并配置为与远程 Kubernetes 群集通信。 安装 tiller 到群集中最简单的方法就是运行 helm init。这将验证 helm 本地环境设置是否正确（并在必要时进行设置）。然后它会连接到 kubectl 默认连接的任何集群（kubectl config view）。一旦连接，它将安装 tiller 到 kube-system 命名空间中。 helm init 以后，可以运行 kubectl get pods --namespace kube-system 并看到 Tiller 正在运行。 你可以通过参数运行 helm init: --canary-image 参数安装金丝雀版本 --tiller-image 安装特定的镜像（版本） --kube-context 使用安装到特定群集 --tiller-namespace 用一个特定的命名空间 (namespace) 安装 --service-account 使用 Service Account 安装 RBAC enabled clusters --automount-service-account false 不适用 service account 安装 一旦安装了 Tiller，运行 helm version 会显示客户端和服务器版本。（如果它仅显示客户端版本， helm 则无法连接到服务器, 使用 kubectl 查看是否有任何 tiller Pod 正在运行。） 除非设置 --tiller-namespace 或 TILLER_NAMESPACE 参数，否则 Helm 将在命名空间 kube-system 中查找 Tiller 。 在缺省配置下， Helm 会利用 “gcr.io/kubernetes-helm/tiller“ 镜像在Kubernetes集群上安装配置 Tiller；并且利用 “https://kubernetes-charts.storage.googleapis.com“ 作为缺省的 stable repository 的地址。由于在国内可能无法访问 “gcr.io“, “storage.googleapis.com“ 等域名，阿里云容器服务为此提供了镜像站点。 首先创建服务。创建rbac-config.yaml文件，文件内容为： 123456789101112131415161718apiVersion: v1kind: ServiceAccountmetadata: name: tiller namespace: kube-system---apiVersion: rbac.authorization.k8s.io/v1beta1kind: ClusterRoleBindingmetadata: name: tillerroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-adminsubjects: - kind: ServiceAccount name: tiller namespace: kube-system 通过yaml文件创建服务： 123root@deeplearning:/data/helm# kubectl create -f rbac-config.yamlserviceaccount/tiller createdclusterrolebinding.rbac.authorization.k8s.io/tiller created 启Helm pod，即安装tiller： 1234567891011121314151617root@deeplearning:/data/helm#helm init -i registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.10.0 \ --stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts \ --service-account tiller # 回显Creating /root/.helm Creating /root/.helm/repository Creating /root/.helm/repository/cache Creating /root/.helm/repository/local Creating /root/.helm/plugins Creating /root/.helm/starters Creating /root/.helm/cache/archive Creating /root/.helm/repository/repositories.yaml Adding stable repo with URL: https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts Adding local repo with URL: http://127.0.0.1:8879/charts $HELM_HOME has been configured at /root/.helm.Warning: Tiller is already installed in the cluster.(Use --client-only to suppress this message, or --upgrade to upgrade Tiller to the current version.) 这时候我们再次执行： 123root@deeplearning:/data/helm# helm versionClient: &amp;version.Version&#123;SemVer:"v2.14.3", GitCommit:"0e7f3b6637f7af8fcfddb3d2941fcc7cbebb0085", GitTreeState:"clean"&#125;Server: &amp;version.Version&#123;SemVer:"v2.10.0", GitCommit:"9ad53aac42165a5fadc6c87be0dea6b115f93090", GitTreeState:"clean"&#125; 这样Helm的服务端tiller就部署完毕。 1.3 Helm CLI 命令简要汇总1234567891011121314151617181920212223242526// 安装一个 Charthelm install stable/mysql// 列出 Kubernetes 中已部署的 Charthelm list --all// helm repo 的操作helm repo updatehelm repo listhelm repo add dev https://example.com/dev-charts// 创建一个 Chart，会产生一个 Chart 所需的目录结构helm create deis-workflow// 安装自定义 charthelm inspect values stable/mysql # 列出一个 chart 的可配置项helm install -f config.yaml stable/mysql # 可以将修改的配置项写到文件中通过 -f 指定并替换helm install --set name: value stable/mysql # 也可以通过 --set 方式替换// 当新版本 chart 发布时，或者当你需要更改 release 配置时，helm 必须根据现在已有的 release 进行升级helm upgrade -f panda.yaml happy-panda stable/mariadb// 删除 releasehelm delete happy-panda 参考文献及材料1、Helm User Guide - Helm 用户指南 https://whmzsu.github.io/helm-doc-zh-cn/ 2、Kubernetes 包管理工具 Helm 简介 https://www.jianshu.com/p/d55e91e28f94 3、Helm介绍 https://zhaohuabing.com/2018/04/16/using-helm-to-deploy-to-kubernetes/]]></content>
      <categories>
        <category>Helm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从Spark on Yarn到Python on Yarn]]></title>
    <url>%2F2019%2F08%2F01%2F2019-01-28-%E4%BB%8ESpark%20on%20Yarn%E5%88%B0Python%20on%20Yarn%2F</url>
    <content type="text"><![CDATA[目录 术语说明 背景 第一部分 Apache Spark运行模式介绍 第二部分 Spark on Yarn 第三部分 Pyspark Application原理 第四部分 Python on Yarn配置及运行 第五部分 总结 参考文献及资料 背景Apache Spark属于重要的大数据计算框架，另外spark还提供了Python的原生API和机器学习组件Spark Ml，使的可以通过Python编写机器学习任务由Spark运行。本篇文件从Spark运行模式开始讲起，重点介绍Spark on Yarn运行模式，最后重点介绍Python on Yarn（即Pyspark on Yarn）上运行原理和案例。 第一部分 Apache Spark运行模式目前 Apache Spark已知支持5种运行模式。按照节点资源数量可以分为单节点模式（2种）和集群模式（3种）。 单节点模式：本地模式、本地伪集群模式 集群模式：Standalone模式、Spark on Yarn模式、Spark on Mesos模式 原生云模式：在Kubernetes上运行。随着Docker容器和原生云技术的兴起，Spark开始支持在Kubernetes上运行。 对于Spark on Kubernetes可以参考官方文档：https://spark.apache.org/docs/latest/running-on-kubernetes.html。另外可以参考我的另外一篇技术总结：《在Minikube上运行Spark集群》。 1.1 本地模式（单节点模式）本地模式又称为Loacl[N]模式。该模式只需要在单节点上解压spark包即可运行，使用多个线程模拟Spark分布式计算，Master和Worker运行在同一个JVM虚拟机中。这里参数N代表可以使用（预申请）N个线程资源，每个线程拥有一个Core（默认值N=1）。 如果参数为：Loacl[*]，表明：Run Spark locally with as many worker threads as logical cores on your machine。即线程数和物理核数相同。 例如下面的启动命令： 1# ./spark-submit –class org.apache.spark.examples.JavaWordCount –master local[*] spark-examples_2.11-2.3.1.jar file:///opt/README.md 该模式不依懒于HDFS分布式文件系统。例如上面的命令使用的本地文件系统。 1.2 本地伪集群模式（单节点模式）该模式和Local[N]类似，不同的是，它会在单机启动多个进程来模拟集群下的分布式场景，而不像Local[N]这种多个线程在一个进程下共享资源。通常用来测试和验证应用程序逻辑上有没有问题，或者想使用Spark的计算框架而而受限于没有太多资源。 作业提交命令中使用local-cluster[x,y,z]参数模式：x代表要生成的executor数，y和z分别代表每个executor所拥有的core和memory数值。例如下面的命令作业申请了2个executor 进程，每个进程分配3个core和1G的内存，来运行应用程序。 1# ./spark-submit –master local-cluster[2, 3, 1024] 1.3 Standalone模式（集群模式）1.3.1 构架部署Standalone为spark自带资源管理系统（即经典的Master/Slaves架构模式）。该模式下集群由Master和Worker节点组成，程序通过与Master节点交互申请资源，Worker节点启动Executor运行。具体数据流图如下： 另外考虑到Master节点存在单点故障。Spark支持使用Zookeeper实现HA高可用（high avalible）。Zookeeper提供一种领导选举的机制，通过该机制可以保证集群中只有一个Master节点处于RecoveryState.Active状态，其他Master节点处于RecoveryState.Standby状态。 1.3.2 作业运行模式在该模式下，用户提交任务有两种方式：Standalone-client和Standalone-cluster。 1.5.1 Client模式执行流程： (1)客户端启动Driver进程。 (2)Driver向Master申请启动Application启动需要的资源。 (3)资源申请成功后，Driver将task发送到相应的Worker节点执行，并负责监控task运行情况。 (4)Worker将task执行结果返回到客户端的Driver进程。 Client模式适用于调试程序。Driver进程在客户端侧启动，如果生产采用这种模式，当业务量较大时，客户端需要启动大量Driver进程，会消耗大量系统资源，导致资源枯竭。 1.5.2 Cluster模式执行流程： (1)客户端会想Master节点申请启动Driver。 (2)Master受理客户端的请求，分配一个Work节点，启动Driver进程。 (3)Driver启动后，重新想Master节点申请运行资源，Master分配资源，并在相应的Worker节点上启动Executor进程。 (4)Driver发送task到相应的Worker节点运行，并负责监控task。 (5)Worker将task执行结果返回到Driver进程。 Driver运行有Master在集群Worker节点上随机分配，相当于在集群上负载资源。 两种方式最大的区别就是Driver进程运行的位置。Cluster模式相对于Client模式更适合于生成环境的部署。 1.4 Spark on Yarn（集群模式）目前大部分企业级Spark都是跑在已有的Hadoop集群（hadoop 2.0系统）中，均使用Yarn来作为Spark的Cluster Manager，为Spark提供资源管理服务，Spark自身完成任务调度和计算。这部分内容会在后文中细致介绍。 1.5 Spark on Mesos（集群模式）参考官方文档介绍：https://spark.apache.org/docs/latest/running-on-mesos.html 第二部分 Spark on Yarn我们知道MapReduce任务是运行在Yarn上的，同样Spark Application也可以运行在Yarn上。这种模式下，资源的管理、协调、执行和监控交给Yarn集群完成。 Yarn集群上可以运行：MapReduce任务、Spark Application、Hbase集群、Storm集群、Flink集群等等，还有我们后续重点介绍的Python on Yarn。 从节点功能上看，Yarn也采用类似Standalone模式的Master/Slave结构。资源框架中RM（ResourceManager）对应Master，NM（NodeManager）对应Slave。RM负责各个NM资源的统一管理和调度，NM节点负责启动和执行任务以及各任务间的资源隔离。 当集群中存在多种计算框架时，架构上选用Yarn统一管理资源要比Standalone更合适。类似Standalone模式，Spark on Yarn也有两种运行方式：Yarn-Client模式和Yarn-Cluster模式。从适用场景上看，Yarn-Cluster模式适用于生产环境，而Yarn-Client模式更适用于开发（交互式调试）。 2.1 Client模式在Yarn-client模式下，Driver运行在本地Client上，通过AM（ApplicationMaster）向RM申请资源。本地Driver负责与所有的executor container进行交互，并将最后的结果汇总。结束掉Client，相当于kill掉这个spark应用。 Spark Yarn Client向YARN的ResourceManager申请启动Application Master。同时在SparkContent初始化中将创建DAGScheduler和TASKScheduler等，由于我们选择的是Yarn-Client模式，程序会选择YarnClientClusterScheduler和YarnClientSchedulerBackend。 ResourceManager收到请求后，在集群中选择一个NodeManager，为该应用程序分配第一个Container，要求它在这个Container中启动应用程序的ApplicationMaster，与YARN-Cluster区别的是在该ApplicationMaster不运行SparkContext，只与SparkContext进行联系进行资源的分派。 Client中的SparkContext初始化完毕后，与ApplicationMaster建立通讯，向ResourceManager注册，根据任务信息向ResourceManager申请资源（Container）。 一旦ApplicationMaster申请到资源（也就是Container）后，便与对应的NodeManager通信，要求它在获得的Container中启动CoarseGrainedExecutorBackend，CoarseGrainedExecutorBackend启动后会向Client中的SparkContext注册并申请Task。 client中的SparkContext分配Task给CoarseGrainedExecutorBackend执行，CoarseGrainedExecutorBackend运行Task并向Driver汇报运行的状态和进度，以让Client随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。 应用程序运行完成后，Client的SparkContext向ResourceManager申请注销并关闭自己。 2.2 Cluster模式在YARN-Cluster模式中，当用户向YARN中提交一个应用程序后，YARN将分两个阶段运行该应用程序： 第一个阶段是把Spark的Driver作为一个ApplicationMaster在YARN集群中先启动。 第二个阶段是由ApplicationMaster创建应用程序，然后为它向ResourceManager申请资源，并启动Executor来运行Task，同时监控它的整个运行过程，直到运行完成。 应用的运行结果不能在客户端显示（可以在history server中查看），所以最好将结果保存在HDFS而非stdout输出，客户端的终端显示的是作为YARN的job的简单运行状况，下图是yarn-cluster模式： 执行过程： Spark Yarn Client向YARN中提交应用程序，包括ApplicationMaster程序、启动ApplicationMaster的命令、需要在Executor中运行的程序等。 ResourceManager收到请求后，在集群中选择一个NodeManager，为该应用程序分配第一个Container，要求它在这个Container中启动应用程序的ApplicationMaster，其中ApplicationMaster进行SparkContext等的初始化。 ApplicationMaster向ResourceManager注册，这样用户可以直接通过ResourceManage查看应用程序的运行状态，然后它将采用轮询的方式通过RPC协议为各个任务申请资源，并监控它们的运行状态直到运行结束。 一旦ApplicationMaster申请到资源（也就是Container）后，便与对应的NodeManager通信，要求它在获得的Container中启动CoarseGrainedExecutorBackend，而Executor对象的创建及维护是由。CoarseGrainedExecutorBackend负责的，CoarseGrainedExecutorBackend启动后会向ApplicationMaster中的SparkContext注册并申请Task。这一点和Standalone模式一样，只不过SparkContext在Spark Application中初始化时，使用CoarseGrainedSchedulerBackend配合YarnClusterScheduler进行任务的调度，其中YarnClusterScheduler只是对TaskSchedulerImpl的一个简单包装，增加了对Executor的等待逻辑等。 ApplicationMaster中的SparkContext分配Task给CoarseGrainedExecutorBackend执行，CoarseGrainedExecutorBackend运行Task并向ApplicationMaster汇报运行的状态和进度，以让ApplicationMaster随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。 应用程序运行完成后，ApplicationMaster向ResourceManager申请注销并关闭自己。 2.3 两种模式的比较在client模式下，Spark Application运行的Driver会在提交程序的节点上，而该节点可以是YARN集群内部节点，也可以不是。一般来说提交Spark Application的客户端节点不是YARN集群内部的节点，那么在客户端节点上可以根据自己的需要安装各种需要的软件和环境，以支撑Spark Application正常运行。在cluster模式下，Spark Application运行时的所有进程都在YARN集群的NodeManager节点上，而且具体在哪些NodeManager上运行是由YARN的调度策略所决定的。 对比这两种模式，最关键的是Spark Application运行时Driver所在的节点不同，而且，如果想要对Driver所在节点的运行环境进行配置，区别很大，但这对于PySpark Application运行来说是非常关键的。 第三部分 Pyspark Application原理PySpark是Spark为使用Python程序编写Spark Application而实现的客户端库，通过PySpark也可以编写Spark Application并在Spark集群上运行。Python具有非常丰富的科学计算、机器学习处理库，如numpy、pandas、scipy等等。为了能够充分利用这些高效的Python模块，很多机器学习程序都会使用Python实现，同时也希望能够在Spark集群上运行。 理解PySpark Application的运行原理，有助于我们使用Python编写Spark Application，并能够对PySpark Application进行各种调优。PySpark构建于Spark的Java API之上，数据在Python脚本里面进行处理，而在JVM中缓存和Shuffle数据，数据处理流程如下图所示: Spark Application会在Driver中创建pyspark.SparkContext对象，后续通过pyspark.SparkContext对象来构建Job DAG并提交DAG运行。使用Python编写PySpark Application，在Python编写的Driver中也有一个pyspark.SparkContext对象，该pyspark.SparkContext对象会通过Py4J模块启动一个JVM实例，创建一个JavaSparkContext对象。PY4J只用在Driver上，后续在Python程序与JavaSparkContext对象之间的通信，都会通过PY4J模块来实现，而且都是本地通信。 PySpark Application中也有RDD，对Python RDD的Transformation操作，都会被映射到Java中的PythonRDD对象上。对于远程节点上的Python RDD操作，Java PythonRDD对象会创建一个Python子进程，并基于Pipe的方式与该Python子进程通信，将用户编写Python处理代码和数据发送到Python子进程中进行处理。 第四部分 Python on Yarn配置及运行4.1 Yarn节点配置Python环境该模式需要在Yarn集群上每个NM节点（Node Manager）上部署Python编译环境，即安装Python安装包、依赖模块。用户编写的Pyspark Application由集群中Yarn调度执行。 通常使用Anaconda安装包进行统一部署，简化环境的部署。 该模式存在下面缺点： 新增依赖包部署安装代价大。如果后续用户编写的Spark Application需要依赖新的Python模块或包，那么就需要依次在集群Node Manager上部署更新依赖包。 用户对于Python环境的依赖差异化无法满足。通常不同用户编写Spark Application会依赖不同的Python环境，比如Python2、Python3环境等等。该模式下只能支持一种环境，无法满足Python多环境的需求。 各节点的Python环境需要统一。由于用户提交的Spark Application具体在哪些Node Manager上执行，由YARN调度决定，所以必须保证每个节点的Python环境（基础环境+依赖环境）都是相同的，环境维护成本高。 4.2 Yarn节点不配置Python环境该模式不需要提前在集群Node Manager上预安装Python环境。 参考文章：http://quasiben.github.io/blog/2016/4/15/conda-spark/ 我们基于华为C60集群（开源集群相同）以及Anaconda环境对该模式进行了测试验证。具体实现思路如下所示： 在一台SUSE节点上部署Anaconda，并创建虚拟Python环境（如果需要可以部署安装部分依赖包）。 创建conda虚拟环境，并整体打包为zip文件。 用户提交PySpark Application时，使用--archives参数指定该zip文件路径。 详细操作步骤如下： 第一步 下载Anaconda3-4.2.0-Linux-x86_64.sh安装软件（基于python3.5），在SUSE服务器上部署安装。Anaconda的安装路径为/usr/anaconda3。查看客户端服务器的python环境清单： 1234dkfzxwma07app08:/usr/anaconda3 # conda env list# conda environments:#root * /usr/anaconda3 其中root环境为目前的主环境。为了便于环境版本管理我们新建一个专用环境（mlpy_env）。 1dkfzxwma07app08:/usr/anaconda3/envs # conda create -n mlpy --clone root 上述命令创建了一个名称为mlpy_env的Python环境，clone选项将对应的软件包都安装到该环境中，包括一些C的动态链接库文件。 接着，将该Python环境打包，执行如下命令： 12dkfzxwma07app08:/usr/anaconda3/envs # cd /root/anaconda2/envsdkfzxwma07app08:/usr/anaconda3/envs # zip -r mlpy_env.zip mlpy_env 将该zip压缩包拷贝到指定目录中（或者后续引用使用绝对路径），方便后续提交PySpark Application： 1dkfzxwma07app08:/usr/anaconda3/envs # cp mlpy_env.zip /tmp/ 最后，我们可以提交我们的PySpark Application，执行如下命令（或打包成shell脚本）： 123456PYSPARK_PYTHON=./ANACONDA/mlpy_env/bin/python spark-submit \--conf spark.yarn.appMasterEnv.PYSPARK_PYTHON=./ANACONDA/mlpy_env/bin/python \--master yarn-cluster \--archives /tmp/mlpy_env.zip#ANACONDA \/var/lib/hadoop-hdfs/pyspark/test_pyspark_dependencies.py 注意：下面命令指的是zip包将在ANACONDA的目录中展开，需要注意路径。 12&gt; --archives /tmp/mlpy_env.zip#ANACONDA&gt; 环境打包需要注意压缩路径。 上面的依赖zip压缩包将整个Python的运行环境都包含在里面，在提交PySpark Application时会将该环境zip包上传到运行Application的所在的每个节点上。解压缩后为Python代码提供运行时环境。如果不想每次都从客户端将该环境文件上传到集群中运行节点上，也可以提前将zip包上传到HDFS文件系统中，并修改–archives参数的值为hdfs:///tmp/mlpy_env.zip #ANACONDA（注意环境差异），也是可以的。 另外，需要说明的是，如果我们开发的/var/lib/hadoop-hdfs/pyspark /test_pyspark_dependencies.py文件中，依赖多个其他Python文件，想要通过上面的方式运行，必须将这些依赖的Python文件拷贝到我们创建的环境中，对应的目录为mlpy_env/lib/python2.7/site-packages/下面。 注意：pyspark不支持python3.6版本，所以python环境使用python3.5 否则程序执行回显会有这样的报错信息： TypeError: namedtuple() missing 3 required keyword-only arguments: ‘verbose’, ‘rename’, and ‘module’ https://issues.apache.org/jira/browse/SPARK-19019?page=com.atlassian.jira.plugin.system.issuetabpanels%3Aall-tabpanel 4.3 一个机器学习任务栗子举一个Kmeans无监督算法的Python案例： 123456789101112131415161718192021222324252627282930313233343536import osfrom pyspark import SparkContextfrom pyspark.mllib.clustering import KMeans, KMeansModelfrom numpy import arrayfrom math import sqrt# 创建spark contextsc = SparkContext(appName="kmeans")# 加载和解析数据文件stg_path = "hdfs://hacluster" + "/user/" + str(os.environ['USER']) + "/.sparkStaging/" + str(sc.applicationId) + "/" data = sc.textFile(os.path.join(stg_path,'kmeans_data.txt')) parsedData = data.map(lambda line: array([float(x) for x in line.split(' ')]))# 创建模型clusters = KMeans.train(parsedData, 2, maxIterations=10,runs=10,initializationMode="random")# 模型训练def error(point): i = clusters.predict(point) center = clusters.centers[i] print("(" + str(point[0]) + "," + str(point[1]) + "," + str(point[2]) + ")" + "blongs to cluster " + str(i+1)) # print("Cluster Number:" + str(len(clusters.centers))) return sqrt(sum([x**2 for x in (point - center)]))WSSSE = parsedData.map(lambda point: error(point)).reduce(lambda x, y: x + y)print("Within Set Sum of Squared Error = " + str(WSSSE))# 打印类心for mCenter in clusters.centers: print(mCenter)# 保存模型myModelPath = "hdfs://hacluster"+"/user/model/"+"KMeansModel.ml"clusters.save(sc, myModelPath)# 加载模型并测试loadModel = KMeansModel.load(sc, myModelPath)print(loadModel.predict(array([1,1,1]))) 整理成下面的提交命令，将作业提交到Yarn集群： 123456789dkfzxwma07app08:/tmp/pyspark # cat run.shPYSPARK_PYTHON=./ANACONDA/mlpy_env/bin/python \/approot1/utility/hadoopclient/Spark/spark/bin/spark-submit \--master yarn \--deploy-mode cluster \--archives /tmp/pyspark/mlpy_env.zip#ANACONDA \--files /tmp/pyspark/kmeans_data.txt \--conf spark.yarn.appMasterEnv.PYSPARK_PYTHON=./ANACONDA/mlpy_env/bin/python \/tmp/pyspark/kmeanTest.py 模型训练结果会写到路径下面：/user/model： 123dkfzxwma07app08:/tmp/pyspark/pythonpkg # hdfs dfs -ls /user/modelFound 1 itemsdrwxr-xr-x+ - itdw hadoop 0 2019-07-30 11:30 /user/model/KMeansModel.ml 模型加载的预测结果可以在Yarn日志中查询： 12345678910dkfzxwma07app08:/tmp/pyspark # yarn logs -applicationId application_1562162322775_150207# 提取部分回显LogType:stdoutLog Upload Time:星期二 七月 30 13:47:23 +0800 2019LogLength:120414Log Contents:Within Set Sum of Squared Error = 0.6928203230275529[ 9.1 9.1 9.1][ 0.1 0.1 0.1]1 当然对于输出可以选择其他输出源(表或者文件)。 第五部分 总结5.1 混合多语言数据流通常一个完整的机器学习应用的数据流设计中，可以将数据ETL准备阶段和算法计算分离出来。使用Java/scala/sql进行数据的预处理，输出算法计算要求的数据格式。这会极大降低算法计算的数据输入规模，降低算法计算的节点的IO。 机器学习的算法计算部分具有高迭代计算特性，对于非分布式的机器学习算法，我们通常部署在高性能的节点上，基于丰富、高性能的Python科学计算模块，使用Python语言实现。而对于数据准备阶段，更适合使用原生的Scala/java编程语言实现Spark Application来处理数据，包括转换、统计、压缩等等，将满足算法输入格式的数据输出到HDFS文件系统中。特别对于数据规模较大的情况，在Spark集群上处理数据，Scala/Java实现的Spark Application运行（多机并行分布式处理）性能要好一些。然后输出数据交给Python进行迭代计算训练。 当然对于分布式机器学习框架，将数据迭代部分分解到多个节点并行处理，由参数服务器管理迭代参数的汇总和更新。在这种计算框架下可以利用数据集群天然的计算资源，实现分布式部署。这就形成了一个高效的混合的多语言的数据处理流。 5.2 架构建议和总结1、对于Python on Yarn架构下，采用“Yarn节点不配置Python环境”模式，便于Python环境的管理。这时候可以将Python环境zip文件上传至集群HDFS文件系统，避免每次提交任务都需要上传zip文件，但是不可避免集群内部HDFS文件系统分发到运行节点产生的网络IO。但比集群外部的上传效率高。 2、对于机器学习任务数据流建议采用混合多语言数据流方式，发挥各计算组件的优势。 3、对于分布式机器学习框架，建议结合集群的计算资源，直接在集群上展开分布式计算（例如Tensorflow计算框架）。而不是单独新建新的机器学习分布式集群。减少两个集群的数据搬运，并且使得数据和计算更加贴近，最重要的提高机器学习任务端到端的效率。 参考文献及资料1、Running Spark Python Applications，链接：https://www.cloudera.com/documentation/enterprise/5-9-x/topics/spark_python.html 2、基于YARN集群构建运行PySpark Application，链接： http://shiyanjun.cn/archives/1738.html 3、Running Spark on YARN，链接： https://spark.apache.org/docs/latest/running-on-yarn.html 4、Running Spark on Kubernetes，链接：https://spark.apache.org/docs/latest/running-on-kubernetes.html 5、Apache Spark Resource Management and YARN App Models，链接：https://blog.cloudera.com/blog/2014/05/apache-spark-resource-management-and-yarn-app-models/ 6、Spark On Yarn的两种模式yarn-cluster和yarn-client深度剖析，链接：https://www.cnblogs.com/ITtangtang/p/7967386.html 7、Introducing Skein: Deploy Python on Apache YARN the Easy Way，链接：https://jcrist.github.io/introducing-skein.html 8、当Spark遇上TensorFlow分布式深度学习框架原理和实践，链接：https://juejin.im/post/5ad4b620f265da23a04a0ad0 9、Spark On Yarn的优势，链接：https://www.cnblogs.com/ITtangtang/p/7967386.html 10、基于YARN集群构建运行PySpark Application，链接：http://www.uml.org.cn/bigdata/201711132.asp]]></content>
      <categories>
        <category>pyspark</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TDengine时间序列数据库压力测试]]></title>
    <url>%2F2019%2F07%2F01%2F2019-07-01-TDengine%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 部署压测工具vegeta 第二部分 部署TDengine数据库 第三部分 TDengine数据库RESTful接口介绍 第四部分 压力测试 第五部分 压力测试结果 参考文献及资料 背景最近涛思数据团队开源了自己的时序数据库，关注度较高。按照官方介绍，性能较为强悍，所以使用压测工具对该数据库进行了性能压测。压测使用的工具Vegeta 是一个用 Go 语言编写的多功能的 HTTP 负载测试工具。Vegeta 提供了命令行工具和一个开发库。 第一部分 部署压测工具vegeta1.1 部署从github上下载vegeta安装介质： 1$ wget https://github.com/tsenart/vegeta/releases/download/cli%2Fv12.5.1/vegeta-12.5.1-linux-amd64.tar.gz 该工具开箱即用，解压tar包： 1$ tar -zxvf vegeta-12.5.1-linux-amd64.tar.gz 1.2 简单测试使用我们使用vegeta测试一下下面的压力场景（对百度主页发起每秒100次（-rate=100）的请求，持续10秒（-duration=10s）），测试结果重定向到文件（result/results.bin）： 1$ echo "GET https://www.baidu.com" |./vegeta attack -duration=10s -rate=100 &gt;result/results.bin 查看一下测试结果： 123456789root@deeplearning:/data/vegeta# ./vegeta report result/results.binRequests [total, rate] 1000, 100.10Duration [total, attack, wait] 10.002241136s, 9.990128173s, 12.112963msLatencies [mean, 50, 95, 99, max] 2.315958984s, 1.889487082s, 6.064678156s, 6.583899297s, 6.961230585sBytes In [total, mean] 227000, 227.00Bytes Out [total, mean] 0, 0.00Success [ratio] 100.00%Status Codes [code:count] 200:1000 Error Set: 另外可以生成html文件报告（可视化）： 1root@deeplearning:/data/vegeta# ./vegeta plot result/results.bin &gt; result/plot.html 第二部分 部署TDengine数据库2.1 制作docker镜像 由于墙的原因我们在VPS上打包镜像，然后本机拉取部署。 为了保证测试环境的隔离性，我们制作docker镜像，使用docker环境进行测试。首先拉取ubuntu的基础镜像： 1$ docker run -t -i ubuntu:16.04 /bin/bash 通过TDengine源码安装。在这过程有大量操作系统工具未安装，需要使用atp-get安装部署。 2.1.1 第一步 clone项目1$ git clone https://github.com/taosdata/TDengine.git 2.1.2 第二步 编译12$ mkdir build &amp;&amp; cd build$ cmake .. &amp;&amp; cmake --build . 2.1.3 第三步 安装1$ make install 2.2 生成镜像打包成镜像，推送到Docker Hub： 123root@vultr:~# docker commit a35c43242a8e rongxiang1986/tdengineroot@vultr:~# docker tag rongxiang1986/tdengine rongxiang1986/tdengine:1.0root@vultr:~# docker push rongxiang1986/tdengine:1.0 2.3 拉取镜像部署拉取镜像： 1root@deeplearning:/data/TDengine/TDengine# docker pull rongxiang1986/tdengine:1.0 启动一个docker容器： 1root@deeplearning:/data/TDengine/TDengine# docker run -t -i --name tdengine -d -p 6020:6020 rongxiang1986/tdengine:1.0 /bin/bash 查看正在运行的容器： 12root@deeplearning:/data/TDengine/TDengine# docker ps# bec2e166c29f 进入容器： 1root@deeplearning:/data/TDengine/TDengine# docker attach bec2e166c29f 最后启动数据库服务，下面是启动回显信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107root@bec2e166c29f:~/TDengine/TDengine/build# ./build/bin/taosd -c test/cfg &amp;[1] 23root@bec2e166c29f:~/TDengine/TDengine/build# TDengine:[23]: Starting TDengine service...07/17 14:48:21.615248 7ff90254e700 UTL timezone not configured, set to system default:Etc/UTC (Etc, +0000)07/17 14:48:21.615261 7ff90254e700 UTL locale not configured, set to system default:C07/17 14:48:21.616266 7ff90254e700 UTL taos config &amp; system info:07/17 14:48:21.616274 7ff90254e700 UTL ==================================07/17 14:48:21.616278 7ff90254e700 UTL internalIp: 172.17.0.3 07/17 14:48:21.616283 7ff90254e700 UTL localIp: 172.17.0.3 07/17 14:48:21.616288 7ff90254e700 UTL httpIp: 0.0.0.0 07/17 14:48:21.616294 7ff90254e700 UTL httpPort: 6020 07/17 14:48:21.616299 7ff90254e700 UTL mgmtShellPort: 6030 07/17 14:48:21.616304 7ff90254e700 UTL vnodeShellPort: 6035 07/17 14:48:21.616308 7ff90254e700 UTL configDir: test/cfg 07/17 14:48:21.616312 7ff90254e700 UTL dataDir: /root/TDengine/TDengine/build/test/data 07/17 14:48:21.616318 7ff90254e700 UTL logDir: /root/TDengine/TDengine/build/test/log 07/17 14:48:21.616325 7ff90254e700 UTL scriptDir: /etc/taos 07/17 14:48:21.616330 7ff90254e700 UTL numOfThreadsPerCore: 1.000000 07/17 14:48:21.616338 7ff90254e700 UTL ratioOfQueryThreads: 0.500000 07/17 14:48:21.616344 7ff90254e700 UTL numOfVnodesPerCore: 8 07/17 14:48:21.616349 7ff90254e700 UTL numOfTotalVnodes: 0 07/17 14:48:21.616355 7ff90254e700 UTL tables: 1000 07/17 14:48:21.616360 7ff90254e700 UTL cache: 16384(byte)07/17 14:48:21.616366 7ff90254e700 UTL rows: 4096 07/17 14:48:21.616371 7ff90254e700 UTL fileBlockMinPercent: 0.250000 07/17 14:48:21.616376 7ff90254e700 UTL ablocks: 4 07/17 14:48:21.616382 7ff90254e700 UTL tblocks: 100 07/17 14:48:21.616386 7ff90254e700 UTL monitorInterval: 30(s)07/17 14:48:21.616391 7ff90254e700 UTL rpcTimer: 300(ms)07/17 14:48:21.616396 7ff90254e700 UTL rpcMaxTime: 600(s)07/17 14:48:21.616402 7ff90254e700 UTL ctime: 3600(s)07/17 14:48:21.616407 7ff90254e700 UTL statusInterval: 1(s)07/17 14:48:21.616414 7ff90254e700 UTL shellActivityTimer: 3(s)07/17 14:48:21.616420 7ff90254e700 UTL meterMetaKeepTimer: 7200(s)07/17 14:48:21.616423 7ff90254e700 UTL metricMetaKeepTimer: 600(s)07/17 14:48:21.616428 7ff90254e700 UTL maxUsers: 1000 07/17 14:48:21.616432 7ff90254e700 UTL maxDbs: 1000 07/17 14:48:21.616439 7ff90254e700 UTL maxTables: 650000 07/17 14:48:21.616442 7ff90254e700 UTL maxVGroups: 1000 07/17 14:48:21.616445 7ff90254e700 UTL minSlidingTime: 10(ms)07/17 14:48:21.616454 7ff90254e700 UTL minIntervalTime: 10(ms)07/17 14:48:21.616460 7ff90254e700 UTL maxStreamCompDelay: 20000(ms)07/17 14:48:21.616463 7ff90254e700 UTL maxFirstStreamCompDelay:10000(ms)07/17 14:48:21.616467 7ff90254e700 UTL retryStreamCompDelay: 10(ms)07/17 14:48:21.616470 7ff90254e700 UTL clog: 1 07/17 14:48:21.616474 7ff90254e700 UTL comp: 2 07/17 14:48:21.616480 7ff90254e700 UTL days: 10 07/17 14:48:21.616483 7ff90254e700 UTL keep: 3650 07/17 14:48:21.616488 7ff90254e700 UTL defaultDB: 07/17 14:48:21.616494 7ff90254e700 UTL defaultUser: root 07/17 14:48:21.616503 7ff90254e700 UTL defaultPass: taosdata 07/17 14:48:21.616508 7ff90254e700 UTL timezone: Etc/UTC (Etc, +0000) 07/17 14:48:21.616515 7ff90254e700 UTL locale: C 07/17 14:48:21.616520 7ff90254e700 UTL charset: UTF-8 07/17 14:48:21.616525 7ff90254e700 UTL maxShellConns: 2000 07/17 14:48:21.616531 7ff90254e700 UTL maxMeterConnections: 10000 07/17 14:48:21.616535 7ff90254e700 UTL maxMgmtConnections: 2000 07/17 14:48:21.616540 7ff90254e700 UTL maxVnodeConnections: 10000 07/17 14:48:21.616543 7ff90254e700 UTL enableHttp: 1 07/17 14:48:21.616549 7ff90254e700 UTL enableMonitor: 1 07/17 14:48:21.616553 7ff90254e700 UTL httpCacheSessions: 2000 07/17 14:48:21.616556 7ff90254e700 UTL httpMaxThreads: 2 07/17 14:48:21.616561 7ff90254e700 UTL numOfLogLines: 10000000 07/17 14:48:21.616565 7ff90254e700 UTL asyncLog: 1 07/17 14:48:21.616570 7ff90254e700 UTL debugFlag: 131 07/17 14:48:21.616574 7ff90254e700 UTL mDebugFlag: 135 07/17 14:48:21.616579 7ff90254e700 UTL dDebugFlag: 131 07/17 14:48:21.616584 7ff90254e700 UTL sdbDebugFlag: 135 07/17 14:48:21.616590 7ff90254e700 UTL taosDebugFlag: 131 07/17 14:48:21.616595 7ff90254e700 UTL tmrDebugFlag: 131 07/17 14:48:21.616601 7ff90254e700 UTL cDebugFlag: 131 07/17 14:48:21.616605 7ff90254e700 UTL jniDebugFlag: 131 07/17 14:48:21.616612 7ff90254e700 UTL odbcDebugFlag: 131 07/17 14:48:21.616617 7ff90254e700 UTL uDebugFlag: 131 07/17 14:48:21.616621 7ff90254e700 UTL httpDebugFlag: 131 07/17 14:48:21.616629 7ff90254e700 UTL monitorDebugFlag: 131 07/17 14:48:21.616634 7ff90254e700 UTL qDebugFlag: 131 07/17 14:48:21.616637 7ff90254e700 UTL gitinfo: 82cbce3261d06ab37c3bd4786c7b2e3d2316c42a 07/17 14:48:21.616643 7ff90254e700 UTL buildinfo: Built by ubuntu at 2019-07-05 18:42 07/17 14:48:21.616648 7ff90254e700 UTL version: 1.6.0.0 07/17 14:48:21.616653 7ff90254e700 UTL os pageSize: 4096(KB)07/17 14:48:21.616658 7ff90254e700 UTL os openMax: 104857607/17 14:48:21.616662 7ff90254e700 UTL os streamMax: 1607/17 14:48:21.616666 7ff90254e700 UTL os numOfCores: 807/17 14:48:21.616670 7ff90254e700 UTL os totalDisk: 426(GB)07/17 14:48:21.616676 7ff90254e700 UTL os totalMemory: 32028(MB)07/17 14:48:21.616682 7ff90254e700 UTL os sysname: Linux07/17 14:48:21.616686 7ff90254e700 UTL os nodename: bec2e166c29f07/17 14:48:21.616690 7ff90254e700 UTL os release: 4.15.0-51-generic07/17 14:48:21.616694 7ff90254e700 UTL os version: #55~16.04.1-Ubuntu SMP Thu May 16 09:24:37 UTC 201907/17 14:48:21.616700 7ff90254e700 UTL os machine: x86_6407/17 14:48:21.616707 7ff90254e700 UTL ==================================07/17 14:48:21.616712 7ff90254e700 DND Server IP address is:172.17.0.307/17 14:48:21.616717 7ff90254e700 DND starting to initialize TDengine engine ...07/17 14:48:21.619440 7ff90254e700 HTP failed to open telegraf schema config file:test/cfg/taos.telegraf.cfg, use default schema07/17 14:48:21.869736 7ff90254e700 DND vnode is initialized successfully07/17 14:48:21.869780 7ff90254e700 MND starting to initialize TDengine mgmt ...07/17 14:48:21.872494 7ff90254e700 MND first access, set total vnodes:6407/17 14:48:21.917758 7ff90254e700 MND TDengine mgmt is initialized successfully07/17 14:48:21.917781 7ff90254e700 HTP starting to initialize http service ...07/17 14:48:21.918417 7ff90254e700 DND TDengine is initialized successfully07/17 14:48:21.918533 7ff8e4f41700 HTP http service init success at ip:0.0.0.0:6020TDengine:[23]: Started TDengine service successfully.07/17 14:48:22.022278 7ff8ff835700 MON starting to initialize monitor service ..07/17 14:48:22.022747 7ff8eb109700 MND user:monitor login from 172.17.0.3, code:007/17 14:48:22.024412 7ff901038700 MON dnode:172.17.0.3 is started07/17 14:48:22.026780 7ff901038700 MON monitor service init success 上面回显service init success说明服务service启动成功。 2.4 镜像使用说明TDengine项目地址：https://github.com/taosdata/TDengine。使用ubuntu16.04作为基础镜像，部署安装TDengine。拉取镜像后，启动容器后： 启动服务：To start the TDengine server, run the command below in terminal: 1$ /root/TDengine/TDengine/build# ./build/bin/taosd -c test/cfg 启动客户端：In another terminal, use the TDengine shell to connect the server: 1$ /root/TDengine/TDengine/build#./build/bin/taos -c test/cfg 第三部分 TDengine数据库RESTful接口介绍按照官方给的例子我们新建案例数据库和表，并且新增数据记录。首先进入shell交互： 1234567root@a35c43242a8e:~/TDengine/TDengine/build# ./build/bin/taos -c test/cfg07/17 04:30:19.818000 7fa154b0e700 MND user:root login from 172.17.0.2, code:0Welcome to the TDengine shell, server version:1.6.0.0 client version:1.6.0.0Copyright (c) 2017 by TAOS Data, Inc. All rights reserved.taos&gt; 创建案例数据： 12345678910111213141516171819202122taos&gt; create database db;07/17 04:31:46.970580 7fa14ffff700 MND DB:0.db is created by rootQuery OK, 1 row(s) affected (0.001848s)taos&gt; use db;Database changed.taos&gt; create table t (ts timestamp, cdata int);Query OK, 1 row(s) affected (0.334998s)taos&gt; insert into t values ('2019-07-15 10:00:00', 10);Query OK, 1 row(s) affected (0.001639s)taos&gt; insert into t values ('2019-07-15 10:01:05', 20);Query OK, 1 row(s) affected (0.000245s)taos&gt; select * from t; ts | cdata |=================================== 19-07-15 10:00:00.000| 10| 19-07-15 10:01:05.000| 20|Query OK, 2 row(s) in set (0.001408s) 退出shell交互后，我们使用Restfull接口与数据库交互。 注意：目前RESTfull接口认证方式使用Http Basic Authorization请求格式，token使用base64(username:password)，即base64(root:taosdata)=cm9vdDp0YW9zZGF0YQ== 可以在在线网站上：https://www.base64encode.org/ encode一下。 1234root@a35c43242a8e:~/TDengine/TDengine/build# curl -H 'Authorization: Basic cm9vdDp0YW9zZGF0YQ==' -d 'select * from db.t' localhost:6020/rest/sql#下面是回显：07/17 04:33:34.834283 7fa154b0e700 MND user:root login from 172.17.0.2, code:0&#123;"status":"succ","head":["ts","cdata"],"data":[["2019-07-15 10:00:00.000",10],["2019-07-15 10:01:05.000",20]],"rows":2&#125; 返回结果是一个JSON格式串，规范化一下： 123456789101112131415161718&#123; "status":"succ", "head":[ "ts", "cdata" ], "data":[ [ "2019-07-15 10:00:00.000", 10 ], [ "2019-07-15 10:01:05.000", 20 ] ], "rows":2&#125; 第四部分 对RESTful接口压力测试最后我们使用vegeta对restful接口进行压力测试： 4.1 查询压测使用目标文件的内容进行压力测试。 首先创建target.txt文件以及数据文件data.json，内容如下： 1234root@bec2e166c29f:~/TDengine/vegeta/TDengineTest# cat target.txtPOST http://localhost:6020/rest/sqlAuthorization: Basic cm9vdDp0YW9zZGF0YQ==@data.json 12root@bec2e166c29f:~/TDengine/vegeta/TDengineTest# cat data.jsonselect * from db.t 最后使用下面的命令开始压测（每秒15000次请求，持续5分钟）： 123456789101112root@bec2e166c29f:~/TDengine/vegeta/TDengineTest#../vegeta attack -rate 15000 -targets target.txt -duration 5m &gt; out.dat# 生成报告root@bec2e166c29f:~/TDengine/vegeta/TDengineTest# ../vegeta report out.dat# 回显：Requests [total, rate] 4500044, 15000.15Duration [total, attack, wait] 5m0.000202809s, 4m59.999911126s, 291.683µsLatencies [mean, 50, 95, 99, max] 314.712µs, 230.113µs, 869.502µs, 1.501018ms, 205.870168msBytes In [total, mean] 954009328, 212.00Bytes Out [total, mean] 90000880, 20.00Success [ratio] 100.00%Status Codes [code:count] 200:4500044 Error Set: 4.2 写入压测首先创建writetarget.txt和数据文件：writedata.json，内容如下： 1234root@bec2e166c29f:~/TDengine/vegeta/TDengineTest# cat writetarget.txtPOST http://localhost:6020/rest/sqlAuthorization: Basic cm9vdDp0YW9zZGF0YQ==@writedata.json 12root@bec2e166c29f:~/TDengine/vegeta/TDengineTest# cat writedata.jsoninsert into db.cpu values (NOW,20,12); 这里写入语句使用时间函数NOW，保证写入时间无重复。 最后使用命令开始压测（每秒30000次请求，持续1分钟）： 1234567891011root@bec2e166c29f:~/TDengine/vegeta/TDengineTest# ../vegeta attack -rate 30000 -targets writetarget.txt -duration 1m &gt; writeout.dat# 生成报告root@bec2e166c29f:~/TDengine/vegeta/TDengineTest# ../vegeta report writeout30000.datRequests [total, rate] 1800018, 30000.31Duration [total, attack, wait] 1m0.000154842s, 59.99998565s, 169.192µsLatencies [mean, 50, 95, 99, max] 254.824µs, 137.651µs, 904.696µs, 1.687601ms, 12.528831msBytes In [total, mean] 115201152, 64.00Bytes Out [total, mean] 70200702, 39.00Success [ratio] 100.00%Status Codes [code:count] 200:1800018 Error Set: 第五部分 压力测试结果由于机器环境的差异，只是做了尝试性测试，不代表产品的实际性能。 官方测试报告参考：https://www.taosdata.com/downloads/TDengine_Testing_Report_cn.pdf 5.1 查询对于查询性能我们每秒15000的请求结果如下： 123456789root@bec2e166c29f:~/TDengine/vegeta/TDengineTest# ../vegeta report out15000.datRequests [total, rate] 4500044, 15000.15Duration [total, attack, wait] 5m0.000202809s, 4m59.999911126s, 291.683µsLatencies [mean, 50, 95, 99, max] 314.712µs, 230.113µs, 869.502µs, 1.501018ms, 205.870168msBytes In [total, mean] 954009328, 212.00Bytes Out [total, mean] 90000880, 20.00Success [ratio] 100.00%Status Codes [code:count] 200:4500044 Error Set: 当提高到每秒20000次时，数据库出现响应失败，成功率只有38.78%： 123456789101112131415161718192021root@bec2e166c29f:~/TDengine/vegeta/TDengineTest# ../vegeta report out20000.dat Requests [total, rate] 904794, 2824.86Duration [total, attack, wait] 6m19.120695351s, 5m20.296894938s, 58.823800413sLatencies [mean, 50, 95, 99, max] 38.726984614s, 43.82040722s, 1m13.377381823s, 1m25.843611324s, 1m52.393219406sBytes In [total, mean] 58181450, 64.30Bytes Out [total, mean] 8016960, 8.86Success [ratio] 38.78%Status Codes [code:count] 0:503946 200:350896 400:49952 Error Set:400 Bad RequestPost http://localhost:6020/rest/sql: dial tcp 0.0.0.0:0-&gt;127.0.0.1:6020: bind: address already in usePost http://localhost:6020/rest/sql: net/http: request canceled (Client.Timeout exceeded while awaiting headers)Post http://localhost:6020/rest/sql: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)Post http://localhost:6020/rest/sql: dial tcp 0.0.0.0:0-&gt;127.0.0.1:6020: bind: address already in use (Client.Timeout exceeded while awaiting headers)Post http://localhost:6020/rest/sql: read tcp 127.0.0.1:34037-&gt;127.0.0.1:6020: read: connection reset by peerPost http://localhost:6020/rest/sql: read tcp 127.0.0.1:53020-&gt;127.0.0.1:6020: read: connection reset by peerPost http://localhost:6020/rest/sql: read tcp 127.0.0.1:47081-&gt;127.0.0.1:6020: read: connection reset by peerPost http://localhost:6020/rest/sql: read tcp 127.0.0.1:35442-&gt;127.0.0.1:6020: read: connection reset by peerPost http://localhost:6020/rest/sql: read tcp 127.0.0.1:58175-&gt;127.0.0.1:6020: read: connection reset by peerPost http://localhost:6020/rest/sql: read tcp 127.0.0.1:41857-&gt;127.0.0.1:6020: read: connection reset by peerPost http://localhost:6020/rest/sql: read tcp 127.0.0.1:58943-&gt;127.0.0.1:6020: read: connection reset by peer 5.2 写入对于写入测试。对于查询性能我们每秒30000的请求结果如下： 123456789root@bec2e166c29f:~/TDengine/vegeta/TDengineTest# ../vegeta report writeout30000.datRequests [total, rate] 1800018, 30000.31Duration [total, attack, wait] 1m0.000154842s, 59.99998565s, 169.192µsLatencies [mean, 50, 95, 99, max] 254.824µs, 137.651µs, 904.696µs, 1.687601ms, 12.528831msBytes In [total, mean] 115201152, 64.00Bytes Out [total, mean] 70200702, 39.00Success [ratio] 100.00%Status Codes [code:count] 200:1800018 Error Set: 当提高到每秒50000次时，数据库性能开始恶化，成功率只有55.73%： 12345678910111213root@bec2e166c29f:~/TDengine/vegeta/TDengineTest# ../vegeta report writeout50000.datRequests [total, rate] 160712, 2676.70Duration [total, attack, wait] 1m47.789030336s, 1m0.041100866s, 47.74792947sLatencies [mean, 50, 95, 99, max] 36.064568863s, 39.103737526s, 50.372069878s, 54.866214748s, 1m12.470342472sBytes In [total, mean] 5731840, 35.67Bytes Out [total, mean] 3492840, 21.73Success [ratio] 55.73%Status Codes [code:count] 0:71152 200:89560 Error Set:Post http://localhost:6020/rest/sql: dial tcp 0.0.0.0:0-&gt;127.0.0.1:6020: bind: address already in usePost http://localhost:6020/rest/sql: net/http: request canceled (Client.Timeout exceeded while awaiting headers)Post http://localhost:6020/rest/sql: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)Post http://localhost:6020/rest/sql: dial tcp 0.0.0.0:0-&gt;127.0.0.1:6020: bind: address already in use (Client.Timeout exceeded while awaiting headers) 结论：单机环境下同等场景（都是压测RESTfull接口）下，TDengine可以抗住每秒15000次的读请求和每秒30000次写请求。influxdb只能抗住每秒6000次持续读、写。按照官网介绍如果写入是批量形式会更快。 参考文献和材料1、推荐一款高性能 HTTP 负载测试工具 Vegeta 链接：https://www.hi-linux.com/posts/4650.html 2、TDengine官网 链接：https://www.taosdata.com/cn/ 3、比Hadoop快至少10倍的物联网大数据平台，我把它开源了 链接：https://weibo.com/ttarticle/p/show?id=2309404394278649462890]]></content>
      <categories>
        <category>TDengine Vegeta</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sqlflow初体验]]></title>
    <url>%2F2019%2F05%2F06%2F2019-05-06-Sqlflow%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 Sqlflow安装部署 第二部分 机器学习例子 第三部分 系统架构 参考文献及资料 背景2019年5 月 6 日，在QCon 全球软件开发大会（北京站）上，蚂蚁金服副 CTO 胡喜正式宣布开源机器学习工具 SQLFlow。实际上3个月前sqkflow项目已经在github上开源了。 本篇文件主要参考sqlflow官网的案例和说明对sqlflow进行了体验，并记录下来。 sqlflow按照官网的定义，将SQL引擎（例如MySQL，Hive，SparkSQL或SQL Server）和tensorflow和其他机器学习的桥梁。扩展了SQL语言，支持对机器学习模型训练、预测和推理。 目前开源版本仅支持MySQL和TensorFlow 介绍文档中也提到，在sqlflow之前也有SQL引擎提供了支持机器学习功能的扩展。 Microsoft SQL Server：Microsoft SQL Server具有机器学习服务，可以将R或Python中的机器学习程序作为外部脚本运行。 Teradata SQL for DL：Teradata还提供RESTful服务，可以从扩展的SQL SELECT语法中调用。 Google BigQuery：Google BigQuery通过引入CREATE MODEL语句在SQL中实现机器学习。 第一部分 Sqlflow安装部署1.1 部署mysql做为数据源（1）构建镜像官网提供了一个dockerfile，可以git clone整个项目。 https://github.com/sql-machine-learning/sqlflow/tree/7c873780bd8a3a9ea4d39ed7d0fcf154b2f8821f/example/datasets 1234# 进入Dockerfile文件所在目录cd example/datasets# 使用Dockerfile构建镜像docker build -t sqlflow:data . 可以查看创建了一个docker images： 12docker images# 创建了REPOSITORY：sqlflow镜像，TAG为：data （2）启动mysql容器用镜像启mysql容器： 12345docker run --rm -d --name sqlflowdata \ -p 3306:3306 \ -e MYSQL_ROOT_PASSWORD=root \ -e MYSQL_ROOT_HOST=% \ sqlflow:data 使用镜像：sqlflow:data，启动一个名为：sqlflowdata的容器，并且把3306端口映射到宿主机。mysql的root用户的密码为root。 （3）生成测试数据进入容器： 1docker exec -it sqlflowdata bash 执行SQL语句： 12345# 建库建表，注意宿主机目录：datasetscat /popularize_churn.sql | mysql -uroot -prootcat /popularize_iris.sql | mysql -uroot -proot# 建库echo "CREATE DATABASE IF NOT EXISTS sqlflow_models;" | mysql -uroot -proot 至此完成mysql容器的启动和测试数据的生成。按Ctrl+P+Q，正常退出不关闭容器。 1.2 使用docker部署slqflow（1）拉取镜像并启动容器首先从docker Hub上拉取镜像： 1# docker pull sqlflow/sqlflow:latest 启动容器： 123# docker run --rm -it --name sqlflowServer -p 8888:8888 sqlflow/sqlflow:latest \bash -c "sqlflowserver --datasource='mysql://root:root@tcp(192.168.31.3:3306)/?maxAllowedPacket=0' &amp;SQLFLOW_SERVER=localhost:50051 jupyter notebook --ip=0.0.0.0 --port=8888 --allow-root" 命令使用镜像：sqlflow/sqlflow:lates，启动了名为：sqlflowServer的容器。将8888端口映射到宿主机上。这里需要配置datasource，指向mysql使用套接字：192.168.31.3:3306。这里使用之前构建的mysql容器的连接信息，可以根据实际情况配置。 如果mysql套接字配置错误，报错信息：connect: connection refused 如果没有报错： 12345672019/05/06 14:47:30 Server Started at :50051[I 14:47:30.261 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret[I 14:47:30.874 NotebookApp] Serving notebooks from local directory: /[I 14:47:30.874 NotebookApp] The Jupyter Notebook is running at:[I 14:47:30.874 NotebookApp] http://(fd2b9b3f994b or 127.0.0.1):8888/?token=265b3fc832b5b48689fa9f88483125dc9335188dd7c1d863[I 14:47:30.874 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).[W 14:47:30.877 NotebookApp] No web browser found: could not locate runnable browser. 这里启动了Jupyter Notebook服务，对外服务端口为8888，并且映射到宿主机。例如这里可以使用下面的url范围web界面：http://192.168.31.3:8888/?token=265b3fc832b5b48689fa9f88483125dc9335188dd7c1d863 （2）简单测试Jupyter Notebook 新建一个python3交互环境。测试一下： 12%%sqlflowselect * from iris.train limit 5; 第二部分 机器学习例子使用iris数据集体验机器学习的例子，使用Jupyter Notebook 完成： （1）训练模型：12%%sqlflowSELECT * FROM iris.train TRAIN DNNClassifier WITH n_classes = 3, hidden_units = [10, 20] COLUMN sepal_length, sepal_width, petal_length, petal_width LABEL class INTO sqlflow_models.my_dnn_model; 使用iris.train表中的数据训练神经网络。 模型训练结果输入到sqlflow_models.my_dnn_model，回显训练正确率为：0.97273 12Training set accuracy: 0.97273Done training （2）模型应用使用训练结果对数据进行预测应用： 12%%sqlflowSELECT * FROM iris.test PREDICT iris.predict.class USING sqlflow_models.my_dnn_model; 使用iris.test中的数据喂给训练好的模型，预测结果输出到表：iris.predict。 1Done predicting. Predict table : iris.predict 查看结果表中的数据案例： 12%%sqlflowselect * from iris.predict limit 2 123456+--------------+-------------+--------------+-------------+-------+| sepal_length | sepal_width | petal_length | petal_width | class |+--------------+-------------+--------------+-------------+-------+| 6.3 | 2.7 | 4.9 | 1.8 | 2 || 5.7 | 2.8 | 4.1 | 1.3 | 1 |+--------------+-------------+--------------+-------------+-------+ 第三部分 系统架构系统原型使用下面的架构： 12SQL statement -&gt; our SQL parser --standard SQL-&gt; MySQL \-extended SQL-&gt; code generator -&gt; execution engine 原型运行的数据流为： 它通过MySQL Connector Python API从MySQL检索数据 从MySQL检索模型 通过调用用户指定的TensorFlow估算器训练模型或使用训练模型进行预测 并将训练过的模型或预测结果写入表格 参考文献及资料1、sqlflow项目官网 链接：https://github.com/sql-machine-learning/sqlflow 2、会 SQL 就能搞定 AI！蚂蚁金服重磅开源机器学习工具 SQLFlow 链接：https://www.infoq.cn/article/vlVqC68h2MT-028lh68C]]></content>
      <categories>
        <category>sqlflow</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hive介绍及部署]]></title>
    <url>%2F2018%2F08%2F14%2F2018-08-13-Hive-install%2F</url>
    <content type="text"><![CDATA[背景Hive（蜂巢）是Hadoop的组件，官方介绍为： Hive™: A data warehouse infrastructure that provides data summarization and ad hoc querying. Hive有三种部署方式（本质是Hive Metastore的三种部署方式）： Embedded Metastore Database (Derby) 内嵌模式 内嵌模式使用的是内嵌的Derby数据库来存储元数据，也不需要额外起Metastore服务。这个是默认的，配置简单，但是一次只能一个客户端连接（Derby只提供单进程存储），适用于用来实验，不适用于生产环境。 Local Metastore Server 本地元存储 采用外部数据库来存储元数据 。本地元存储不需要单独起metastore服务，用的是跟hive在同一个进程里的metastore服务 。 目前支持：Derby，Mysql，微软SQLServer，Oracle和Postgres Remote Metastore Server 远程元存储 采用外部数据库来存储元数据 。远程元存储需要单独起metastore服务，然后每个客户端都在配置文件里配置连接到该metastore服务。远程元存储的metastore服务和hive运行在不同的进程里。 远程元存储是生产环境部署方式。 本地部署过程 由于设备资源限制，没有太多机器配置类似生产环境的集群环境。所以通过docker搭建大集群环境。 搭建目标： 集群中hadoop集群由3台构成（1台master，2台slaves） Hive的元数据库使用Mysql，并且单独包裹在一个docker环境中。 环境准备准备hadoop集群环境。启docker集群： 1234CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc27312e13270 kiwenlau/hadoop:1.0 "sh -c 'service ssh …" 2 hours ago Up 2 hours hadoop-slave2f8b69885f3ef kiwenlau/hadoop:1.0 "sh -c 'service ssh …" 2 hours ago Up 2 hours hadoop-slave1439b359d230e kiwenlau/hadoop:1.0 "sh -c 'service ssh …" 2 hours ago Up 2 hours 0.0.0.0:8088-&gt;8088/tcp, 0.0.0.0:50070-&gt;50070/tcp hadoop-master Hive部署下载安装包：1234# 进入hadoop-master主机，进入hadoop目录：/use/local/hadoopwget http://apache.claz.org/hive/hive-2.3.3/apache-hive-2.3.3-bin.tar.gztar -zxvf apache-hive-2.3.3-bin.tar.gzmv apache-hive-2.3.3-bin hive 配置Hive环境变量：123456vi /etc/profile#hiveexport HIVE_HOME=/usr/local/hadoop/hivePATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$HIVE_HOME/bin:$PATH# 生效环境变量source /etc/profile 调整Hive的配置文件：12345# 进入hive 配置文件目录：cd confcp hive-default.xml.template hive-site.xml# 修改配置文件vim hive-site.xml 新建HDFS分布式文件目录：12345678# hadoop已经设置好环境变量，新建下面目录hadoop fs -mkdir -p /user/hive/warehouse hadoop fs -mkdir -p /user/hive/tmp hadoop fs -mkdir -p /user/hive/log # 设置目录权限hadoop fs -chmod -R 777 /user/hive/warehouse hadoop fs -chmod -R 777 /user/hive/tmp hadoop fs -chmod -R 777 /user/hive/log 可以用下面命令进行检查： 12345root@hadoop-master:/usr/local/hadoop/hive/conf# hadoop fs -ls /user/hiveFound 3 itemsdrwxrwxrwx - root supergroup 0 2018-08-14 07:34 /user/hive/logdrwxrwxrwx - root supergroup 0 2018-08-14 07:34 /user/hive/tmpdrwxrwxrwx - root supergroup 0 2018-08-14 07:34 /user/hive/warehouse 修改配置文件（hive-site.xml）：hive数据仓库数据路径：/user/hive/warehouse 需要使用hdfs新建文件目录。 12345&lt;property&gt; &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt; &lt;value&gt;/user/hive/warehouse&lt;/value&gt; &lt;description&gt;location of default database for the warehouse&lt;/description&gt;&lt;/property&gt; 配置查询日志存放目录： 12345&lt;property&gt; &lt;name&gt;hive.querylog.location&lt;/name&gt; &lt;value&gt;/user/hive/log/hadoop&lt;/value&gt; &lt;description&gt;Location of Hive run time structured log file&lt;/description&gt;&lt;/property&gt; 数据库JDBC连接配置（172.18.0.5为mysql的ip地址，暴露3306端口）： 12345&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://172.18.0.5:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&lt;/value&gt; &lt;description&gt;&lt;/property&gt; 数据库驱动： 12345&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;&lt;/property&gt; 数据库用户名： 12345&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;root&lt;/value&gt; &lt;description&gt;Username to use against metastore database&lt;/description&gt;&lt;/property&gt; 数据库密码： 12345&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;123456&lt;/value&gt; &lt;description&gt;password to use against metastore database&lt;/description&gt;&lt;/property&gt; 配置Hive临时目录： 1mkdir /usr/local/hadoop/hive/tmp 并在 hive-site.xml 中修改: 把${system:java.io.tmpdir} 改成真实物理绝对路径 /usr/local/hadoop/hive/tmp 把 ${system:user.name} 改成 ${user.name} 可以在外面编辑好配置文件，拷贝进docke： 12&gt; docker cp hive-site.xml 439b359d230e:/usr/local/hadoop/hive/conf/hive-site.xml&gt; 配置hive-env.sh文件：尾部加上下面的配置（或者修改注释部分的配置亦可）： 123HADOOP_HOME=/usr/local/hadoopexport HIVE_CONF_DIR=/usr/local/hadoop/hive/confexport HIVE_AUX_JARS_PATH=/usr/local/hadoop/hive/lib 配置Mysql启mysql容器，容器名：first-mysql，使用和hadoop一个桥接网络hadoop，密码为123456 1docker run --name first-mysql --net=hadoop -p 3306:3306 -e MYSQL\_ROOT\_PASSWORD=123456 -d mysql:5.7 回显： 12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES84ae224cee53 mysql:5.7 "docker-entrypoint.s…" 32 minutes ago Up 32 minutes 0.0.0.0:3306-&gt;3306/tcp first-mysql 在Hadoop-master中配置mysql客户端（用来访问mysql服务器）： 1apt-get install mysql-client-core-5.6 测试远程连接： 1mysql -h172.18.0.5 -P3306 -uroot -p123456 新建数据库，数据库名为hive： 12mysql&gt; CREATE DATABASE hive;Query OK, 1 row affected (0.00 sec) 初始化（Hive主机上）： 12cd /usr/local/hadoop/hive/bin./schematool -initSchema -dbType mysql 回显： 12345root@hadoop-master:/usr/local/hadoop/hive/bin# ./schematool -initSchema -dbType mysqlSLF4J: Class path contains multiple SLF4J bindings.。。。（略）schemaTool completed# 初始化成功 下载配置mysql驱动包，放在Hive的lib路径下面： 12cd /usr/local/hadoop/hive/libwget http://central.maven.org/maven2/mysql/mysql-connector-java/5.1.38/mysql-connector-java-5.1.38.jar 启动Hive做完上面准备工作后，开始启动hive： 12345678910root@hadoop-master:/usr/local/hadoop/hive/bin# ./hiveSLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/usr/local/hadoop/hive/lib/log4j-slf4j-impl-2.6.2.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/usr/local/hadoop/share/hadoop/common/lib/slf4j-log4j12-1.7.10.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]Logging initialized using configuration in jar:file:/usr/local/hadoop/hive/lib/hive-common-2.3.3.jar!/hive-log4j2.properties Async: trueHive-on-MR is deprecated in Hive 2 and may not be available in the future versions. Consider using a different execution engine (i.e. tez, spark) or using Hive 1.X releases.hive&gt; 最后进入hive的命令界面。 踩坑备注1、Hive提示SSL连接警告 1Tue Aug 14 10:53:12 UTC 2018 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. 虽然Hive SQL执行成功，但是报上面的错误。产生的原因是使用JDBC连接MySQL服务器时为设置useSSL参数 。 解决办法：javax.jdo.option.ConnectionURL 配置的value值进行调整，设置useSSL=false ，注意xml中的语法。 12345678&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://172.18.0.5:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&lt;/value&gt; &lt;description&gt; JDBC connect string for a JDBC metastore. To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL. For example, jdbc:postgresql://myhost/db?ssl=true for postgres database. &lt;/description&gt; 重启Hive，不再有警告。 远程部署对于远程部署需要单独启metastore服务，具体需要调整下面的配置文件（hive-site.xml）： 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hive.metastore.uris&lt;/name&gt; &lt;value&gt;thrift://hadoop-master:9083&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 启动metastore服务： 1nohup hive --service metastore &amp; 当然这属于简单方式将Hive都扎堆部署在一个容器中。可以在集群其他几点启metastore服务，提升架构的高可用性，避免单点问题。 参考文献1、Apache Hive-2.3.0 快速搭建与使用，https://segmentfault.com/a/1190000011303459 2、Hive提示警告SSL，https://blog.csdn.net/u012922838/article/details/73291524]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在Minikube上运行Kafka集群]]></title>
    <url>%2F2018%2F06%2F25%2F2019-07-27-%E5%9C%A8Minikube%E4%B8%8A%E8%BF%90%E8%A1%8CKafka%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 Minikube集群启动 第一部分 Kubernetes中StatefulSet介绍 第三部分 部署Zookeeper集群 第四部分 部署Kafka集群 第五部分 总结 参考文献及资料 背景Kafka和zookeeper是在两种典型的有状态的集群服务。首先kafka和zookeeper都需要存储盘来保存有状态信息，其次kafka和zookeeper每一个实例都需要有对应的实例Id(Kafka需要broker.id,zookeeper需要my.id)来作为集群内部每个成员的标识，集群内节点之间进行内部通信时需要用到这些标识。 对于这类服务的部署，需要解决两个大的问题，一个是状态保存，另一个是集群管理(多服务实例管理)。kubernetes中提的StatefulSet(1.5版本之前称为Petset)方便了有状态集群服务在上的部署和管理。具体来说是通过Init Container来做集群的初始化工 作，用 Headless Service来维持集群成员的稳定关系，用Persistent Volume和Persistent Volume Claim提供网络存储来持久化数据，从而支持有状态集群服务的部署。 StatefulSet 是Kubernetes1.9版本中稳定的特性，本文使用的环境为 Kubernetes 1.10.0。 第一部分 Minikube集群启动12345678910111213141516171819202122root@deeplearning:~# minikube startThere is a newer version of minikube available (v1.2.0). Download it here:https://github.com/kubernetes/minikube/releases/tag/v1.2.0To disable this notification, run the following:minikube config set WantUpdateNotification falseStarting local Kubernetes v1.10.0 cluster...Starting VM...Downloading Minikube ISO 153.08 MB / 153.08 MB [============================================] 100.00% 0sGetting VM IP address...Moving files into cluster...Downloading kubeadm v1.10.0Downloading kubelet v1.10.0Finished Downloading kubeadm v1.10.0Finished Downloading kubelet v1.10.0Setting up certs...Connecting to cluster...Setting up kubeconfig...Starting cluster components...Kubectl is now configured to use the cluster.Loading cached images from config file. 第二部分 Kubernetes中StatefulSet介绍使用Kubernetes来调度无状态的应用较为简单 StatefulSet 这个对象是专门用来部署用状态应用的，可以为Pod提供稳定的身份标识，包括hostname、启动顺序、DNS名称等。 在最新发布的 Kubernetes 1.5 我们将过去的 PetSet 功能升级到了 Beta 版本，并重新命名为StatefulSet 第三部分 部署Zookeeper集群第四部分 部署Kafka集群参考文献及材料1、kubernetes 中 kafka 和 zookeeper 有状态集群服务部署实践 (一) https://cloud.tencent.com/developer/article/1005492 2、https://cloud.tencent.com/developer/article/1005491 3、https://www.bogotobogo.com/DevOps/Docker/Docker_Kubernetes_StatefulSet.php https://technology.amis.nl/2018/04/19/15-minutes-to-get-a-kafka-cluster-running-on-kubernetes-and-start-producing-and-consuming-from-a-node-application/ 4、https://kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/ 5、https://jimmysong.io/kubernetes-handbook/guide/using-statefulset.html 6、Kubernetes部署Kafka集群 https://blog.usejournal.com/kafka-on-kubernetes-a-good-fit-95251da55837 https://www.cnblogs.com/cocowool/p/kubernetes_statefulset.html]]></content>
      <categories>
        <category>Minikube Kafka</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在Minikube上运行Flink集群]]></title>
    <url>%2F2018%2F06%2F25%2F2019-04-23-%E5%9C%A8Minikube%E4%B8%8A%E8%BF%90%E8%A1%8CFlink%E9%9B%86%E7%BE%A4%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 部署准备 第二部分 验证 总结 参考文献及资料 背景第一部分 部署准备首先当然需要部署minikube集群。启动minikube集群： 1234567891011# minikube startStarting local Kubernetes v1.10.0 cluster...Starting VM...Getting VM IP address...Moving files into cluster...Setting up certs...Connecting to cluster...Setting up kubeconfig...Starting cluster components...Kubectl is now configured to use the cluster.Loading cached images from config file. 上面的回显表明minikube已经启动成功。执行下面网络配置： 1# minikube ssh 'sudo ip link set docker0 promisc on' 第二部分 部署Flink集群一个基本的Flink集群运行在minikube需要三个组件： Deployment/Job：运行 JobManager Deployment for a pool of TaskManagers Service exposing the JobManager’s REST and UI ports 1.1 创建命名空间12# kubectl create -f namespace.yamlnamespace/flink created 其中namespace.yaml文件为： 123456kind: NamespaceapiVersion: v1metadata: name: flink labels: name: flink 查询minikube集群的的命名空间： 12345# kubectl get namespacesNAME STATUS AGEflink Active 1mkube-public Active 254dkube-system Active 254d 1.2 集群组件资源定义1.2.1 启动flink-jobmanager组件Job Manager 服务是Flink集群的主服务，使用jobmanager-deployment.yaml创建。 123456789101112131415161718192021222324252627282930apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: flink-jobmanager namespace: flinkspec: replicas: 1 template: metadata: labels: app: flink component: jobmanager spec: containers: - name: jobmanager image: flink:latest args: - jobmanager ports: - containerPort: 6123 name: rpc - containerPort: 6124 name: blob - containerPort: 6125 name: query - containerPort: 8081 name: ui env: - name: JOB_MANAGER_RPC_ADDRESS value: flink-jobmanager 1.2.2 启动flink-taskmanager组件使用taskmanager-deployment.yaml创建。 12345678910111213141516171819202122232425262728apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: flink-taskmanager namespace: flinkspec: replicas: 2 template: metadata: labels: app: flink component: taskmanager spec: containers: - name: taskmanager image: flink:latest args: - taskmanager ports: - containerPort: 6121 name: data - containerPort: 6122 name: rpc - containerPort: 6125 name: query env: - name: JOB_MANAGER_RPC_ADDRESS value: flink-jobmanager 1.2.3 启用flink服务使用jobmanager-service.yaml创建服务，并且将端口映射到minikube主机响应端口。 1234567891011121314151617181920212223apiVersion: v1kind: Servicemetadata: name: flink-jobmanager namespace: flinkspec: type: NodePort ports: - name: rpc port: 6123 nodePort: 30123 - name: blob port: 6124 nodePort: 30124 - name: query port: 6125 nodePort: 30125 - name: ui port: 8081 nodePort: 30081 selector: app: flink component: jobmanager 1.3 端口映射到虚拟机主机minikube虚拟机停止的情况下的端口转发命令如下： 1234# VBoxManage modifyvm "minikube" --natpf1 "30123_6123,tcp,,6123,,30123"# VBoxManage modifyvm "minikube" --natpf1 "30124_6123,tcp,,6124,,30124"# VBoxManage modifyvm "minikube" --natpf1 "30125_6125,tcp,,6125,,30125"# VBoxManage modifyvm "minikube" --natpf1 "30081_8081,tcp,,8081,,30081" 格式说明：vboxmanage modifyvm 宿主机名称 natpf “映射别名,tcp,,本机端口,,虚拟机端口” minikube虚拟机运行的情况下的端口转发命令如下： 1234# VBoxManage controlvm "minikube" --natpf1 "30123_6123,tcp,,6123,,30123"# VBoxManage controlvm "minikube" --natpf1 "30124_6123,tcp,,6124,,30124"# VBoxManage controlvm "minikube" --natpf1 "30125_6125,tcp,,6125,,30125"# VBoxManage controlvm "minikube" --natpf1 "30081_8081,tcp,,8081,,30081" 格式说明：vboxmanage controlvm 宿主机名称 natpf “映射别名,tcp,,本机端口,,宿主机端口” 另外如果要删除上面转发规则： vboxmanage controlvm 宿主机名称 natpf delete 映射别名 vboxmanage modifyvm 宿主机名称 natpf delete 映射别名 第三部分 验证3.1 minikube控制台界面为了是主机局域网类服务器都能访问minikube控制台，需要将端口映射出去。 1# VBoxManage modifyvm "minikube" --natpf1 "kubedashboard,tcp,,30000,,30000" 3.2 Flink控制台 总结（1）部署前提前拉取镜像到本地镜像库。 （2）需要将服务端口映射到本地机器端口，供局域网服务访问，为后续访问Flink提供方便。 参考文献1、Kubernetes Setup ：https://ci.apache.org/projects/flink/flink-docs-stable/ops/deployment/kubernetes.html 2、How to Deploy Flink Cluster &amp; Flink-exporter in Kubernetes Cluster：https://medium.com/pharos-production/how-to-deploy-flink-cluster-flink-exporter-in-kubernetes-cluster-48e24b440446 3、melentye/flink-kubernetes https://github.com/melentye/flink-kubernetes 4、Set up Ingress on Minikube with the NGINX Ingress Controller https://kubernetes.io/docs/tasks/access-application-cluster/ingress-minikube/]]></content>
      <categories>
        <category>Flink</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在Minikube上运行Spark集群]]></title>
    <url>%2F2018%2F06%2F25%2F2018-08-06-%E5%9C%A8Minikube%E4%B8%8A%E8%BF%90%E8%A1%8CSpark%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[[TOC] 背景​ Spark2.3版本开始支持使用spark-submit直接提交任务给Kubernetes集群。执行机制原理： Spark创建一个在Kubernetes pod中运行的Spark驱动程序。 驱动程序创建执行程序，这些执行程序也在Kubernetes pod中运行并连接到它们，并执行应用程序代码。 当应用程序完成时，执行程序窗格会终止并清理，但驱动程序窗格会保留日志并在Kubernetes API中保持“已完成”状态，直到它最终被垃圾收集或手动清理。 第一部分 环境准备1.1 minikube虚拟机准备由于spark集群对内存和cpu资源要求较高，在minikube启动前，提前配置较多的资源给虚拟机。 当minikube启动时，它以单节点配置开始，默认情况下占用1Gb内存和2CPU内核，但是，为了运行spark集群，这个资源配置是不够的，而且作业会失败。 12345# minikube config set memory 8192These changes will take effect upon a minikube delete and then a minikube start# minikube config set cpus 2These changes will take effect upon a minikube delete and then a minikube start 或者用下面的命令启集群 1# minikube start --cpus 2 --memory 8192 1.2 Spark环境准备第一步 下载saprk2.3 1# wget http://apache.mirrors.hoobly.com/spark/spark-2.3.0/spark-2.3.0-bin-hadoop2.7.tgz 解压缩： 1# tar xvf spark-2.3.0-bin-hadoop2.7.tgz 制作docker镜像 12# cd spark-2.3.0-bin-hadoop2.7# docker build -t rongxiang/spark:2.3.0 -f kubernetes/dockerfiles/spark/Dockerfile . 查看镜像情况： 123# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZErongxiang1986/spark 2.3.0 c5c806314f25 5 days ago 346MB 登录docker 账户： 12345# docker loginLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.Username: Password: Login Succeeded 将之前build好的镜像pull到docker hub上： 1# docker push rongxiang1986/spark:2.3.0 注意这里的格式要求（我踩坑了）：docker push 注册用户名/镜像名 在https://hub.docker.com/上查看，镜像确实push上去了。 第二部分 提交Spark作业2.1 作业提交提前配置serviceaccount信息。 1234# kubectl create serviceaccount sparkserviceaccount/spark created# kubectl create clusterrolebinding spark-role --clusterrole=edit --serviceaccount=default:spark --namespace=defaultclusterrolebinding.rbac.authorization.k8s.io/spark-role created 提交作业： 12345678910# ./spark-submit \--master k8s://https://192.168.99.100:8443 \--deploy-mode cluster \--name spark-pi \--class org.apache.spark.examples.SparkPi \--conf spark.kubernetes.authenticate.driver.serviceAccountName=spark \--conf spark.kubernetes.authenticate.executor.serviceAccountName=spark \--conf spark.executor.instances=2 \--conf spark.kubernetes.container.image=rongxiang1986/spark:2.3.0 \local:///opt/spark/examples/jars/spark-examples_2.11-2.3.0.jar 提交命令的参数含义分别是： --class：应用程序的入口点（命令中使用：org.apache.spark.examples.SparkPi）； --master：Kubernetes集群的URL（k8s://https://192.168.99.100:8443）； --deploy-mode：驱动程序部署位置（默认值：客户端），这里部署在集群中； --conf spark.executor.instances=2：运行作业启动的executor个数； --conf spark.kubernetes.container.image=rongxiang1986/spark:2.3.0：使用的docker镜像名称； local:///opt/spark/examples/jars/spark-examples_2.11-2.3.0.jar：应用程序依赖jar包路径； 注意：目前deploy-mode只支持cluster模式，不支持client模式。 Error: Client mode is currently not supported for Kubernetes. 作业运行回显如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677782018-08-12 15:51:17 WARN Utils:66 - Your hostname, deeplearning resolves to a loopback address: 127.0.1.1; using 192.168.31.3 instead (on interface enp0s31f6)2018-08-12 15:51:17 WARN Utils:66 - Set SPARK_LOCAL_IP if you need to bind to another address2018-08-12 15:51:18 INFO LoggingPodStatusWatcherImpl:54 - State changed, new state: pod name: spark-pi-7314d819cd3730b4bf7d02bfedd21373-driver namespace: default labels: spark-app-selector -&gt; spark-8be4d909d85148bc9f1f91d511c275c6, spark-role -&gt; driver pod uid: 7f6dd84d-9e04-11e8-b58f-080027b3a6c0 creation time: 2018-08-12T07:51:18Z service account name: spark volumes: spark-token-rzrgk node name: N/A start time: N/A container images: N/A phase: Pending status: []2018-08-12 15:51:18 INFO LoggingPodStatusWatcherImpl:54 - State changed, new state: pod name: spark-pi-7314d819cd3730b4bf7d02bfedd21373-driver namespace: default labels: spark-app-selector -&gt; spark-8be4d909d85148bc9f1f91d511c275c6, spark-role -&gt; driver pod uid: 7f6dd84d-9e04-11e8-b58f-080027b3a6c0 creation time: 2018-08-12T07:51:18Z service account name: spark volumes: spark-token-rzrgk node name: minikube start time: N/A container images: N/A phase: Pending status: []2018-08-12 15:51:18 INFO LoggingPodStatusWatcherImpl:54 - State changed, new state: pod name: spark-pi-7314d819cd3730b4bf7d02bfedd21373-driver namespace: default labels: spark-app-selector -&gt; spark-8be4d909d85148bc9f1f91d511c275c6, spark-role -&gt; driver pod uid: 7f6dd84d-9e04-11e8-b58f-080027b3a6c0 creation time: 2018-08-12T07:51:18Z service account name: spark volumes: spark-token-rzrgk node name: minikube start time: 2018-08-12T07:51:18Z container images: rongxiang1986/spark:2.3.0 phase: Pending status: [ContainerStatus(containerID=null, image=rongxiang1986/spark:2.3.0, imageID=, lastState=ContainerState(running=null, terminated=null, waiting=null, additionalProperties=&#123;&#125;), name=spark-kubernetes-driver, ready=false, restartCount=0, state=ContainerState(running=null, terminated=null, waiting=ContainerStateWaiting(message=null, reason=ContainerCreating, additionalProperties=&#123;&#125;), additionalProperties=&#123;&#125;), additionalProperties=&#123;&#125;)]2018-08-12 15:51:18 INFO Client:54 - Waiting for application spark-pi to finish...2018-08-12 15:51:51 INFO LoggingPodStatusWatcherImpl:54 - State changed, new state: pod name: spark-pi-7314d819cd3730b4bf7d02bfedd21373-driver namespace: default labels: spark-app-selector -&gt; spark-8be4d909d85148bc9f1f91d511c275c6, spark-role -&gt; driver pod uid: 7f6dd84d-9e04-11e8-b58f-080027b3a6c0 creation time: 2018-08-12T07:51:18Z service account name: spark volumes: spark-token-rzrgk node name: minikube start time: 2018-08-12T07:51:18Z container images: rongxiang1986/spark:2.3.0 phase: Running status: [ContainerStatus(containerID=docker://d43089c8340affc4534f796b94a90ae080670c36c095176575fbeebacaab648e, image=rongxiang1986/spark:2.3.0, imageID=docker-pullable://rongxiang1986/spark@sha256:3e93a2d462679015a9fb7d723f53ab1d62c5e3619e3f1564d182c3d297ddf75d, lastState=ContainerState(running=null, terminated=null, waiting=null, additionalProperties=&#123;&#125;), name=spark-kubernetes-driver, ready=true, restartCount=0, state=ContainerState(running=ContainerStateRunning(startedAt=Time(time=2018-08-12T07:51:51Z, additionalProperties=&#123;&#125;), additionalProperties=&#123;&#125;), terminated=null, waiting=null, additionalProperties=&#123;&#125;), additionalProperties=&#123;&#125;)]2018-08-12 15:51:57 INFO LoggingPodStatusWatcherImpl:54 - State changed, new state: pod name: spark-pi-7314d819cd3730b4bf7d02bfedd21373-driver namespace: default labels: spark-app-selector -&gt; spark-8be4d909d85148bc9f1f91d511c275c6, spark-role -&gt; driver pod uid: 7f6dd84d-9e04-11e8-b58f-080027b3a6c0 creation time: 2018-08-12T07:51:18Z service account name: spark volumes: spark-token-rzrgk node name: minikube start time: 2018-08-12T07:51:18Z container images: rongxiang1986/spark:2.3.0 phase: Succeeded status: [ContainerStatus(containerID=docker://d43089c8340affc4534f796b94a90ae080670c36c095176575fbeebacaab648e, image=rongxiang1986/spark:2.3.0, imageID=docker-pullable://rongxiang1986/spark@sha256:3e93a2d462679015a9fb7d723f53ab1d62c5e3619e3f1564d182c3d297ddf75d, lastState=ContainerState(running=null, terminated=null, waiting=null, additionalProperties=&#123;&#125;), name=spark-kubernetes-driver, ready=false, restartCount=0, state=ContainerState(running=null, terminated=ContainerStateTerminated(containerID=docker://d43089c8340affc4534f796b94a90ae080670c36c095176575fbeebacaab648e, exitCode=0, finishedAt=Time(time=2018-08-12T07:51:57Z, additionalProperties=&#123;&#125;), message=null, reason=Completed, signal=null, startedAt=Time(time=2018-08-12T07:51:51Z, additionalProperties=&#123;&#125;), additionalProperties=&#123;&#125;), waiting=null, additionalProperties=&#123;&#125;), additionalProperties=&#123;&#125;)]2018-08-12 15:51:57 INFO LoggingPodStatusWatcherImpl:54 - Container final statuses: Container name: spark-kubernetes-driver Container image: rongxiang1986/spark:2.3.0 Container state: Terminated Exit code: 02018-08-12 15:51:57 INFO Client:54 - Application spark-pi finished.2018-08-12 15:51:57 INFO ShutdownHookManager:54 - Shutdown hook called2018-08-12 15:51:57 INFO ShutdownHookManager:54 - Deleting directory /tmp/spark-6dd1c204-4ad7-40c4-b47f-a34f18e1995d 2.2 日志查询可以通过命令查看容器执行日志，或者通过kubernetes-dashboard提供web界面查看。 1# kubectl logs spark-pi-709e1c1b19813e7cbc1aeff45200c64e-driver 1234567891011121314152018-08-12 07:51:57 INFO DAGScheduler:54 - Job 0 finished: reduce at SparkPi.scala:38, took 0.576528 sPi is roughly 3.13367566837834182018-08-12 07:51:57 INFO AbstractConnector:318 - Stopped Spark@9635fa&#123;HTTP/1.1,[http/1.1]&#125;&#123;0.0.0.0:4040&#125;2018-08-12 07:51:57 INFO SparkUI:54 - Stopped Spark web UI at http://spark-pi-7314d819cd3730b4bf7d02bfedd21373-driver-svc.default.svc:40402018-08-12 07:51:57 INFO KubernetesClusterSchedulerBackend:54 - Shutting down all executors2018-08-12 07:51:57 INFO KubernetesClusterSchedulerBackend$KubernetesDriverEndpoint:54 - Asking each executor to shut down2018-08-12 07:51:57 INFO KubernetesClusterSchedulerBackend:54 - Closing kubernetes client2018-08-12 07:51:57 INFO MapOutputTrackerMasterEndpoint:54 - MapOutputTrackerMasterEndpoint stopped!2018-08-12 07:51:57 INFO MemoryStore:54 - MemoryStore cleared2018-08-12 07:51:57 INFO BlockManager:54 - BlockManager stopped2018-08-12 07:51:57 INFO BlockManagerMaster:54 - BlockManagerMaster stopped2018-08-12 07:51:57 INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint:54 - OutputCommitCoordinator stopped!2018-08-12 07:51:57 INFO SparkContext:54 - Successfully stopped SparkContext2018-08-12 07:51:57 INFO ShutdownHookManager:54 - Shutdown hook called2018-08-12 07:51:57 INFO ShutdownHookManager:54 - Deleting directory /tmp/spark-435d5ab2-f7b4-45d0-a00f-0bd9f162f9db 执行结束后executor pod被自动清除。计算得到pi的值为： 1Pi is roughly 3.1336756683783418 如果作业通过cluster提交，driver容器会被保留，可以查看： 123456789# minikube service list|-------------|------------------------------------------------------|-----------------------------|| NAMESPACE | NAME | URL ||-------------|------------------------------------------------------|-----------------------------|| default | kubernetes | No node port || default | spark-pi-27fcc168740e372292b27185d124ad7b-driver-svc | No node port || kube-system | kube-dns | No node port || kube-system | kubernetes-dashboard | http://192.168.99.100:30000 ||-------------|------------------------------------------------------|-----------------------------| 参考文献1、Running Spark on Kubernetes ：https://spark.apache.org/docs/latest/running-on-kubernetes.html 2、在Minikube Kubernetes集群上运行Spark工作：https://iamninad.com/running-spark-job-on-kubernetes-minikube/]]></content>
      <categories>
        <category>Minikube spark Kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu上部署Minikube]]></title>
    <url>%2F2018%2F06%2F25%2F2018-06-25-%E5%9C%A8Ubuntu%E4%B8%8A%E9%83%A8%E7%BD%B2Minikube%2F</url>
    <content type="text"><![CDATA[[TOC] 背景Kubernetes是Google推出的容器编排工具，这是Google保密十几年的强大武器Borg的开源版本。Kubernetes这个名字源于古希腊，意思是舵手。既然docker被比喻成大海上驮着集装箱的鲸鱼，那么Kubernetes就是舵手，掌握鲸鱼的游弋方向，寓意深刻。 Kubernetes第一个正式版本于2015年7月发布。从Kubernetes 1.3开始提供了一个叫Minikube的强大测试工具，可以在主流操作系统平台（win、os、linux）上运行单节点的小型集群，这个工具默认安装和配置了一个Linux VM，Docker和Kubernetes的相关组件，并且提供Dashboard。 本篇主要介绍Ubuntu平台上部署Minikube。Minikube利用本地虚拟机环境部署Kubernetes，其基本架构如下图所示。 Minitube项目地址：https://github.com/kubernetes/minikube 第一部分 准备Minikube在OS X和Windows上部署需要安装虚拟机实现（用虚拟机来初始化Kubernetes环境），但是Linux例外可以使用自己的环境。参见：https://github.com/kubernetes/minikube#quickstart 1.1 准备工作检查CPU是否支持虚拟化，即BIOS中参数（VT-x/AMD-v ）设置为enable。 1.2 安装虚拟机Minikube在不同操作系统上支持不同的虚拟驱动： macOS xhyve driver, VirtualBox 或 VMware Fusion Linux VirtualBox 或 KVM 注意: Minikube 也支持 --vm-driver=none 选项来在本机运行 Kubernetes 组件，这时候需要本机安装了 Docker。 Windows VirtualBox 或 Hyper-V 本篇在Ubuntu部署VirtualBox虚拟驱动。 123# wget https://download.virtualbox.org/virtualbox/5.1.38/virtualbox-5.1_5.1.38-122592~Ubuntu~xenial_i386.deb#dpkg -i virtualbox-5.1_5.1.38-122592~Ubuntu~xenial_i386.deb 第二部分 安装minikube1234# curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.28.0/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/ % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 40.8M 100 40.8M 0 0 4671k 0 0:00:08 0:00:08 --:--:-- 7574k 第三部分 安装Kubectlkubectl即kubernetes的客户端，通过他可以进行类似docker run等容器管理操作 。 下载： 1234567# curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 52.5M 100 52.5M 0 0 6654k 0 0:00:08 0:00:08 --:--:-- 10.3M# chmod +x kubectl# mv kubectl /usr/local/bin/ 第四部分 启集群1234567891011121314151617root@deeplearning:~# minikube start --registry-mirror=https://registry.docker-cn.comStarting local Kubernetes v1.10.0 cluster...Starting VM...Downloading Minikube ISO 153.08 MB / 153.08 MB [============================================] 100.00% 0sGetting VM IP address...Moving files into cluster...Downloading kubeadm v1.10.0Downloading kubelet v1.10.0Finished Downloading kubelet v1.10.0Finished Downloading kubeadm v1.10.0Setting up certs...Connecting to cluster...Setting up kubeconfig...Starting cluster components...Kubectl is now configured to use the cluster.Loading cached images from config file. 进入minikube虚拟机： 123456789101112root@deeplearning:~# minikube ssh _ _ _ _ ( ) ( ) ___ ___ (_) ___ (_)| |/') _ _ | |_ __ /' _ ` _ `\| |/' _ `\| || , &lt; ( ) ( )| '_`\ /'__`\| ( ) ( ) || || ( ) || || |\`\ | (_) || |_) )( ___/(_) (_) (_)(_)(_) (_)(_)(_) (_)`\___/'(_,__/'`\____)$ # 通过exit退出集群$ exitlogout 虚拟机地址： 12# minikube ip192.168.99.100 启停集群： 1# minikube start/stop 获取集群信息： 123root@deeplearning:/home/rongxiang# kubectl get node NAME STATUS ROLES AGE VERSIONminikube Ready master 7h v1.10.0 删除集群： 123# minikube delete # rm -rf ~/.minikube # kubeadm reset 第五部分 心酸踩坑如果在启集群时遇到下面类似的错误，不要慌。国内环境99%的原因是GFW的原因，集群在抓取Google站点docker镜像时候被墙咔嚓了，然后time out。 WTF！我开始不知道呀。网上的部署指引都那么轻松！！然后重复删除集群，重新装，配参数，给docker配代理。尼玛，最后代理都被咔嚓了。终于撞了南墙，去阿里云拉取镜像，几秒钟搞定。 1234567891011121314151617# minikube startStarting local Kubernetes v1.10.0 cluster...Starting VM...Getting VM IP address...Moving files into cluster...Setting up certs...Connecting to cluster...Setting up kubeconfig...Starting cluster components...E0626 12:57:46.868961 26526 start.go:299] Error restarting cluster: restarting kube-proxy: waiting for kube-proxy to be up for configmap update: timed out waiting for the condition================================================================================An error has occurred. Would you like to opt in to sending anonymized crashinformation to minikube to help prevent future errors?To opt out of these messages, run the command: minikube config set WantReportErrorPrompt false================================================================================Please enter your response [Y/n]: 第六部分 远程访问 minikube dashboard在虚拟机启动前，设置端口转发。注意这里使用tcp而不是http。 1# VBoxManage modifyvm "minikube" --natpf1 "kubedashboard,tcp,,30000,,30000" 然后启动虚拟机，这时候局域网上的其他服务器就可以通过宿主机的IP:30000访问web UI。 或者： 1# kubectl proxy --address='0.0.0.0' --disable-filter=true 附录 补充VBoxManage管理查询虚拟机： 123# VBoxManage list vms"&lt;inaccessible&gt;" &#123;4a3cefe1-11d1-45d2-91c5-1e39fccb6a8d&#125;"minikube" &#123;dfcd1bdf-afc1-49e6-a270-9d8ff14bf167&#125; 删除虚拟机： 1# VBoxManage unregistervm --delete 4a3cefe1-11d1-45d2-91c5-1e39fccb6a8d 参考文献及材料1、Minitube项目地址：https://github.com/kubernetes/minikube]]></content>
      <categories>
        <category>Minikube Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Cloudera Quickstart Docker镜像快速部署hadoop集群]]></title>
    <url>%2F2018%2F06%2F25%2F2019-04-30-%E4%BD%BF%E7%94%A8Cloudera%20Quickstart%20Docker%E9%95%9C%E5%83%8F%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2hadoop%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 Docker镜像准备 第二部分 运行容器 第三部分 cloudera-manager管理 第四部分 组件使用测试 第五部分 总结 参考文献及资料 背景通常在个人笔记本上部署Hadoop测试集群（含生态圈各组件）是个很耗时的工作。Cloudera公司提供一个快速部署的Docker镜像，可以快速启动一个测试集群。 测试环境为Ubuntu服务器 第一部分 Docker镜像准备首先本机需要部署有docker环境，如果没有需要提前部署。 1.1 拉取Docker镜像可以从DockerHub上拉取cloudera/quickstart镜像。 镜像项目地址为：https://hub.docker.com/r/cloudera/quickstart 1# docker pull cloudera/quickstart:latest 如果不具备联网环境，可以通过镜像介质包安装。介质可以在官网（需要注册用户）下载：https://www.cloudera.com/downloads/quickstart_vms/5-13.html 由于墙的原因下载会很慢 123# wget https://downloads.cloudera.com/demo_vm/docker/cloudera-quickstart-vm-5.13.0-0-beta-docker.tar.gz# tar xzf cloudera-quickstart-vm-5.13.0-0-beta-docker.tar.gz# docker import - cloudera/quickstart:latest &lt; cloudera-quickstart-vm-5.13.0-0-beta-docker/*.tar 1.2 检查镜像库12# docker images|grep clouderacloudera/quickstart latest 4239cd2958c6 3 years ago 6.34GB 说明镜像准备好了，下面基于镜像启动容器。 第二部分 运行容器2.1 使用镜像启动容器启动CDH集群的命令格式为： 1# docker run --hostname=quickstart.cloudera --privileged=true -t -i [OPTIONS] [IMAGE] /usr/bin/docker-quickstart 官方提示的参数介绍如下： Option Description –hostname=quickstart.cloudera Required: Pseudo-distributed configuration assumes this hostname.容器主机名（/etc/hosts中指定hostname）。 –privileged=true Required: For HBase, MySQL-backed Hive metastore, Hue, Oozie, Sentry, and Cloudera Manager.这是Hbase组件需要的模式。 -t Required: Allocate a pseudoterminal. Once services are started, a Bash shell takes over. This switch starts a terminal emulator to run the services. -i Required: If you want to use the terminal, either immediately or connect to the terminal later. -p 8888 Recommended: Map the Hue port in the guest to another port on the host.端口映射参数。 -p [PORT] Optional: Map any other ports (for example, 7180 for Cloudera Manager, 80 for a guided tutorial). -d Optional: Run the container in the background.容器后台启动。 –name 容器的名字 -v host_path:container_path 主机上目录挂载到容器中目录上，主机上该放入任何东西，Docker容器中对于目录可以直接访问。 当然还可以自定义其他docker启动参数。最后启动命令整理为： 1234567docker run -t -i -d \--name cdh \--hostname=quickstart.cloudera \--privileged=true \-v /data/CDH:/src \-p 8020:8020 -p 8022:8022 -p 7180:7180 -p 21050:21050 -p 50070:50070 -p 50075:50075 -p 50010:50010 -p 50020:50020 -p 8890:8890 -p 60010:60010 -p 10002:10002 -p 25010:25010 -p 25020:25020 -p 18088:18088 -p 8088:8088 -p 19888:19888 -p 7187:7187 -p 11000:11000 -p 8888:8888 cloudera/quickstart \/bin/bash -c '/usr/bin/docker-quickstart' Cloudera 本身的 manager 是 7180 端口，提前配置端口映射。 启动容器我们使用了-d后台启动参数，如果没有指定后台启动，终端将自动连接到容器，退出shell后容器会中止运行（可以通过使用Ctrl + P + Q命令退出，这样容器会继续保持运行）。 对于已经后台运行的容器，我们使用下面的命令进入容器shell： 1# docker attach [CONTAINER HASH] 2.2 时钟同步问题容器内部使用的时间时区为UTC，和主机（宿主机通常为CST（东八区））不同时区，会提示时钟同步问题。解决的办法是： 在环境变量中添加时区变量,并source生效: 123$ vi /etc/profile文件末尾添加一行：TZ='Asia/Shanghai'; export TZ$ source /etc/profile 最后启动时钟同步服务： 12345[root@quickstart home]# service ntpd startStarting ntpd: [ OK ]# 检查服务状态[root@quickstart home]# service ntpd statusntpd (pid 13536) is running... 这样完成时钟同步。 2.3 使用集群服务这样集群的大部分服务组件均可使用。 第三部分 cloudera-manager管理3.1 启动管理服务CDH在该镜像中提供cloudera-manager组件，用户集群web管理界面，可以通过下面的命令启动。 需要注意的是，启动后CDH会停止其他组件服务。 12345678910111213141516171819202122232425#./home/cloudera/cloudera-manager --express[QuickStart] Shutting down CDH services via init scripts...kafka-server: unrecognized serviceJMX enabled by defaultUsing config: /etc/zookeeper/conf/zoo.cfg[QuickStart] Disabling CDH services on boot...error reading information on service kafka-server: No such file or directory[QuickStart] Starting Cloudera Manager server...[QuickStart] Waiting for Cloudera Manager API...[QuickStart] Starting Cloudera Manager agent...[QuickStart] Configuring deployment...Submitted jobs: 14[QuickStart] Deploying client configuration...Submitted jobs: 16[QuickStart] Starting Cloudera Management Service...Submitted jobs: 24[QuickStart] Enabling Cloudera Manager daemons on boot...________________________________________________________________________________Success! You can now log into Cloudera Manager from the QuickStart VM's browser: http://quickstart.cloudera:7180 Username: cloudera Password: cloudera 集群控制台的地址为：http://quickstart.cloudera:7180，需要注意的是这里quickstart.cloudera是主机名，需要客户端hosts中配置，否则使用实IP或者容器端口映射后使用宿主机IP（例如：192.168.31.3）。 用户名和密码为：cloudera/cloudera,登录界面如下： 登录后，下图是集群控制台： 从管理界面上可以看到除了主机和 manager ，其他服务组件均未启动。 3.2 启动集群组件服务在控制台上，我们按照顺序启动HDFS、Hive、Hue、Yarn服务。 如果服务启动异常，可以尝试重启服务组件。注意需要先启动HDFS后启动Hive，否则需要重启Hive。 第四部分 组件使用测试4.1 HDFS组件使用我们使用HDFS的Python API与集群hdfs文件系统进行交互测试： 4.1.1 查看文件系统123456from hdfs.client import Clientclient = Client("http://192.168.31.3:50070", root="/", timeout=100)print(client.list("/"))# ['benchmarks', 'hbase', 'tmp', 'user', 'var']# 返回一个list记录主目录 4.1.2 上传新增文件注意这里需要在宿主机（客户端机器）配置hosts文件： 1192.168.31.3 quickstart.cloudera 然后执行： 123client.upload("/tmp", "/root/jupyter/nohup.out")# '/tmp/nohup.out'# 返回路径信息 4.1.3 下载hdfs文件12client.download("/tmp/nohup.out", "/tmp")# 返回路径'/tmp/nohup.out' 第五部分 总结1、Cloudera 的 docker 版本分成两部分启动。(1)启动各组件启动,使用命令为： /usr/bin/docker-quickstart，(2) 启动Cloudera manager 管理服务，启动命令为：/home/cloudera/cloudera-manager。docker启动时选择启动一项。 参考文献及材料1、cloudera/quickstart镜像地址：https://hub.docker.com/r/cloudera/quickstart 2、cloudera/quickstart镜像部署指引：https://www.cloudera.com/documentation/enterprise/5-6-x/topics/quickstart_docker_container.html 3、利用 Docker 搭建单机的 Cloudera CDH 以及使用实践]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[5分钟介绍深度学习（科普）]]></title>
    <url>%2F2018%2F04%2F16%2F2018-04-15-5%E5%88%86%E9%92%9F%E4%BB%8B%E7%BB%8D%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%A7%91%E6%99%AE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[历史背景最近几年Deep Learning、AI人工智能、机器学习等名词称为新闻热点，特别是Google Deep mind的Alpha Go战胜韩国棋手李世石，让深度学习妇孺皆知。 首先从概念范畴上讲，deep learning属于机器学习的一个分支，追根溯源其实是人工神经网络。顾名思义，人工神经网络是借鉴人类神经网路的结构原型，算生物仿生学（虽然人类到现在也没弄明白大脑原理）。 例如下面就是一个3层结构的人工神经网络（1个输入层、1个隐藏层、1个输出层）。 1989年Yann LeCun使用反向传播算法（Back Propagation）应用于多层神经网络训练。但一旦层数较大，网络的参数和训练计算量成倍增加，通常需要几周时间才能完成参数训练，另外反向传播算法容易梯度爆炸。研究人员获得好的结果，时间成本太大。 所以当时机器学习研究方向中，支持向量机（SVM）算法比多层神经网络更为热门，神经网络研究则相当冷门。 直到2012 年的ImageNet 图像分类竞赛中，Alex Krizhevsky使用CNN（卷积）多层网络（共8层、6千万个参数）赢得当年的比赛，领先第二名10.8个百分点。并且模型使用GPU芯片训练、引入正则技术（Dropout）。 从此多层神经网络成为机器学习中的研究热点。而为了“洗白”以前暗淡历史，被赋予了新的名称：Deep Learning。 深度学习背后的数学目前的人工智能均属于弱人工智能（不具备心智和意识）。事实上，深度学习目前主要在图像识别和声音识别场景中获得较好的效果。深度学习的成为热点，依赖于两方面条件的成熟: 算力的提升，训练中大量使用GPU。 大量数据的获得和沉淀。 弱人工智能背后的理论基础依赖于数学和统计理论，其实更应该算数据科学的范畴。 比如输入数据具有$m$维特征，而输出特征为$k$维（例如如果是个二分类问题，$k=2$）。我们使用3层神经网络（输入层为$m$维，即含有$m$个神经元；隐藏层为$n$维，输出层为$k$维）用来训练。 通常我们将输入数据看成$R^m$（$m$维欧几里得空间），输出数据看成$R^k$（$k$维欧式空间）,如下图： 从数学上看，神经网络的结构定义了一个函数空间：${R^{n}} \xrightarrow{\text{f}} {R^{h}} \xrightarrow{\text{g}} {R^{m}}$ 。这个函数空间中元素是非线性的（隐藏层和输出层有非线性的激活函数）。空间中每个函数由网络中的参数（w，b）唯一决定。 神经网络训练的过程可以形象的理解为寻找最佳函数的过程：输入层“吃进”大量训练数据，通过非线性函数的作用，观察输出层输出结果和实际值的差异。这是一个监督学习的过程。 如果差异（误差）在容忍范围内，停止训练，认为该函数是目标函数。 如果差异较大，反向传播算法根据梯度下降的反向更新网络中的参数（w，b），即挑选新的函数。 重新喂进数据，计算新挑选函数的误差。如此循环，直到找到目标函数（也可设置提前结束训练）。 为什么神经网络的发展最后偏向的是“深度”呢？即增加层数来提高网络的认知能力。为什么没有“宽度学习”？即增加网络隐藏层的维度（宽度）。 其实从数学上可以证明深度网络和“宽度网络”的等价性。证明提示：考虑网络定义的函数空间出发。 写在最后（畅想未来）深度学习的局限性思考目前深度学习被各行各业应用于各种场景，而且有些特定场景取得了良好结果。但是传统的深度学习仍属于监督学习，更像一个被动的执行者，按照人类既定的规则，吃进海量数据，然后训练。 那么深度网络是否真的理解和学到了模式？还是只学会对有限数据的模式识别？甚至就是一个庞大的记忆网络？这都是值得我们深度思考的。 GAN对抗网络那么怎么能说明模型真的学习并理解了。我们提出了一个原则：如果你理解了一个事物，那么你就可以创造它。这样就发明了GAN对抗网络。让网络自己去创造事物，然后用现实数据去监督，当网络的创造能力和现实接近时，我们认为网络学会了。 其实思想类似传统的遗传算法。 强化学习另外传统的深度学习，输入的环境（数据）是固定的。然而现实中我们学习过程其实是：环境（数据）与学习个体互相作用的交互过程。这个学习过程人类由于时间有限，是个漫长的过程。但是计算机有个天然优势，可以同时启用成千上万的学习个体完成与环境数据的交互学习过程。例如Alpha Go启用上万个体，两两互搏，配上强大算力，短时间完成学习，这是人类不可企及的。 迁移学习人类学习中还有个方法叫：触类旁通。其实就是不同场景训练模型的借鉴。例如A场景得到训练好的模型（网络参数），对于新的场景B，可以尝试直接用A场景的网络（或部分使用，拼接），以此来减少训练成本。 那么新的问题来了：是否具有统一的迁移标准，即什么模型是适合迁移的？如果这些问题没有理论基础支持，迁移学习也摆脱不了“炼丹术”的非议。 深度学习从过去的暗淡无色到现在的光耀夺目。 然而任何方法都是有边际效应的。 人工智能的终点还很遥远，谁是下一颗耀眼的明星，需要学界和工业界共同探索。 ​ ​ 2018年4月15日 夜]]></content>
      <categories>
        <category>network</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机语言中编译和解释的总结]]></title>
    <url>%2F2018%2F04%2F14%2F2018-04-14-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%BC%96%E8%AF%91%E5%92%8C%E8%A7%A3%E9%87%8A%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 几个概念 第二部分 编译器和解释器 第三部分 解释型语言和编译型语言 参考文献及资料 背景 非计算机科班，主要是总结给自己看的，如果有表达错误，请大家指正。 第一部分 几个概念高级语言与低级语言高级语言（High Level Programming Language）和低级语言（Low Level Programming Language）是一对相对的共生概念（没有一个严格的量化区分标准）。 低级语言更接近计算机底层资源（直接与硬件资源进行交互）。例如汇编语言。 高级语言进行了封装和抽象，语言设计更容易被人类思维逻辑所理解（和低级语言比较，学习曲线较缓）。例如C、C++、java、python等。 随着计算机语言的蓬勃发展（计算机语言的文艺复兴），过去一些高级语言，也有人重新定位成低级语言，例如C语言。 字节码与机器码字节码（Byte Code）不是一种计算机语言。属于高级语言预编译生成的中间码。高级语言源码在预编译的过程中，就完成这部分工作，生成字节码。 机器码（Machine Code）是一组可以直接被CPU执行的指令集。所有语言（低级和高级）最后都需要编译或解释成机器码（CPU指令集），才能执行。 第二部分 编译器和解释器编译器（Interpreter） A compiler is a computer program (or a set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language), with the latter often having a binary form known as object code. The most common reason for converting source code is to create an executable program. 编译器是一种计算机程序。 编译器是一个计算机语言的翻译工具，直接将源代码文件预编译（形象的说：翻译）成更低级的代码语言（字节码码、机器码）。 编译器不会去执行编译的结果，只生成编译的结果文件。 解释器（Compiler） In computer science, an interpreter is a computer program that directly executes, i.e. performs, instructions written in a programming or scripting language, without previously compiling them into a machine language program. An interpreter generally uses one of the following strategies for program execution: 1、parse the source code and perform its behavior directly. 2、translate source code into some efficient intermediate representation and immediately execute this. 3、explicitly execute stored precompiled code made by a compiler which is part of the interpreter system. 解释器是一种计算机程序。 解释器读取源代码或者中间码文件，转换成机器码并与计算机硬件交互。即逐行执行源码。 解释器会将源代码转换成一种中间代码不会输出更低级的编译结果文件。输出执行结果。 第三部分 解释型语言和编译型语言两者的区别主要是源码编译时间的差异。相同点都要翻译成机器码后由计算机执行。 编译型语言 编译语言的源码文件需要提前通过编译器编译成机器码文件（比如win中的exe可执行文件）。 执行时，只需执行编译结果文件。不需要重复翻译。 这类语言有：C、C++、Fortran、Pascal等。 解释型语言 解释型语言在运行时进行翻译。比如VB语言，在执行的时候，解释器将语言翻译成机器码，然后执行。 这类语言有：Ruby、Perl、JavaScript、PHP等。 混合型语言但是随着计算机语言的发展，有些语言兼具两者的特点。 JAVA语言 JAVA编译过程只是将.java文件翻译成字节码（Byte Code）（.class文件）。字节码文件交由java虚拟机（JVM）解释运行。也就是说Java源码文件既要编译也要JVM虚拟机进行解释后运行。所以有种说法认为Java是半解释型语言（semi-interpreted” language）。 Python语言 python其实类似Java。例如一个python文件test.py ，解释器首先尝试读取该文件历史编译结果（pyc文件）即test.pyc文件或者test.pyo 。如果没有历史文件或者编译文件的日期较旧（即py文件可能有更新），解释器会重新编译生成字节码文件（pyc文件），然后Python虚拟机对字节码解释执行。 参考文献及资料【1】 你知道「编译」与「解释」的区别吗？]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解Python语言中import机制]]></title>
    <url>%2F2018%2F04%2F14%2F2018-04-14-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E8%AF%AD%E8%A8%80%E4%B8%ADimport%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 windows下安装 第二部分 配置环境变量 第三部分 IDE配置 第四部分 HelloWorld案例 参考文献及资料 背景第一部分 包和模块首先要介绍Python中两个概念：包和模块。简单的理解（从文件系统角度），包（package）是一个文件夹，而模块（module）是一个python源码文件（扩展名为.py）。 包（package）：文件夹（文件夹中含有文件__init__.py），包里面含有很多模块组成。 __init__.py文件，在里面自定义初始化操作，或为空。 模块（module）：即python文件，文件中定义了函数、变量、常量、类等。 第二部分 Import 方法Import 模块方法先看一个例子。我们经常使用的模块math ，背后对应其实是一个python文件：math.py 。该文件在C:\Anaconda3\Lib\site-packages\pymc3目录里面（具体环境会有差异）。 123import mathmath.sqrt(2)#1.4142135623730951 如果只要import math.py中具体的函数： 123from math import sqrt，sinsqrt(2)sin（1） 另外可以将模块中所有内容导入： 12from math import *sqrt(2) Import 包方法包（package）可以简单理解为文件夹。该文件夹下须存在 __init__.py 文件, 内容可以为空。另外该主文件夹下面可以有子文件夹，如果也有 __init__.py 文件，这是子包。类似依次嵌套。 例如Tensorflow的包（文件树）： 123456789101112root@vultr:~/anaconda3/lib/python3.6/site-packages/tensorflow# tree -L 1.├── aux-bin├── contrib├── core├── examples├── include├── __init__.py├── libtensorflow_framework.so├── __pycache__├── python└── tools __init__.py 文件在import包时，优先导入，作为import包的初始化。 我们以Tensorflow为例： 12345678#导入包import tensorflow as tf#导入子包：contribimport tensorflow.contrib as contribfrom tensorflow import contrib#导入具体的模块：mnistfrom tensorflow.examples.tutorials import mnistimport tensorflow.examples.tutorials.mnist 第三部分 命名空间（namespace）Namespace是字典数据，供编译器、解释器对源代码中函数名、变量名、模块名等信息进行关联检索。 定义Python语言使用namespace（命名空间）来存储变量，namespace是一个mapping（映射）。namespace可以理解是一个字典（dict）数据类型，其中键名（key）为变量名，而键值（value）为变量的值。 A namespace is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries。 每一个函数拥有自己的namespace。称为local namespace（局部命名空间），记录函数的变量。 每一个模块（module）拥有自己的namespace。称为global namespace（全局命名空间），记录模块的变量，包括包括模块中的函数、类，其他import（导入）的模块，还有模块级别的变量和常量。 每一个包（package）拥有自己的namespace。 也是global namespace ，记录包中所有子包、模块的变量信息。 Python的built-in names（内置函数、内置常量、内置类型）。 即内置命名空间。在Python解释器启动时创建，任何模块都可以访问。当退出解释器后删除。 命名空间的检索顺序当代码中需要访问或获取变量时（还有模块名、函数名），Python解释器会对命名空间进行顺序检索，直到根据键名（变量名）找到键值（变量值）。查找的顺序为（LEGB）： local namespace，即当前函数或者当前类。如找到，停止检索。 enclosing function namespace，嵌套函数中外部函数的namespace。 global namespace，即当前模块。如找到，停止检索。 build-in namespace，即内置命名空间。如果前面两次检索均为找到，解释器才会最后检索内置命名空间。如果仍然未找到就会报NameRrror（类似：NameError: name &#39;a&#39; is not defined）。 举栗子讲完了理论介绍，我们来举栗子，直观感受一下。 12345678910111213#进入python环境Python 3.5.3 |Anaconda custom (64-bit)| (default, May 11 2017, 13:52:01) [MSC v.1900 64 bit (AMD64)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; print(globals())&#123;'__name__': '__main__', '__doc__': None, '__spec__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__builtins__': &lt;module 'builtins' (built-in)&gt;&#125;&gt;&gt;&gt; x=1&gt;&gt;&gt; print(globals())&#123;'__name__': '__main__', '__doc__': None, '__spec__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'x': 1&#125; 上面的例子我们查看了global namespace的字典（dict），其中&#39;__builtins__&#39;就是内置命名空间。新建变量x=1后，全局命名空间会新增这个K-V对。 还可以通过下面的方法查看import模块、包的namespace。 当我们import一个module（模块）或者package（包）时，伴随着新建一个global namespace（全局命名空间）。 1234567891011import mathmath.__dict__&#123;'__name__': 'math', 'tanh': &lt;built-in function tanh&gt;, 'nan': nan, 'atanh': &lt;built-in function atanh&gt;,'acosh': &lt;built-in function acosh&gt;, #中间略'trunc': &lt;built-in function trunc&gt;, 'acos': &lt;built-in function acos&gt;, 'sqrt': &lt;built-in function sqrt&gt;, 'floor': &lt;built-in function floor&gt;, 'gamma': &lt;built-in function gamma&gt;, 'cosh': &lt;built-in function cosh&gt;&#125;import tensorflowtensorflow.__dict__#包的所有模块、函数等命名空间信息。大家可以试一下。 大家可以动手试试其他的场景，比如函数内部查看locals() 。函数内部的变量global声明后，查看globals()字典会有怎样变化。这里就不再一一验证举栗了。 对于包，我们以tensorflow为例： 123456import tensorflowtensorflow.__dict__##中间略，只摘取部分信息。命名空间中包含module和function的信息。'angle': &lt;function tensorflow.python.ops.math_ops.angle&gt;, 'app': &lt;module 'tensorflow.python.platform.app' from '/root/anaconda3/lib/python3.6/site-packages/tensorflow/python/platform/app.py'&gt;, 'arg_max': &lt;function tensorflow.python.ops.gen_math_ops.arg_max&gt;, 第四部分 Import的过程当我们执行import 模块、包时，主要有三个过程：检索、加载、名字绑定。 第一步：检索（Finder）Python解释器会对模块所属位置进行搜索： （1）检索：内置模块（已经加载到缓存中的模块）内置模块（已经加载到缓存中的模块），即在 sys.modules 中检索。Python已经加载到内存中的模块均会在这个字典中进行登记。如果已经登记，不再重复加载。直接将模块的名字加入正在import的模块的namespace。可以通过下面方法查看： 123456789&gt;&gt;&gt; import sys&gt;&gt;&gt; print(sys.modules)&#123;'_signal': &lt;module '_signal' (built-in)&gt;, 'os.path': &lt;module 'ntpath' from 'C:\Anaconda3\\lib\\ntpath.py'&gt;,pickle': &lt;module 'pickle' from 'C:\\Anaconda3\\lib\\pickle.py'&gt;, #中间略'subprocess':module 'subprocess' from 'C:\\Anaconda3\\lib\\subprocess.py'&gt;, 'sys': &lt;module 'ys' (built-in)&gt;, 'ctypes.util': &lt;module 'ctypes.util' from 'C:\\Anaconda3\\lib\ctypes\\util.py'&gt;, '_weakref': &lt;module '_weakref' (built-in)&gt;, '_imp': &lt;module_imp' (built-in)&gt;&#125; 如果不是built-in，value中会有模块的绝对路径信息。 通过key查找模块位置，如果value为None，就会抛出错误信息：ModuleNotFoundError。 如果key不存在，就会进入下一步检索。 如果我们导入过包，例如tensorflow。 注意如果要使用其中模块，需要该模块的全名（即全路径信息），例如：tensorflow.examples.tutorials.mnist.input_data 。因为sys.modules中只有全路径的key。 1234import tensorflowprint(sys.modules)##这个字典中会有tensorflow所有子包、模块的信息和具体的路径。#'tensorflow.examples.tutorials.mnist.input_data': &lt;module 'tensorflow.examples.tutorials.mnist.input_data' from '/root/anaconda3/lib/python3.6/site-packages/tensorflow/examples/tutorials/mnist/input_data.py'&gt; （2）检索 sys.meta_path逐个遍历其中的 finder 来查找模块。否则进入下一步检索。 （3）检索模块所属包目录如果模块Module在包（Package）中（如import Package.Module），则以Package.__path__为搜索路径进行查找。 （4）检索环境变量如果模块不在一个包中（如import Module），则以 sys.path 为搜索路径进行查找。 如果上面检索均为找到，抛出错误信息：ModuleNotFoundError。 第二步：加载（Loader）加载完成对模块的初始化处理： 设置属性。包括__name__、__file__、__package__和__loader__ 。 编译源码。编译生成字节码文件（.pyc文件），如果是包，则是其对应的__init__.py文件编译为字节码（*.pyc）。如果字节码文件已存在且仍然是最新的（时间戳和py文件一致），则不会重新编译。 加载到内存。模块在第一次被加载时被编译，载入内存，并将信息加入到sys.modules中。 也可以强制用reload()函数重新加载模块（包）。 第三步：名字绑定将模块和包的命名空间信息导入到当前执行Python文件的namespace（命名空间）。 第五部分 将模块、包的路径加入检索路径讲完了枯燥的理论背景，下面我们来介绍实际应用。当你写好一个模块文件，如何正确完成import模块？主要有下面两类方法： 动态方法（sys.path中添加）我们知道检索路径中sys.path，所以可以在import模块之前将模块的绝对路径添加到sys.path中。同样导入包需要加入包的文件夹绝对路径。具体方法如下： 12345import sys##sys.path.append(dir)sys.path.append('your\module（package）\file\path')##sys.path.insert(pos,dir)sys.path.insert(0,'your\module（package）\file\path') 注意： 1、这里pos参数是插入sys.path这个list数据的位置，pos=0，即list第一位，优先级高。 2、python程序向sys.path添加的目录只在此程序的生命周期之内有效。程序结束，失效。所以这是一种动态方法。 123456789#win7import sysprint(sys.path)#输出['', 'C:\\Python27\\lib\\site-packages\\pip-8.1.1-py2.7.egg', 'C:\\windows\\system32\\python27.zip', 'C:\\Python27\\DLLs', 'C:\\Python27\\lib', 'C:\\Python27\\lib\\plat-win', 'C:\\Python27\\lib\\lib-tk', 'C:\\Python27', 'C:\\Users\\rongxiang\\AppData\\Roaming\\Python\\Python27\\site-packages', 'C:\\Python27\\lib\\site-packages'] 静态方法（1）另外检索路径还有系统环境变量，所以可以将模块（包）路径添加在系统环境变量中。 （2）粗暴一点直接将模块（包）拷贝到sys.path的其中一个路径下面。但是这种管理比较乱。 （3）Python在遍历sys.path的目录过程中，会解析 .pth 文件，将文件中所记录的路径加入到 sys.path ，这样 .pth 文件中的路径也可以找到了。例如我们在C:\Python27\lib\site-packages 中新建一个.pth文件。例如： 12# .pth file for the your module or package'your\module（package）\file\path' 这样在模块（包）上线时，我们只需要将模块（包）的目录或者文件绝对路径放在新建的.path文件中即可。 参考文章【1】http://www.cnblogs.com/russellluo/p/3328683.html#_3]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据科学实践中常用开放数据集介绍]]></title>
    <url>%2F2018%2F04%2F05%2F2018-04-01-%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%BC%80%E6%94%BE%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 开放数据集 参考文献及资料 背景数据科学研究的对象是数据，学习过程中需要相关数据集辅助大家练习、做实验。从而体会数据科学中算法方法论。中国古语云：巧妇难有无米之炊，说的就是数据对于数据科学学习的重要性。 这篇文章收集介绍了各种常用的开放数据集，供大家学习参考。会持续更新。 第二部分 开放数据集这里主要将开放数据分为三类：图像类、自然语言（NLP）类、音频类。 1.1 图像类MNIST手写数据集 介绍： MNIST（全称：Modified National Institute of Standards and Technology database）数据集是常见的深度学习开放数据集（基本属于深度学习的hello world数据集）。这是一个手写阿拉伯数据集（0-9数字），数据主要采集于美国高中学生。数据集总量为7W个手写数字图像（训练集6w个、测试机1w个）。 文件 内容 train-images-idx3-ubyte.gz 训练集图片 - 60000张训练图片 train-labels-idx1-ubyte.gz 训练集图片对应的数字标签（0-9） t10k-images-idx3-ubyte.gz 测试集图片 - 10000 张 图片 t10k-labels-idx1-ubyte.gz 测试集图片对应的数字标签 数据存储大小：二进制文件，50M，压缩形式约10M。每张图像被归一化成28*28的像素矩阵。 图像数据格式：像素值为0到255. 0表示背景（白色），255表示前景（黑色）。例如下面手写数字1的数据矩阵表示： 官方网页连接：http://yann.lecun.com/exdb/mnist/ 读取数据案例（Python）： Tensorflow中已经有对MNIST数据集解析的脚本，我们可以直接调用： 文件 目的 input_data.py、mnist.py 用于读取MNIST数据集 12345678910111213141516import tensorflow as tf#tf为1.7版本import numpy as npfrom tensorflow.examples.tutorials.mnist import input_datadata_dir = '/root/tftest/mnistdata/'#data_dir为数据集文件存放目录mnist = input_data.read_data_sets(data_dir, one_hot=True，validation_size=5000)#mnist = input_data.read_data_sets(data_dir, one_hot=False)#one_hot参数True，表示标签进行one-hot编码处理。#validation_size参数可以从训练集中划出一部分数据作为验证集。默认是5w个，可以自己调节。x_train,y_train,x_test,y_test,x_vali,y_vali = \mnist.train.images,mnist.train.labels,mnist.test.images,mnist.test.labels,\mnist.validation.images,mnist.validation.labels#x_train的数据类型为：&lt;class 'numpy.ndarray'&gt; ​ 上面的例子划分好数据就可以喂给各种算法模型进行训练。 扩展：EMNIST数据集：https://arxiv.org/abs/1702.05373。 按照MNIST规范，数据集更大：包含240,000个训练图像和40,000个手写数字测试图像。 MS-COCO图像分割数据集 介绍： MS-COCO（全称是Common Objects in Context）是微软团队提供的一个可以用来进行图像识别的数据集。数据集中的图像分为训练、验证和测试集。COCO数据集现在有3种标注类型：object instances（目标实例）, object keypoints（目标上的关键点）, 和image captions（看图说话），使用JSON文件存储。 一共有33w张图像，80个对象类别，每幅图5个字母、25w个关键点。 数据存储大小：约25G（压缩形式） 数据格式：中文介绍可以参考知乎这篇文章：COCO数据集的标注格式 。 官方网站：http://mscoco.org/ ImageNet图像数据集 介绍： Imagenet是深度学习中大名鼎鼎的数据集。数据集有1400多万幅图片，涵盖2万多个类别；其中有超过百万的图片有明确的类别标注和图像中物体位置的标注。深度学习中关于图像分类、定位、检测等研究工作大多基于此数据集展开。Imagenet数据集文档详细，有专门的团队维护，使用非常方便，在计算机视觉领域研究论文中应用非常广，几乎成为了目前深度学习图像领域算法性能检验的“标准”数据集。 数据存储大小：约150G 官方网站：http://www.image-net.org/ Open Image图像数据集 介绍： Open Image为Google提供。数据集包含近900万个图像URL。这些图像已经用数千个类的图像级标签边框进行了注释。该数据集包含9,011,219张图像的训练集，41,260张图像的验证集以及125,436张图像的测试集。 数据大小：500G 官方网站：https://github.com/openimages/dataset VisualQA图像数据库 介绍： VQA是一个包含有关图像的开放式问题的数据集。这些问题需要理解视野和语言。数据集有265,016张图片。 数据大小：25G 官方网站：http://www.visualqa.org/ The Street View House Numbers (SVHN) Dataset街边号码牌数据集 介绍： SVHN图像数据集用于开发机器学习和对象识别算法，对数据预处理和格式化的要求最低。它可以被看作与MNIST相似，但是将更多标记数据（超过600,000个数字图像）并入一个数量级并且来自显着更难以解决的真实世界问题（识别自然场景图像中的数字和数字）。SVHN数据从谷歌街景图片中的房屋号码中获得的。书记含有用于训练的73257个数字，用于测试的26032个数字以及用作额外训练数据的531131个附加数字。 数据集大小： [train.tar.gz]， [test.tar.gz]， [extra.tar.gz ] 共三个文件。 官方网站：http://ufldl.stanford.edu/housenumbers/ CIFAR-10图像数据集 介绍： CIFAR-10数据集由10个类的60,000个图像组成（每个类在上图中表示为一行）。总共有50,000个训练图像和10,000个测试图像。数据集分为6个部分 - 5个培训批次和1个测试批次。每批有10,000个图像。 数据大小：170M 官方网站：http://www.cs.toronto.edu/~kriz/cifar.html Fashion-MNIST 介绍 Fashion-MNIST包含60,000个训练图像和10,000个测试图像。它是一个类似MNIST的时尚产品数据库。开发人员认为MNIST已被过度使用，因此他们将其作为该数据集的直接替代品。每张图片都以灰度显示，并与10个类别的标签相关联。 数据集大小：30M 官方网站：https://github.com/zalandoresearch/fashion-mnist 1.2 自然语言类数据库IMDB电影评论数据集 介绍： 这是电影爱好者的梦幻数据集。它具有比此领域以前的任何数据集更多的数据。除了训练和测试评估示例之外，还有更多未标记的数据供您使用。原始文本和预处理的单词格式包也包括在内。 数据集大小：80 M 官方网站：http://ai.stanford.edu/~amaas/data/sentiment/ 模型案例：https://arxiv.org/abs/1705.09207 Twenty Newsgroups Data Set 介绍： 该数据集包含有关新闻组的信息。为了管理这个数据集，从20个不同的新闻组中获取了1000篇Usenet文章。这些文章具有典型特征，如主题行，签名和引号。 数据集大小：20 M 官方网站：https://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups 模型案例：https://arxiv.org/abs/1606.01781 Sentiment140情感分析数据集 介绍： Sentiment140是一个可用于情感分析的数据集。 数据集大小：80 M 官方网站：http://help.sentiment140.com/for-students/ 模型案例：http://www.aclweb.org/anthology/W17-5202 WordNet 介绍： WordNet是英语synsets的大型数据库。Synsets是同义词组，每个描述不同的概念。WordNet的结构使其成为NLP非常有用的工具。 数据集大小：10 M 官方网站：https://wordnet.princeton.edu/ 模型案例：https://aclanthology.info/pdf/R/R11/R11-1097.pdf Yelp评论 介绍： 这是Yelp为了学习目的而发布的一个开放数据集。它由数百万用户评论，商业属性和来自多个大都市地区的超过20万张照片组成。这是一个非常常用的全球NLP挑战数据集。 数据集大小：2.66 GB JSON，2.9 GB SQL和7.5 GB照片（全部压缩） 官方网站：https://www.yelp.com/dataset 模型案例：https://arxiv.org/pdf/1710.00519.pdf 维基百科语料库 介绍： 该数据集是维基百科全文的集合。它包含来自400多万篇文章的将近19亿字。什么使得这个强大的NLP数据集是你可以通过单词，短语或段落本身的一部分进行搜索。 数据集大小： 20 MB 官方网站：https://corpus.byu.edu/wiki/ 模型案例：https://arxiv.org/pdf/1711.03953.pdf 博客作者身份语料库 介绍： 此数据集包含从数千名博主收集的博客帖子，从blogger.com收集。每个博客都作为一个单独的文件提供。每个博客至少包含200次常用英语单词。 数据集大小： 300 MB 官方网站：http://u.cs.biu.ac.il/~koppel/BlogCorpus.htm 模型案例：https://arxiv.org/pdf/1609.06686.pdf 欧洲语言的机器翻译 介绍： 数据集包含四种欧洲语言。 数据集大小： 约15 G 官方网站：http://statmt.org/wmt11/translation-task.html 模型案例：https://arxiv.org/abs/1706.03762 1.3 音频/语音数据集口语数字数据集 介绍： 为了解决识别音频样本中的口头数字的任务而创建。这是一个开放的数据集，所以希望随着人们继续贡献更多样本，它会不断增长。 数据集大小： 约10 G=M 记录数量：1500个音频样本 官方网站：https://github.com/Jakobovski/free-spoken-digit-dataset 模型案例：https://arxiv.org/pdf/1712.00866 免费音乐档案（FMA） 介绍： FMA是音乐分析的数据集。数据集由全长和HQ音频，预先计算的特征以及音轨和用户级元数据组成。它是一个开放数据集，用于评估MIR中的几个任务。以下是数据集连同其包含的csv文件列表： tracks.csv：所有106,574首曲目的每首曲目元数据，如ID，标题，艺术家，流派，标签和播放次数。 genres.csv：所有163种风格的ID与他们的名字和父母（用于推断流派层次和顶级流派）。 features.csv：用librosa提取的共同特征 。 echonest.csv：由Echonest （现在的 Spotify）为13,129首音轨的子集提供的音频功能 。 数据集大小： 约1T 记录数量：1500个音频样本 官方网站：https://github.com/mdeff/fma 模型案例：https://arxiv.org/pdf/1803.05337.pdf 舞厅 介绍： 该数据集包含舞厅跳舞音频文件。以真实音频格式提供了许多舞蹈风格的一些特征摘录。 以下是数据集的一些特征： 数据集大小： 约14 G 记录数量：约700个音频样本 官方网站：http://mtg.upf.edu/ismir2004/contest/tempoContest/node5.html 模型案例：https://pdfs.semanticscholar.org/0cc2/952bf70c84e0199fcf8e58a8680a7903521e.pdf 百万歌曲数据集 介绍： 百万歌曲数据集是音频功能和元数据的一百万当代流行音乐曲目可自由可用的集合。 其目的是： 鼓励对扩大到商业规模的算法进行研究 为评估研究提供参考数据集 作为使用API创建大型数据集的捷径（例如Echo Nest的） 帮助新研究人员在MIR领域开始工作 数据集的核心是一百万首歌曲的特征分析和元数据。该数据集不包含任何音频，只包含派生的功能。示例音频可以通过使用哥伦比亚大学提供的代码从7digital等服务中获取。 数据集大小： 约280 G 记录数量：它的一百万首歌曲！ 官方网站：https://labrosa.ee.columbia.edu/millionsong/ 模型案例：http://www.ke.tu-darmstadt.de/events/PL-12/papers/08-aiolli.pdf LibriSpeech 介绍： 该数据集是大约1000小时的英语语音的大型语料库。这些数据来自LibriVox项目的有声读物。它已被分割并正确对齐。如果您正在寻找一个起点，请查看已准备好的声学模型，这些模型在kaldi-asr.org和语言模型上进行了训练，适合评估，网址为http://www.openslr.org/11/。 数据集大小： 约60 G 记录数量：1000小时的演讲 官方网站：http://www.openslr.org/12/ 模型案例：https://arxiv.org/abs/1712.09444 VoxCeleb 介绍： VoxCeleb是一个大型的说话人识别数据集。它包含约1,200名来自YouTube视频的约10万个话语。数据大部分是性别平衡的（男性占55％）。名人跨越不同的口音，职业和年龄。开发和测试集之间没有重叠。对于隔离和识别哪个超级巨星来说，这是一个有趣的用例。 数据集大小： 约150 M 记录数量： 1,251位名人的100,000条话语 官方网站：http://www.robots.ox.ac.uk/~vgg/data/voxceleb/ 模型案例：https://www.robots.ox.ac.uk/~vgg/publications/2017/Nagrani17/nagrani17.pdf 1.4 比赛数据Twitter情绪分析数据 介绍： 仇恨以种族主义和性别歧视为形式的言论已成为叽叽喳喳的麻烦，重要的是将这类推文与其他人分开。在这个实践问题中，我们提供既有正常又有仇恨推文的Twitter数据。您作为数据科学家的任务是确定推文是仇恨推文，哪些不是。 数据集大小： 约3 M 记录数量： 31,962条推文 官方网站：https://datahack.analyticsvidhya.com/contest/practice-problem-twitter-sentiment-analysis/ 印度演员的年龄检测 介绍： 对于任何深度学习爱好者来说，这是一个令人着迷的挑战。该数据集包含数千个印度演员的图像，你的任务是确定他们的年龄。所有图像都是手动选择的，并从视频帧中剪切，导致尺度，姿势，表情，照度，年龄，分辨率，遮挡和化妆的高度可变性。 数据集大小： 约48 M 记录数量： 训练集中的19,906幅图像和测试集中的6636幅图像 官方网站：https://datahack.analyticsvidhya.com/contest/practice-problem-age-detection/ 城市声音分类 介绍： 这个数据集包含超过8000个来自10个班级的城市声音摘录。这个实践问题旨在向您介绍常见分类方案中的音频处理。 数据集大小： 训练集 - 3 GB（压缩），测试集 - 2 GB（压缩） 记录数量： 来自10个班级的8732个城市声音标注的声音片段（&lt;= 4s） 官方网站：https://datahack.analyticsvidhya.com/contest/practice-problem-urban-sound-classification/ 参考文献及资料【1】 https://www.tensorflow.org/versions/r1.1/get_started/mnist/beginners 【2】 https://www.analyticsvidhya.com/blog/2018/03/comprehensive-collection-deep-learning-datasets/ 【3】 https://deeplearning4j.org/cn/opendata]]></content>
      <categories>
        <category>Bigdata</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu挂载新的硬盘（2T以上）]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-Ubuntu%E6%8C%82%E8%BD%BD%E6%96%B0%E7%9A%84%E7%A1%AC%E7%9B%98%EF%BC%882T%E4%BB%A5%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 查看硬盘信息 第二部分 新挂载硬盘分区 第三部分 使用parted分区 第四部分 格式化新建分区 第五部分 挂载分区 第六部分 配置开机自动挂载分区 第七部分 附录 参考文献及资料 背景系统环境： Linux version 4.13.0-37-generic (Ubuntu 5.4.0-6ubuntu1~16.04.9)。root用户登入操作。 第一部分 查看硬盘信息机器断电时，接入硬盘。开机后用下面的命令查看硬盘状况（非root用户需sudo）。 123456789101112131415161718root@deeplearning:~# fdisk -lDisk /dev/sda: 465.8 GiB, 500107862016 bytes, 976773168 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: gptDisk identifier: CC8004FC-D422-48FA-8ACF-54C3F48E860BDevice Start End Sectors Size Type/dev/sda1 2048 1050623 1048576 512M EFI System/dev/sda2 1050624 909946879 908896256 433.4G Linux filesystem/dev/sda3 909946880 976771071 66824192 31.9G Linux swapDisk /dev/sdb: 3.7 TiB, 4000787030016 bytes, 7814037168 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytes 查看到系统由两块硬盘：/dev/sda和/dev/sdb，如果还有其他硬盘会继续sdc、sdd编号。 正在使用的系统盘sda已经有三个分区（sda1、sda2、sda3），新挂载的硬盘sdb位分区。 第二部分 新挂载硬盘分区新硬盘存储空间一共4T，我们对硬盘进行分区。划分为两个分区： 1234567891011121314root@deeplearning:~# fdisk /dev/sdbWelcome to fdisk (util-linux 2.27.1).Changes will remain in memory only, until you decide to write them.Be careful before using the write command./dev/sdb: device contains a valid 'ext4' signature; it is strongly recommended to wipe the device with wipefs(8) if this is sible collisionsDevice does not contain a recognized partition table.The size of this disk is 3.7 TiB (4000787030016 bytes). DOS partition table format can not be used on drives for volumes lar512-byte sectors. Use GUID partition table format (GPT).Created a new DOS disklabel with disk identifier 0x6b028a17.Command (m for help): 注意这里已经有警告：The size of this disk is 3.7 TiB (4000787030016 bytes). DOS partition table format can not be used on drives for volumes lar512-byte sectors. Use GUID partition table format (GPT) 这里情况特殊，新加入的磁盘为4T。fdisk命令对于大于2T的分区无法划分。如果继续使用fdisk工具，最多只能分出2T的分区，剩下的空间无法利用。这不坑爹嘛。提示我们使用parted命令。 第三部分 使用parted分区parted命令可以划分单个分区大于2T的GPT格式的分区。 更改分区表类型： 1root@deeplearning:~# parted -s /dev/sdb mklabel gpt 使用parted进行分区： 123456789101112131415161718192021222324252627282930313233root@deeplearning:~# parted /dev/sdbGNU Parted 3.2Using /dev/sdbWelcome to GNU Parted! Type 'help' to view a list of commands.(parted) print Model: ATA WDC WD40EFRX-68N (scsi)Disk /dev/sdb: 4001GBSector size (logical/physical): 512B/4096BPartition Table: gptDisk Flags: Number Start End Size File system Name Flags(parted) mklabel gpt Warning: The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost. Do you want to continue?Yes/No? yes (parted) mkpart Partition name? []? File system type? [ext2]? ext4 Start? 0% End? 100% (parted) print Model: ATA WDC WD40EFRX-68N (scsi)Disk /dev/sdb: 4001GBSector size (logical/physical): 512B/4096BPartition Table: gptDisk Flags: Number Start End Size File system Name Flags 1 1049kB 4001GB 4001GB ext4(parted) quit Information: You may need to update /etc/fstab. 最后我们验证一下，sdb1分区成功，提示我们要更新系统文件：/etc/fstab。 12345678910111213141516171819202122232425root@deeplearning:~# ls /dev/sd* /dev/sda /dev/sda1 /dev/sda2 /dev/sda3 /dev/sdb /dev/sdb1root@deeplearning:~# fdisk -lDisk /dev/sda: 465.8 GiB, 500107862016 bytes, 976773168 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: gptDisk identifier: CC8004FC-D422-48FA-8ACF-54C3F48E860BDevice Start End Sectors Size Type/dev/sda1 2048 1050623 1048576 512M EFI System/dev/sda2 1050624 909946879 908896256 433.4G Linux filesystem/dev/sda3 909946880 976771071 66824192 31.9G Linux swapDisk /dev/sdb: 3.7 TiB, 4000787030016 bytes, 7814037168 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisklabel type: gptDisk identifier: 0D8B0FBC-83F6-4D77-ABDB-98875EC511E4Device Start End Sectors Size Type/dev/sdb1 2048 7814035455 7814033408 3.7T Linux filesystem 第四部分 格式化新建分区将分区格式化为ext4格式的文件系统。 1234567891011121314root@deeplearning:~# mkfs.ext4 /dev/sdb1mke2fs 1.42.13 (17-May-2015)Creating filesystem with 976754176 4k blocks and 244195328 inodesFilesystem UUID: dfcd419f-38a5-4a5c-9b93-9f236d2c2444Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968, 102400000, 214990848, 512000000, 550731776, 644972544Allocating group tables: done Writing inode tables: done Creating journal (32768 blocks): doneWriting superblocks and filesystem accounting information: done 如果有多个分区需要依次执行格式化。 第五部分 挂载分区新建硬盘即将挂载的目录，然后将硬盘挂载到该目录下。并验证挂载成功，检查硬盘空间。 12345678910111213root@deeplearning:/# mkdir /dataroot@deeplearning:/# mount /dev/sdb1 /dataroot@deeplearning:/# df -hFilesystem Size Used Avail Use% Mounted onudev 16G 0 16G 0% /devtmpfs 3.2G 9.3M 3.2G 1% /run/dev/sda2 427G 21G 385G 5% /tmpfs 16G 0 16G 0% /dev/shmtmpfs 5.0M 4.0K 5.0M 1% /run/locktmpfs 16G 0 16G 0% /sys/fs/cgroup/dev/sda1 511M 3.5M 508M 1% /boot/efitmpfs 3.2G 12K 3.2G 1% /run/user/1000/dev/sdb1 3.6T 68M 3.4T 1% /data 上面我们把新的硬盘挂载到了/data目录，硬盘空间大小正常。 第六部分 配置开机自动挂载分区6.1 查看分区的UUID123root@deeplearning:/# blkid#（略）.../dev/sdb1: UUID="dfcd419f-38a5-4a5c-9b93-9f236d2c2444" TYPE="ext4" PARTUUID="fe373bd5-5b19-4ed0-8713-716455a8ebb4" 6.2 配置/etc/fstab将分区信息写到/etc/fstab文件中让它永久挂载: 将下面的配置信息加入配置文件尾部： 1UUID=dfcd419f-38a5-4a5c-9b93-9f236d2c2444 /data ext4 defaults 0 1 第七部分 附录7.1 /etc/fstab配置说明12345678910111213# Use 'blkid' to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).&lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt; 1 2 3 4 5 6对应参数说明：1、指代文件系统的设备名。最初，该字段只包含待挂载分区的设备名（如/dev/sda1）。现在，除设备名外，还可以包含LABEL或UUID2、文件系统挂载点。文件系统包含挂载点下整个目录树结构里的所有数据，除非其中某个目录又挂载了另一个文件系统3、文件系统类型。下面是多数常见文件系统类型（ext3,tmpfs,devpts,sysfs,proc,swap,vfat）4、mount命令选项。mount选项包括noauto（启动时不挂载该文件系统）和ro（只读方式挂载文件系统）等。在该字段里添加用户或属主选项，即可允许该用户挂载文件系统。多个选项之间必须用逗号隔开。其他选项的相关信息可参看mount命令手册页（-o选项处）5、转储文件系统？该字段只在用dump备份时才有意义。数字1表示该文件系统需要转储，0表示不需要转储6、文件系统检查？该字段里的数字表示文件系统是否需要用fsck检查。0表示不必检查该文件系统，数字1示意该文件系统需要先行检查（用于根文件系统）。数字2则表示完成根文件系统检查后，再检查该文件系统。 7.2 Parted命令说明（本文使用交互模式完成配置）Parted 命令分为两种模式：命令行模式和交互模式。 命令行模式： parted [option] device [command] ,该模式可以直接在命令行下对磁盘进行分区操作，比较适合编程应用。 交互模式：parted [option] device 类似于使用fdisk /dev/xxx MBR：MBR分区表(即主引导记录)大家都很熟悉。所支持的最大卷：2T，而且对分区有限制：最多4个主分区或3个主分区加一个扩展分区 GPT： GPT（即GUID分区表）。是源自EFI标准的一种较新的磁盘分区表结构的标准，是未来磁盘分区的主要形式。与MBR分区方式相比，具有如下优点。突破MBR 4个主分区限制，每个磁盘最多支持128个分区。支持大于2T的分区，最大卷可达18EB。 parted是一个可以分区并进行分区调整的工具，他可以创建，破坏，移动，复制，调整ext2 linux-swap fat fat32 reiserfs类型的分区，可以创建，调整，移动Macintosh的HFS分区，检测jfs，ntfs，ufs，xfs分区。 使用方法：parted [options] [device [command [options...]...]] 12345678910111213141516171819202122232425262728options-h 显示帮助信息-l 显示所有块设备上的分区device 对哪个块设备进行操作，如果没有指定则使用第一个块设备command [options...]check partition 对分区做一个简单的检测cp [source-device] source dest 复制source-device设备上的source分区到当前设备的dest分区mklabel label-type 创建新分区表类型，label-type可以是："bsd", "dvh", "gpt", "loop","mac", "msdos", "pc98", or "sun" 一般的pc机都是msdos格式，如果分区大于2T则需要选用gpt格式的分区表。mkfs partition fs-type 在partition分区上创建一个fs-type文件系统，fs-type可以是："fat16", "fat32", "ext2", "linux-swap","reiserfs" 注意不支持ext3格式的文件系统，只能先分区然后用专有命令进行格式化。mkpart part-type [fs-type] start end 创建一个part-type类型的分区，part-type可以是："primary", "logical", or "extended" 如果指定fs-type则在创建分区的同时进行格式化。start和end指的是分区的起始位置，单位默认是M。eg：mkpart primary 0 -1 0表示分区的开始 -1表示分区的结尾 意思是划分整个硬盘空间为主分区mkpartfs part-type fs-type start end 创建一个fs-type类型的part-type分区，不推荐使用，最好是使用mkpart分区完成后使用mke2fs进行格式化。name partition name 给分区设置一个名字，这种设置只能用在Mac, PC98, and GPT类型的分区表，设置时名字用引号括起来select device 在机器上有多个硬盘时，选择操作那个硬盘resize partition start end 调整分区大小rm partition 删除一个分区rescue start end 拯救一个位于stat和end之间的分区unit unit 在前面分区时，默认分区时数值的单位是M，这个参数卡伊改变默认单位，"kB", "MB", "GB", "TB"move partition start end 移动partition分区print 显示分区表信息 quit 退出parted 参考文献【1】 Setting up a large (2TB+) hard disk drive on Linux]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo:解决Typora编辑table无法被解析问题]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-05-Hexo%E8%A7%A3%E5%86%B3Typora%E7%BC%96%E8%BE%91table%E6%97%A0%E6%B3%95%E8%A2%AB%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 掉坑背景 第二部分 爬坑过程和解决办法 第三部分 提示 参考文献及资料 第一部分 掉坑背景使用Typora编辑Makedown文件，添加表格，但是提交给Hexo渲染网页，无法正常解析显示，而是显示源码。例如：| Table Header 1 | Table Header 2 || ————– | ————– || Division 1 | Division 2 || Division 1 | Division 2 | 第二部分 爬坑过程和解决办法一开始认为是Hexo的bug，Google也没人遇到类似情况，都准备在github上建问题单了。最后本着严谨的态度，以文本的格式打开文档，发现表格源码和正文之间没有空行！！！！！ 这尼玛坑爹呀，所以Hexo无法解析，但是Typora能正常解析。空出一行后正常解析： 123456&lt;正文&gt;(空一行)| Table Header 1 | Table Header 2 || - | - | | Division 1 | Division 2 | | Division 1 | Division 2 | Table Header 1 Table Header 2 Division 1 Division 2 Division 1 Division 2 这一点Typora做的不够兼容（只怪他太过于强大的解析能力。。。。）。Tyopra不服了，我强大也有错？？哈哈哈 记录该坑供掉坑小伙伴参考。 第三部分 提示如果掉坑小伙伴，上面办法没解决。用文本方式打开文件，逐个排查原因。 参考文献及资料暂无]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jupyter notebook:主题和字体的美化]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-26-JupyterNotebook%E4%B8%BB%E9%A2%98%E5%92%8C%E5%AD%97%E4%BD%93%E7%9A%84%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 安装 第二部分 命令格式 第三部分 案例 参考文献及资料 背景Jupyter notebook是数据科学常用的代码交互式工具。通常在server端启jupyter进程（web服务），client端打开浏览器，jupyter提供代码编写和调试交互环境。非常方便。 但是jupyter提供的默认界面不够美观，特别是windows操作系统默认字体为浏览器默认字体–宋体（下图），另外默认主题太难看了，没有通常IDE提供的主题美观。 发现一个Jupyter的美化工具：jupyterthemes ，和大家分享一下。简单介绍一下安装和配置。细节介绍参考项目的介绍文档。 第一部分 安装使用pip安装： 1root@vultr:~# pip install jupyterthemes 或者使用Anaconda的conda安装： 1root@vultr:~# conda install -c conda-forge jupyterthemes 第二部分 命令格式使用jt -h显示命令帮助说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354root@vultr:~# jt -husage: jt [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT] [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-dfs DFFONTSIZE] [-ofs OUTFONTSIZE] [-mathfs MATHFONTSIZE] [-m MARGINS] [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-cellw CELLWIDTH] [-lineh LINEHEIGHT] [-altp] [-altmd] [-altout] [-P] [-T] [-N] [-vim] [-r] [-dfonts]optional arguments: -h, --help show this help message and exit #-h，--help显示此帮助信息并退出 -l, --list list available themes #-l， 列出可用主题 -t THEME, --theme THEME theme name to install（配置需要安装的主题） -f MONOFONT, --monofont MONOFONT monospace code font（代码的字体） -fs MONOSIZE, --monosize MONOSIZE code font-size（代码字体大小） -nf NBFONT, --nbfont NBFONT notebook font（notebook 字体） -nfs NBFONTSIZE, --nbfontsize NBFONTSIZE notebook fontsize（notebook 字体大小） -tf TCFONT, --tcfont TCFONT txtcell font（文本的字体） -tfs TCFONTSIZE, --tcfontsize TCFONTSIZE txtcell fontsize（文本的字体大小） -dfs DFFONTSIZE, --dffontsize DFFONTSIZE pandas dataframe fontsize（pandas类型的字体大小） -ofs OUTFONTSIZE, --outfontsize OUTFONTSIZE output area fontsize（输出区域字体大小） -mathfs MATHFONTSIZE, --mathfontsize MATHFONTSIZE mathjax fontsize (in %)（数学公式字体大小） -m MARGINS, --margins MARGINS fix margins of main intro page -cursw CURSORWIDTH, --cursorwidth CURSORWIDTH set cursorwidth (px)（设置光标宽度） -cursc CURSORCOLOR, --cursorcolor CURSORCOLOR cursor color (r, b, g, p)（设置光标颜色） -cellw CELLWIDTH, --cellwidth CELLWIDTH set cell width (px or %)（单元的宽度） -lineh LINEHEIGHT, --lineheight LINEHEIGHT code/text line-height (%)（行高） -altp, --altprompt alt input prompt style -altmd, --altmarkdown alt markdown cell style -altout, --altoutput set output bg color to notebook bg -P, --hideprompt hide cell input prompt -T, --toolbar make toolbar visible（工具栏可见） -N, --nbname nb name/logo visible -vim, --vimext toggle styles for vim -r, --reset reset to default theme（设置成默认主题） -dfonts, --defaultfonts force fonts to browser default（设置成浏览器默认字体） 第三部分 案例例如下面的命令完成效果： 使用的主题是：monokai，工具栏可见，命名笔记本的选项，代码的字体为13，代码的字体为consolamono。 1root@vultr:~# jt -t monokai -T -N -fs 13 -f consolamono 如果jupyter进程已启，需要重新启进程后生效。 实现的效果截图： 其他主题效果大家可以自己尝试。 参考文献及资料1、jupyter官网，链接：https://jupyter.org/]]></content>
      <categories>
        <category>jupyter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[树莓派使用USB摄像头自制家庭监控]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8USB%E6%91%84%E5%83%8F%E5%A4%B4%E8%87%AA%E5%88%B6%E5%AE%B6%E5%BA%AD%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 部署步骤 参考文献及资料 背景树莓派摄像头和USB摄像头 树莓派有配套的摄像头模块（Raspberry Pi camera board），如下图。 另外树莓派也支持USB摄像头。关于树莓派支持的USB摄像头有个清单参考（需要梯子）。大家购买前最好确认一下是否在兼容清单中。 第一部分 部署步骤第一步：检查USB摄像头和树莓派的兼容性将USB摄像头和树莓派连接，查看USB接口连接情况。 12345root@raspberrypi:/# lsusbBus 001 Device 004: ID 046d:0825 Logitech, Inc. Webcam C270Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet AdapterBus 001 Device 002: ID 0424:9514 Standard Microsystems Corp.Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 发现004口上面连接并识别了摄像头（我的是Logitech 270摄像头）。 如果没有识别出来，需要查看USB兼容清单是否有该型号。另外由于树莓派供电功率较小，也有可能是USB供电功率不足，需要有外置电源的USB摄像头。 另外还可以查看设备驱动情况： 12root@raspberrypi:/# ls /dev/vid*/dev/video0 发现video0设备，说明识别了USB摄像头（罗技的c270i） 第二步：MOTION软件实现对于USB摄像头，有多种软件包可以实现拍照和摄像等功能，这里使用motion。 安装motion 1root@raspberrypi:/# sudo apt-get install motion 编辑配置配置文件 1root@raspberrypi:~# vi /etc/motion/motion.conf 调整相关参数 123456789101112# The mini-http server listens to this port for requests (default: 0 = disabled)stream_port 8082# web界面访问端口# TCP/IP port for the http server to listen on (default: 0 = disabled)webcontrol_port 8080#控制端口# Restrict control connections to localhost only (default: on)webcontrol_localhost off# Target base directory for pictures and films# Recommended to use absolute path. (Default: current working directory)target_dir /var/lib/motion#照片及视频存放路径 其他参数调整如下： ​ ffmpeg_output_movies=off ​ stream_localhost=off ​ webcontrol_localhost=off ​ locate_motion_mode=peview ​ locate_motion_style=redbox ​ text_changes=on 开启motion进程修改motion文件，设置为守护进程运行（即参数配置为：yes）： 123# vi /etc/default/motion# set to 'yes' to enable the motion daemonstart_motion_daemon=yes 启进程： 1234567root@raspberrypi:/etc/init.d# motion start[0] [NTC] [ALL] conf_load: Processing thread 0 - config file /etc/motion/motion.conf[0] [ALR] [ALL] conf_cmdparse: Unknown config option "sdl_threadnr"[0] [NTC] [ALL] motion_startup: Motion 3.2.12+git20140228 Started[0] [NTC] [ALL] motion_startup: Logging to syslog[0] [NTC] [ALL] motion_startup: Using log type (ALL) log level (NTC)[0] [NTC] [ALL] become_daemon: Motion going to daemon mode 查看监控画面地址栏中输入地址和端口号（IP：8082），上面配置的web界面访问端口为8082： 查看监控数据存放目录另外目录/var/lib/motion中存放历史数据。 第三步：内网穿透（外网访问web监控界面）实现上面的步骤，你只能在家里本地局域网访问监控界面，意义不大。 由于目前中国宽带服务公司都不会给家庭网络外网地址。所以需要内网穿透，实现外网访问家庭内网。 具体可以使用frp软件实现内网穿透。具体做法参考的博客中另一篇介绍frp的分享文章。 参考文献及资料1、Building a Motion Activated Security Camera with the Raspberry Pi Zero，链接： https://www.bouvet.no/bouvet-deler/utbrudd/building-a-motion-activated-security-camera-with-the-raspberry-pi-zero 2、How to make a DIY home alarm system with a raspberry pi and a webcam，链接：https://medium.com/@Cvrsor/how-to-make-a-diy-home-alarm-system-with-a-raspberry-pi-and-a-webcam-2d5a2d61da3d]]></content>
      <categories>
        <category>raspberry</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动手实现深度学习相机]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14-deeplearning_camera(%E6%9C%AA%E5%AE%8C%E7%A8%BF)%2F</url>
    <content type="text"><![CDATA[2017年年底，亚马逊（AWS）宣布将推出深度学习相机——DeepLens ，亚马逊官网已经开始预售，预计6月14日发货。但是售价为249刀（约1600人民币）。偏贵了。 具体介绍可以参考这篇文章：AWS深度学习摄像头，将对机器学习产业有何影响？ 看到有人利用树莓派和简易摄像头实现了一个深度学习相机，用来检测院子里面小鸟吃食。正好自己有一个树莓派，可以参考玩一下。进一步优化甚至可以放在家门口，对访客人脸识别。]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统常用命令汇总]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-15-Ubuntu%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 系统信息 第二部分 资源信息 第三部分 磁盘信息 第四部分 网络信息 第五部分 进程信息 第六部分 用户信息 参考文献及资料 背景本篇博客主要汇总查询Ubuntu系统的信息的相关命令及展示案例。会持续更新。 第一部分 系统信息1.1 查看：CPU信息12root@deeplearning:/# cat /proc/versionLinux version 4.13.0-37-generic (buildd@lcy01-amd64-012) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9)) #42~16.04.1-Ubuntu SMP Wed Mar 7 16:03:28 UTC 2018 1.2 查看：内核、操作系统、CPU信息12root@deeplearning:/# uname -aLinux deeplearning 4.13.0-37-generic #42~16.04.1-Ubuntu SMP Wed Mar 7 16:03:28 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 1.3 查看：操作系统版本信息123456root@deeplearning:/# lsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 16.04.4 LTSRelease: 16.04Codename: xenial 1.4 查看：计算机名12root@vultr:~# hostnamevultr.guest 第二部分 资源信息2.1 查看：存储分区的使用信息123456789root@vultr:~# df -hFilesystem Size Used Avail Use% Mounted onudev 469M 0 469M 0% /devtmpfs 99M 11M 89M 11% /run/dev/vda1 25G 12G 12G 49% /tmpfs 495M 0 495M 0% /dev/shmtmpfs 5.0M 0 5.0M 0% /run/locktmpfs 495M 0 495M 0% /sys/fs/cgrouptmpfs 99M 0 99M 0% /run/user/0 2.2 查看：系统运行时间、用户数量12root@vultr:~# uptime 23:04:54 up 10 days, 17:21, 1 user, load average: 0.21, 0.06, 0.02 第三部分 磁盘信息3.1 查看:所有分区信息12345678910root@vultr:~# fdisk -lDisk /dev/vda: 25 GiB, 26843545600 bytes, 52428800 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0xcb855d49Device Boot Start End Sectors Size Id Type/dev/vda1 * 2048 52428257 52426210 25G 83 Linux 第四部分 网络信息4.1 查看：网络接口信息12345678910root@vultr:~# ifconfig#（略）lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 198660 bytes 27478459 (27.4 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 198660 bytes 27478459 (27.4 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 4.2 查看：防火墙信息1234root@vultr:~# iptables -LChain DOCKER-USER (1 references)target prot opt source destination RETURN all -- anywhere anywhere 4.3 查看：路由表12345root@vultr:~# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface#（略）172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0 4.4 查看：监听端口、已经建立的连接1234root@vultr:~# netstat -lntpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 749/sshd 1234root@vultr:~# netstat -antpActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 749/sshd 4.5 查看：网络统计信息123456root@vultr:~# netstat -sIp: Forwarding: 1 5729182 total packets received 9 with invalid addresses#略信息 第五部分 进程信息5.1 查看：所有进程信息123root@vultr:~# ps -ef UID PID PPID C STIME TTY TIME CMDroot 1 0 0 Mar25 ? 00:00:44 /sbin/init 5.2 查看：实时显示进程状态12345678910root@vultr:~# toptop - 23:24:19 up 10 days, 17:41, 1 user, load average: 0.02, 0.02, 0.00Tasks: 87 total, 1 running, 86 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.7 us, 0.3 sy, 0.0 ni, 99.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1012392 total, 74384 free, 270236 used, 667772 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 556896 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 25691 root 20 0 554760 13348 3448 S 0.3 1.3 35:21.42 docker-containe #（略信息） 第六部分 用户信息6.1 查看：活动用户1234root@vultr:~# w 23:25:22 up 10 days, 17:42, 1 user, load average: 0.33, 0.08, 0.02USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 140.31.74.0 22:59 2.00s 0.06s 0.00s w 6.2 查看：用户登录日志信息12345root@vultr:~# lastroot pts/0 113.41.56.0 Wed Apr 4 22:59 still logged inroot pts/0 113.41.56.0 Wed Apr 4 08:37 - 13:38 (05:00)wtmp begins Sun Apr 1 19:59:32 2018 参考文献及资料1、The 50 Most Useful Linux Commands To Run in the Terminal，链接：https://www.ubuntupit.com/best-linux-commands-to-run-in-the-terminal/]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu添加国内apt更新源]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-15-Ubuntu%E6%B7%BB%E5%8A%A0%E5%9B%BD%E5%86%85apt%E6%9B%B4%E6%96%B0%E6%BA%90%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 更换步骤 参考文献及资料 背景本篇博客主要介绍如何更改Ubuntu系统的apt源。 关于源我们使用apt安装软件时，会到国外源下载软件包。但是由于各种原因（你懂的）国外站点到国内的下载速度非常缓慢，甚至1k/s。对于大的包，这是无法忍受的等待，经常会超时中断。所以我们换成国内的源站点。其中口碑比较好的源站点有：阿里源、清华源、中科大源等。 Ubuntu系统的源地址文件位置：/etc/apt/sources.list 第一部分 更换步骤第一步：备份 对于系统文件的修改建议实施备份。养成良好的变更习惯。关键时候能救命。 关于备份文件命名有两个建议：（1）含有backup字段提示为备份文件；（2）含有备份日期，便于区分多个备份。当然如果是多用户话应该含有用户名，便于区分。 1root@deeplearning:/# cp /etc/apt/sources.list /etc/apt/sources.list.backup.20180315 第二步：添加源地址 我们添加阿里源， 进入阿里云开源镜像站，找到ubuntu的帮助信息： 我们版本号Ubuntu 16.04.4 LTS，并且Codename: xenial。需要根据自己的版本对应相应的源。 123456789101112131415161718# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricteddeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse 直接将source.list中内容用上面的源地址内容替换，保存后退出。更新源： 1root@deeplearning:/# apt-get update 附录：apt的常用操作命令清单12345678910111213141516sudo apt-get update 更新源sudo apt-get install package 安装包sudo apt-get remove package 删除包sudo apt-cache search package 搜索软件包sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package --reinstall 重新安装包sudo apt-get -f install 修复安装sudo apt-get remove package --purge 删除包，包括配置文件等sudo apt-get build-dep package 安装相关的编译环境sudo apt-get upgrade 更新已安装的包sudo apt-get dist-upgrade 升级系统sudo apt-cache depends package 了解使用该包依赖那些包sudo apt-cache rdepends package 查看该包被哪些包依赖sudo apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包sudo apt-get check 检查是否有损坏的依赖 参考文献及资料1、Ubuntu更换阿里云软件源，链接:https://yq.aliyun.com/articles/704603]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动手实现Ubuntu系统WOL远程唤醒]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14-%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0Ubuntu%E7%B3%BB%E7%BB%9FWOL%E8%BF%9C%E7%A8%8B%E5%94%A4%E9%86%92%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 检查主机板块和网卡是否支持Wol 第二部分 部署步骤 参考文献及资料 背景本篇博客主要介绍通过局域网唤醒服务器（远程启动计算机）。具体在Ubuntu操作系统上实现。具体数据流为：通过互联网远程登录长期开机的树莓派，然后通过树莓派唤醒同一个局域网的高性能服务器。 目前中国家庭宽带网络都是没有外网IP的，如果外网访问家庭网络，需要做端口映射，实现远程访问。 什么是WoL（Wake on LAN）电脑处在关机（或休眠）状态时，只要主机保持连接电源、网线连接网卡，其实网卡和主板仍然有微弱供电。这部分供电能让网卡监听和解读来自外部网络的广播信息。其中会对一种特殊的广播信息Magic Packet（魔法数据包）进行侦测。Magic Packet网络包以广播的形式发送，发送的范围可以是整个局域网或者指定的子网。另外Magic Packet中唤醒服务器IP可以是多个，侦测主机一旦发现包中的唤醒IP集中包含自己的IP，会通知主板、电源供电器，开始执行唤醒，打开机器。 第一部分 检查主机板块和网卡是否支持Wol 主板是否支持：进入BIOS，将“Power Management Setup”中的“Wake Up On LAN”或“Resume by LAN”项设置为“Enable”或“On” 网卡是否支持： 1# ethtool enp0s31f6 其中有下面的字段信息： 12Supports Wake-on: pumbgWake-on: g 第二部分 部署步骤2.1 方法1需要安装wakeonlan包： 1root@raspberrypi:~# sudo apt-get install wakeonlan 下面的命令通过树莓派发送魔术包： 12root@raspberrypi:~# wakeonlan -i 192.168.1.3 b0:6f:bf:b0:9f:2fSending magic packet to 192.168.1.3:9 with b0:6f:b0:bf:9f:2f 2.2 方法2在网关配置ARP信息（IP与物理地址进行绑定），发送网段的广播： 12root@raspberrypi:~# wakeonlan -i 192.168.1.0 b0:6f:bf:b0:9f:2fSending magic packet to 192.168.1.0:9 with b0:6f:b0:bf:9f:2f 参考文献及链接1、WakeOnLan 链接：https://help.ubuntu.com/community/WakeOnLan 2、wiki 链接：https://en.wikipedia.org/wiki/Wake-on-LAN 3、Ubuntu 與 Wake on LAN 链接：http://softsmith.blogspot.com/2014/05/ubuntu-wake-on-lan.html]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[树莓派搭建家庭内网穿透服务器(frp实现)]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-12-%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E5%AE%B6%E5%BA%AD%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%9C%8D%E5%8A%A1%E5%99%A8(frp%E5%AE%9E%E7%8E%B0)%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 环境准备 第二部分 FRP介绍 第三部分 实现步骤 参考文献及资料 背景对于目前家庭网络，有下面两个迫切需求： 需要远程（比如在单位、路途等）SSH访问家里PC服务器、后续实现远程唤醒服务器。 后续部署自制家庭监控，需要远程访问监控web界面。 鉴于上面的需求，技术上需要实现外网访问内网（即内网穿透）。下面详细介绍具体实现步骤。 第一部分 环境准备 一台树莓派主机。由于耗电较少，适合长期开机，作为中转服务器。 一个公网IP。由于电信宽带不提供公网IP，只能自己想办法。正好有一台外网VPS服务器（独有公网IP） 另外顺便打个不收钱的广告：VPS可以使用vultr的虚机，支持支付宝，非常方便。 第二部分 FRP介绍实现内网穿透有很多方法：frp软件、ngrok软件、还有花生壳。关于frp有详细的官方介绍文档 ，不再赘述。 第三部分 实现步骤第一步：配置VPS服务器VPS操作系统为Ubuntu，下载linux_amd64版本： 1root@vultr:~# wget https://github.com/fatedier/frp/releases/download/v0.16.1/frp_0.16.1_linux_amd64.tar.gz 解压缩： 123456789101112root@vultr:~# tar -zxvf frp_0.16.1_linux_amd64.tar.gzfrp_0.16.1_linux_amd64/frp_0.16.1_linux_amd64/frpc_full.inifrp_0.16.1_linux_amd64/LICENSEfrp_0.16.1_linux_amd64/frpc.inifrp_0.16.1_linux_amd64/frps.inifrp_0.16.1_linux_amd64/frpcfrp_0.16.1_linux_amd64/frps_full.inifrp_0.16.1_linux_amd64/frpsroot@vultr:~# cd frp_0.16.1_linux_amd64/root@vultr:~/frp_0.16.1_linux_amd64# lsfrpc frpc_full.ini frpc.ini frps frps_full.ini frps.ini LICENSE 对于VPS服务端只有两个文件是需要的：frps （服务）和frps.ini （配置文件）是需要的，我们拷贝到/bin目录下面（这一步主要是集中放在bin目录便于管理）。 frpc 和frpc.ini是客户端服务和配置文件，后面介绍。 12root@vultr:~/frp_0.16.1_linux_amd64# cp frps /bin/frpsroot@vultr:~/frp_0.16.1_linux_amd64# cp frps.ini /bin/frps.ini 然后对配置文件进行修改： 123456789101112131415161718192021222324252627282930313233root@vultr:/bin# vi frps.ini#修改配置文件[common]bind_addr = 10.66.2.137#VPS公网IP地址（为了保护隐私，上面地址是虚构的）bind_port = 7000#frp服务端口，用户自己定于一个空闲端口（不要和其他应用服务端口冲突）。需要注意的是必须与frpc.ini相同vhost_http_port = 80#http服务端口vhost_https_port = 443#https服务端口dashboard_port = 7500#web控制台端口，10.66.2.137：7500可以访问控制界面#下面两个参数是控制界面的用户名和密码dashboard_user = admindashboard_pwd = Password123！privilege_token = Password123！#特权模式密钥，需与frpc.ini相同log_file = /bin/frps_log/frps.log#日志文件存储路径log_level = info#日志记录级别log_max_days = 7#日志最大存储天数max_pool_count = 5#后端连接池最大连接数量#口令超时时间authentication_timeout = 900#subdomain_host = frp.com #服务端绑定域名tcp_mux = true 保存修改后的配置文件，后台启服务端进程，下面是命令格式： 12345root@vultr:/bin# nohup ./frps -c ./frps.ini &amp;#查看服务进程：root@vultr:/bin# ps -ef|grep frproot 1339 1 0 Mar25 ? 00:03:54 ./frps -c ./frps.iniroot 5320 4958 0 11:42 pts/1 00:00:00 grep --color=auto frp 以上完成服务端配置。 第二步：配置树莓派客户端 注意：树莓派的CPU处理器是ARM的，所以注意下载的版本包。 1root@raspberrypi:~# wget https://github.com/fatedier/frp/releases/download/v0.16.1/frp_0.16.1_linux_arm.tar.gz 解压缩下载的包： 123456789101112root@raspberrypi:~# tar -zxvf frp_0.16.1_linux_arm.tar.gz frp_0.16.1_linux_arm/frp_0.16.1_linux_arm/frpc_full.inifrp_0.16.1_linux_arm/LICENSEfrp_0.16.1_linux_arm/frpc.inifrp_0.16.1_linux_arm/frps.inifrp_0.16.1_linux_arm/frpcfrp_0.16.1_linux_arm/frps_full.inifrp_0.16.1_linux_arm/frpsroot@raspberrypi:~# cd frp_0.16.1_linux_armroot@raspberrypi:~/frp_0.16.1_linux_arm# lsfrpc frpc_full.ini frpc.ini frps frps_full.ini frps.ini LICENSE 类似服务端操作将frpc和frpc.ini拷贝到/bin目录下面。 12root@raspberrypi:~/frp_0.16.1_linux_arm# cp frpc /bin/frpcroot@raspberrypi:~/frp_0.16.1_linux_arm# cp frpc.ini /bin/frpc.ini 修改配置文件： 123456789101112131415161718192021222324252627282930313233343536373839root@raspberrypi:/bin# vi frpc.ini#修改客户端配置文件[common]server_addr = 10.66.2.137#VPS公网IP地址（为了保护隐私，上面地址是虚构的）server_port = 7000privilege_token = Password123！log_file = /bin/frpc.log#日志目录log_level = infolog_max_days = 7pool_count = 5tcp_mux = true#配置SSH端口映射[ssh]type = tcplocal_ip = 127.0.0.1#本地端口local_port = 22#映射端口remote_port = 6000[web]type = httplocal_ip = 127.0.0.1local_port = 80use_encryption = falseuse_compression = truesubdomain = web#所绑定的公网服务器域名，一级、二级域名都可以。这里没有就不用配置了custom_domains = web.frp.com#远程监控端口映射[motion]type = tcplocal_ip = 127.0.0.1local_port = 8082remote_port = 8000 保存修改，后台启客户端进程： 1234root@raspberrypi:/bin# nohup ./frpc -c ./frpc.ini &amp;root@raspberrypi:/bin# ps -ef|grep frproot 4627 1 0 4月02 ? 00:05:19 ./frpc -c ./frpc.iniroot 13731 13669 0 19:56 pts/0 00:00:00 grep frp 第三步：验证 FRP管理界面（http://公网IP:7500） 显示两个端口映射都是online可用的： 下面是整体视图： SSH服务 我们已经将本地访问ssh的服务端口（192.168.1.2：22）映射到外网端口（10.66.2.137：6000）。 例如使用putty工具，IP地址填写：10.66.2.137，端口：6000。 连接后使用树莓派本地ssh用户和密码即可登录。 参考文献及资料[1] FRP官方网站 https://github.com/fatedier/frp]]></content>
      <categories>
        <category>raspberry</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[树莓派更改APT为国内阿里云源]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-12-%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9B%B4%E6%94%B9APT%E4%B8%BA%E5%9B%BD%E5%86%85%E9%98%BF%E9%87%8C%E4%BA%91%E6%BA%90%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 更改步骤 参考文献及资料 背景发现树莓派wget国外源异常慢。其实可以更改为国内的apt源，不用走海下光缆啦。 第一部分 更改步骤1.1 编辑sources.list文件还没安装我喜爱的vim，只能先用nano编辑文件： 1root@raspberrypi:~# nano /etc/apt/sources.list 1.2 修改源将原始的源注释掉，添加阿里云的源地址（在这里感谢阿里爸爸）。 12deb http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contrib rpideb-src http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contrib rpi 1.3 更软件索引清单最后更新一下，以后就可以快速apt-get啦。 1sudo apt-get update 参考文献及资料1、Raspberry Pi 使用阿里云OPSX镜像，链接：https://zihengcat.github.io/2018/05/14/using-alibaba-cloud-opsx-mirrors-in-raspberry-pi/]]></content>
      <categories>
        <category>raspberry</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu操作系统设置静态IP地址]]></title>
    <url>%2F2018%2F02%2F06%2F2018-02-25-Ubuntu%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 编辑interfaces文件 第二部分 添加静态IP信息及DNS信息 第三部分 重启服务生效 参考文献及资料 背景有一台Linux台式机（Ubuntu 16.04.3 LTS (GNU/Linux 4.13.0-32-generic x86_64)）。之前IP是DHCP服务分配的。准备给服务器分配静态IP，方便使用。 ubuntu的网络参数保存在文件/etc/network/interfaces中。 第一部分 编辑interfaces文件12345vi /etc/network/interfaces# interfaces(5) file used by ifup(8) and ifdown(8)auto loiface lo inet loopback 第二部分 添加静态IP信息及DNS信息12345678910# interfaces(5) file used by ifup(8) and ifdown(8)auto loiface lo inet loopbackauto enp0s31f6iface enp0s31f6 inet staticaddress 192.168.31.62gateway 192.168.31.254netmask 255.255.255.0dns-nameservers 192.168.31.1 8.8.8.8 第三部分 重启服务生效1234567891011root@vultr:~# service systemd-networkd status● systemd-networkd.service - Network Service Loaded: loaded (/lib/systemd/system/systemd-networkd.service; enabled-runtime; vendor preset: enabled) Active: active (running) since Wed 2020-03-18 09:18:58 UTC; 3 days ago Docs: man:systemd-networkd.service(8) Main PID: 843 (systemd-network) Status: "Processing requests..." Tasks: 1 (limit: 1108) CGroup: /system.slice/systemd-networkd.service └─843 /lib/systemd/systemd-networkd.... 如果如法生效，尝试reboot服务器。 参考文献及资料1、Configure static IP address on Ubuntu 16.04 LTS Server，链接：https://michael.mckinnon.id.au/2016/05/05/configuring-ubuntu-16-04-static-ip-address/]]></content>
      <categories>
        <category>Linux IP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SAS 9.4 部署及SID文件调整]]></title>
    <url>%2F2018%2F02%2F06%2F2018-02-09-SAS%209.4%20%E9%83%A8%E7%BD%B2%E5%8F%8ASID%E6%96%87%E4%BB%B6%E8%B0%83%E6%95%B4%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 下载SAS 9.4介质及安装 第二部分 SID文件的导入 第三部分 分享一个坑 第四部分 一点提示 参考文献及资料 背景本篇博客主要介绍个人部署SAS 9.4软件过程及安装过程中调整SID文件技巧。由于工作中经常使用SAS软件连接数据库查数，所以个人电脑准备也装备一下，部署过程分享给大家。 第一部分 下载SAS 9.4介质及安装相信大家的资源检索能力，肯定能找到可用的安装介质。 介质可以参考一个网盘地址：http://pan.baidu.com/s/1qYz7ZNA 密码：ulig 解压缩后windows 直接执行setup.exe文件，linux 执行setup.sh文件执行命令：sh setup.sh。 然后选择安装语言、需要安装的组件、选择（32bit或64bit）等，不再赘述。 第二部分 SID文件的导入 如果你有未过期的SID文件，直接导入后安装即可。下面主要介绍没有时咋办（本文介绍方法主要是个人学习使用哈，商业使用建议购买SID哈，毕竟不差钱） 1、闹心的方法首先找到旧的SID文件（授权时间已经过期），导入SID文件前，将操作系统修改为历史时间，然后顺利安装。但是每次使用SAS都要将系统时间后调，否则没法启动SAS正常使用。确实很闹心，而且修改系统时间后很多软件会提示异常，比如浏览器等。 2、奇技淫巧 其实认真查找SID文件，还是可以找到不过期的。 比如下面的链接：http://downloads.npust.edu.tw/otherFile/20170703022854.txt 过期时间为：30APR2018 [ ] 如果用这个SID提示无效或报错，这时候我们需要调整一下这个SID文件。 - 在安装源文件目录中找到order.xml文件，我的目录为：~\SAS 9.4\order_data\99YYS5\order.xm。在文件中找到两个参数：setnumid=&quot;51200421&quot;、number=&quot;99YYS5&quot; - 将SID文件中下面两个参数调整和order文件中相同： 123#调整后Order=99YYS5Setnumid=51200421 [ ] 最后重新加载SID文件，顺利安装。 &gt; 另外如果还是报错可能是遇到别的坑了。。。。。 第三部分 分享一个坑作者部署平台是win7。所以涉及“C:\ Program Files”（存放64bit软件）和“C:\ Program Files(x86)”（存放32bit软件）。 而下载的SAS 9.4是32bit的，路径选择了“C:\ Program Files”，所以导入SID一直报错。 最后缓过神，调整了安装路径为“C:\ Program Files（x86）”（存放32bit软件的地方），最后顺利安装。 第四部分 一点提示SID文件中会有各个组件的授权，如果使用SAS软件部分组件无效，可能是SID文件中未有该组件的授权信息。下面是截取一个SID的授权组件的信息。例如有基础SAS 、SAS EG、还有SAS和oracle、Teradata连接的组件等。 123456Base SAS 31DEC2017SAS Enterprise Guide 31DEC2017SAS Enterprise Miner Personal Client 31DEC2017SAS/ACCESS Interface to Oracle 31DEC2017SAS/ACCESS Interface to PC Files 31DEC2017SAS/ACCESS Interface to Teradata 31DEC2017 例如：Interface to Oracle组件用来和oracle数据链接。连接后SAS EG客户端可以读取数据库中表，新建映射逻辑库就可以用SAS EG来做表操作。 参考文献及资料1、SAS安装介质网盘，链接：介质可以参考一个网盘地址：http://pan.baidu.com/s/1qYz7ZNA 密码：ulig]]></content>
      <categories>
        <category>SAS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python标准库timeit的使用简介]]></title>
    <url>%2F2018%2F01%2F25%2F2018-01-25-Python%E6%A0%87%E5%87%86%E5%BA%93timeit%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 模块介绍 参考文献及资料 背景Python调试代码时，经常需要测算一些代码模块或函数的执行效率（即耗时）。常用手段会在代码前后分别用time.time()记下开始和结束的时间，然后相减获得执行耗时。 本篇博客是一篇学习笔记，介绍Python一个内置模块实现代码执行计时。 第一部分 模块介绍 timeit属于Python的标准库。文件路径在~Lib/timeit.py。 timeit同时具有命令行接口和可调用的函数接口。 一、命令行接口1、案例12&gt;&gt;&gt;python -m timeit '"-".join(str(n) for n in range(100))&gt;&gt;&gt;100000 loops, best of 3: 14.1 usec per loop 回显内容：语句&quot;-&quot;.join(str(n) for n in range(100)执行了10w次，平均耗时14.1 usec。 2、接口参数说明 123456789python -m timeit [-n N] [-r N] [-s S] [-t] [-c] [-h] [statement ...]#[-n N] 表示测试语句（statement）执行的次数。如果不指定，会连续执行10，100，1000，...即10的倍数次，直到总时间至少0.2秒，结束。#[-r N] 计数器重复次数。默认是3。返回一个list，记录每次耗时。#[-s S] statement之前前的初始化语句。默认为pass。#[-t] 使用time.time()。#[-c] 使用time.clock()。#[-v] 会输出更多的执行过程信息。10次的耗时，1000次耗时，等等#[-h] 单独使用，反馈接口的使用信息。 注意：statement和[-s S]的参数按照字符串的形式传入。 二、函数接口1、类timeit.Timer 案例 123456789import timeit#定义一个类t=timeit.Timer('char in text',setup='text="sample string";char="g"')#timeit()函数t.timeit()#回显：0.019882534000089436#repeat()函数t.repeat()#回显：[0.01990252700011297, 0.01574616299990339, 0.015739961000008407] 参数说明 123456#1、初始化一个Timer类的参数：timeit.Timer(stmt='pass', setup='pass', timer=&lt;timer function&gt;)#2、timeit(number=1000000)# 默认number执行100w次。#3、repeat(repeat=3，number=1000000)# 默认执行100w次，重复3次（返回list） 2、两个函数 类似Timer的类，timeit也有两个函数。 1234567#1、timeit函数timeit.timeit(stmt="pass", setup="pass", timer=default_timer,number=default_number)#参数说明：stmt即statement，重复执行的语句。setup即执行前的初始化语句（执行一次）。#2、repeat函数timeit.repeat(stmt='pass', setup='pass', timer=&lt;default timer&gt;, repeat=3, number=1000000)#类似Timer类中函数。 案例 1234567import timeitdef test_example(): for i in range(100): "-".join(str(i))if __name__ == '__main__': print(timeit.timeit("test_example()", setup="from __main__ import test_example"))#25.844697911000367 例子中statement是个函数，重复执行前需要在setup中提前import。 参考文献及资料]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis学习笔记（数据类型及常用命令）]]></title>
    <url>%2F2018%2F01%2F25%2F2018-01-25-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4)%2F</url>
    <content type="text"><![CDATA[目录 背景 第一部分 Redis的数据类型 参考文献及资料 背景Redis作为内存数据库，具有高效的读取性能。首次安装完Redis和Python连接redis的包。尝试做一些hello world的练习。 第一部分 Redis的数据类型 Redis是一个键值数据库（Key-Value） 其中Value值支持5中数据类型。分别是string（字符串）、list（列表）、set（集合）、hash（散列）、zset（有序集合） redis-cli控制台的使用及各种数据类型的操作 进入控制台 12&gt;&gt;&gt;redis-cli127.0.0.1:6379&gt; 表示进入控制台，可以和redis进行互动。首先尝试字符串类型的三个命令（set、get、del）。 1、string类型的3个常用命令set命令 12127.0.0.1:6379&gt; set hello worldOK set命令用于给redis中指定键赋值。这里key为hello，而键值value为world。如果key不存在会自动新建该键。 get命令 12127.0.0.1:6379&gt; get hello"world" get命令用于从redis中获取指定键的值。例子获取了hello键的值，返回键值字符串“world”。 del命令 1234127.0.0.1:6379&gt; del hello(integer) 1127.0.0.1:6379&gt; get hello(nil) del命令用于从redis中删除指定键的键值。且我们用get命令检验，确实被删除了。 2、list类型的4个命令rpush、lpush命令 12345678127.0.0.1:6379&gt; rpush list-test item1(integer) 1127.0.0.1:6379&gt; rpush list-test item2(integer) 2127.0.0.1:6379&gt; rpush list-test item1(integer) 3127.0.0.1:6379&gt; lpush list-test item3(integer) 4 上面的命令我们从右边先后推入了item1，item2，item1；然后从左边推入了item3。所以最后的形式应该是[“item3”,”item1”,”item2”,”item1”] lrange命令 12345127.0.0.1:6379&gt; lrange list-test 0 -11) "item3"2) "item1"3) "item2"4) "item1" lrange用于获取list中指定范围的值。这里0是起始索引，-1是最后一个索引（类似python中的list索引）。 lindex 命令 12127.0.0.1:6379&gt; lindex list-test 2"item2" lindex命令从list中获得指定索引位置的值。这里2实际是第三个值，所以返回“item2”。 lpop、rpop命令 123456127.0.0.1:6379&gt; lpop list-test"item3"127.0.0.1:6379&gt; lrange list-test 0 -11) "item1"2) "item2"3) "item1" lpop命令将list-test中最左边的值删除（弹掉），我们用lrange命令查看，确实已经删除。rpop类似使用。 3、set集合类型的四个命令sadd命令 12345678910127.0.0.1:6379&gt; sadd set-test item(integer) 1127.0.0.1:6379&gt; sadd set-test item1(integer) 1127.0.0.1:6379&gt; sadd set-test item2(integer) 1127.0.0.1:6379&gt; sadd set-test item3(integer) 1127.0.0.1:6379&gt; sadd set-test item4(integer) 1 使用sadd命令向集合set-test加入了5个字符串值。注意set类型类似python中的set类型。无序值不重复。 sismember命令 12127.0.0.1:6379&gt; sismember set-test item3(integer) 1 sismember用来查看值是否在集合中。上面检查item3是否在set-test，返回1，表示在集合中。 srem命令 1234127.0.0.1:6379&gt; srem set-test item2(integer) 1127.0.0.1:6379&gt; srem set-test item6(integer) 0 srem命令查看值是否在集合中，如果在返回1且删除该值。否则返回0。 smembers命令 12345127.0.0.1:6379&gt; smembers set-test1) "item"2) "item4"3) "item1"4) "item3" smembers命令查看集合中所有值。上面的结果也验证了srem确实将item2删除了。 set类型还有集合之间的运算（数学），例如sinter、sunion、sdiff分别是集合的交集、并集、差集运算。 4、hash散列类型的命令散列的数据类型是存储多个键值对之间的映射。 hset命令 12345678127.0.0.1:6379&gt; hset hash-test sub-key1 value1(integer) 1127.0.0.1:6379&gt; hset hash-test sub-key2 value2(integer) 1127.0.0.1:6379&gt; hset hash-test sub-key3 value3(integer) 1127.0.0.1:6379&gt; hset hash-test sub-key2 value2(integer) 0 hset 向hash-test中插入键及键值。返回1表示原hash中无该值，0表示重复插入。 hgetall命令 1234567127.0.0.1:6379&gt; hgetall hash-test1) "sub-key1"2) "value1"3) "sub-key2"4) "value2"5) "sub-key3"6) "value3" hgetall命令从hash-test中获取所有的键值。 hget命令 12127.0.0.1:6379&gt; hget hash-test sub-key2"value2" hget命令从hash-test中获得指定键的键值。 hdel命令 1234567127.0.0.1:6379&gt; hdel hash-test sub-key2(integer) 1127.0.0.1:6379&gt; hgetall hash-test1) "sub-key1"2) "value1"3) "sub-key3"4) "value3" hdel命令删除指定键及键值。 5、有序集合的命令zadd命令 123456127.0.0.1:6379&gt; zadd zset-test 123 number1(integer) 1127.0.0.1:6379&gt; zadd zset-test 456 number2(integer) 1127.0.0.1:6379&gt; zadd zset-test 123 number1(integer) 0 zadd命令zset-test中插入分值（score）及成员名（member）。 zrange命令 12345678127.0.0.1:6379&gt; zrange zset-test 0 -1 withscores1) "number1"2) "123"3) "number2"4) "456"127.0.0.1:6379&gt; zrange zset-test 0 -11) "number1"2) "number2" zrange命令获取指定范围的分值和成员名。其中withscores参数用来控制是否同时获得score值。 zrangebyscores命令 123127.0.0.1:6379&gt; zrangebyscore zset-test 0 200 withscores1) "number1"2) "123" zrangebyscores命令获取scores指定范围的分值和成员名。 zrem命令 12345127.0.0.1:6379&gt; zrem zset-test number1(integer) 1127.0.0.1:6379&gt; zrange zset-test 0 -1 withscores1) "number2"2) "456" zrem命令检查zset-test中知否有该分值和成员名。如果有返回1，并且删除。 参考文献及资料1、redisbook，链接：https://github.com/huangz1990/redisbook]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
</search>
