<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RongXiang</title>
  
  <subtitle>我的烂笔头</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zjrongxiang.github.io/"/>
  <updated>2022-06-18T01:46:31.623Z</updated>
  <id>https://zjrongxiang.github.io/</id>
  
  <author>
    <name>rong xiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python系列文章-jieba分词包使用</title>
    <link href="https://zjrongxiang.github.io/2022/06/17/2022-06-17-Python%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0-jieba%E5%88%86%E8%AF%8D%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://zjrongxiang.github.io/2022/06/17/2022-06-17-Python系列文章-jieba分词包的使用/</id>
    <published>2022-06-17T14:42:00.000Z</published>
    <updated>2022-06-18T01:46:31.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分  </p></li><li><p>第二部分  总结</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p><a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">https://github.com/fxsjy/jieba</a></p><p><a href="https://bbs.huaweicloud.com/blogs/252899" target="_blank" rel="noopener">https://bbs.huaweicloud.com/blogs/252899</a></p><p><a href="https://blog.csdn.net/u013982921/article/details/81122928" target="_blank" rel="noopener">https://blog.csdn.net/u013982921/article/details/81122928</a></p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、变量官网介绍：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分  总结&lt;/p&gt;
&lt;/li
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>经济系列文章-央行资产负债表</title>
    <link href="https://zjrongxiang.github.io/2022/06/06/2022-06-06-%E7%BB%8F%E6%B5%8E%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0-%E5%A4%AE%E8%A1%8C%E8%B5%84%E4%BA%A7%E8%B4%9F%E5%80%BA%E8%A1%A8/"/>
    <id>https://zjrongxiang.github.io/2022/06/06/2022-06-06-经济系列文章-央行资产负债表/</id>
    <published>2022-06-06T13:30:00.000Z</published>
    <updated>2022-06-06T06:48:03.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;h2 id=&quot;参考文献及资料&quot;&gt;&lt;a href=&quot;#参考文献及资料&quot; class=&quot;headerlink&quot; title=&quot;参考文献及资料&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Distance Measures" scheme="https://zjrongxiang.github.io/categories/Distance-Measures/"/>
    
    
      <category term="Data Science" scheme="https://zjrongxiang.github.io/tags/Data-Science/"/>
    
  </entry>
  
  <entry>
    <title>Python环境配置-pip更换国内源</title>
    <link href="https://zjrongxiang.github.io/2022/05/22/2022-05-22-Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-pip%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"/>
    <id>https://zjrongxiang.github.io/2022/05/22/2022-05-22-Python环境配置-pip更换国内源/</id>
    <published>2022-05-22T14:42:00.000Z</published>
    <updated>2022-05-22T05:38:50.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分  Linux环境</li><li>第二部分  windows环境</li><li>第三部分  国内其他安装源</li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>国内环境通过pip安装，默认使用境外的镜像服务器。由于特殊原因，速度较慢，所以需要调整为国内镜像源。例如清华镜像源。</p><p>清华pypi 镜像间隔 5 分钟同步一次。</p><h2 id="第一部分-Linux环境"><a href="#第一部分-Linux环境" class="headerlink" title="第一部分 Linux环境"></a>第一部分 Linux环境</h2><h3 id="1-1-临时使用"><a href="#1-1-临时使用" class="headerlink" title="1.1 临时使用"></a>1.1 临时使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</span><br></pre></td></tr></table></figure><p>注意，<code>simple</code> 不能少, 是 <code>https</code> 而不是 <code>http</code></p><h3 id="1-2-配置文件永久生效"><a href="#1-2-配置文件永久生效" class="headerlink" title="1.2 配置文件永久生效"></a>1.2 配置文件永久生效</h3><p>升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip</span><br></pre></td></tr></table></figure><p>如果需要手动配置，手动创建下面的文件：<code>/root/.config/pip/pip.conf</code></p><p>注意这里是在root下面创建，可以根据情况在其他用户下创建，路径为：<code>~/.pip/pip.conf</code></p><p>文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h2 id="第二部分-windows环境"><a href="#第二部分-windows环境" class="headerlink" title="第二部分 windows环境"></a>第二部分 windows环境</h2><h3 id="1-1-临时使用-1"><a href="#1-1-临时使用-1" class="headerlink" title="1.1 临时使用"></a>1.1 临时使用</h3><p>和Linux相同，命令中增加url参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> -i https://pypi.tuna.tsinghua.edu.cn/simple <span class="keyword">some</span>-<span class="keyword">package</span></span><br></pre></td></tr></table></figure><h3 id="1-2-配置文件永久生效-1"><a href="#1-2-配置文件永久生效-1" class="headerlink" title="1.2 配置文件永久生效"></a>1.2 配置文件永久生效</h3><ul><li><p><strong>方法1</strong>（命令方式）：</p><p>执行执行下面的命令：</p></li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config <span class="keyword">set</span> <span class="keyword">global</span>.<span class="built_in">index</span>-url http<span class="variable">s:</span>//pypi.tuna.tsinghua.edu.<span class="keyword">cn</span>/simple</span><br></pre></td></tr></table></figure><p>回显如下（注意用户名为系统的用户）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Writing to C:\Users\用户名\AppData\Roaming\pip\pip.ini</span><br></pre></td></tr></table></figure><p>或者手动方式创建配置文件，如下：</p><ul><li><strong>方法2</strong>（手动）：</li></ul><p>在<code>C:\Users\用户名\pip</code>（如果没有路径创建，注意用户名用户根据自己系统调整），添加文件<code>pip.ini</code>，文件内容：</p><p>timeout 是超时时间，可以适当调大些。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[global] </span><br><span class="line">timeout = 60000</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p>对于路径可以使用系统默认路径：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\用</span>户名<span class="symbol">\A</span>ppData<span class="symbol">\R</span>oaming<span class="symbol">\p</span>ip</span><br></pre></td></tr></table></figure><h2 id="第三部分-国内其他安装源"><a href="#第三部分-国内其他安装源" class="headerlink" title="第三部分 国内其他安装源"></a>第三部分 国内其他安装源</h2><p>其他国内数据源有：</p><p>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a> </p><p>中国科学技术大学 :<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fpypi.mirrors.ustc.edu.cn%2Fsimple" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple</a></p><p>清华：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fpypi.tuna.tsinghua.edu.cn%2Fsimple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><p>豆瓣：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fpypi.douban.com%2Fsimple%2F" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></p><p>华中理工大学 :<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fpypi.hustunique.com%2Fsimple" target="_blank" rel="noopener">http://pypi.hustunique.com/simple</a></p><p>山东理工大学 :<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fpypi.sdutlinux.org%2Fsimple" target="_blank" rel="noopener">http://pypi.sdutlinux.org/simpl</a>e</p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">清华大学开源软件镜像站</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分  Linux环境&lt;/li&gt;
&lt;li&gt;第二部分  windows环境&lt;/li&gt;
&lt;li&gt;第三部分
      
    
    </summary>
    
      <category term="python" scheme="https://zjrongxiang.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Pyspark系列文章-Pyspark和Elasticsearch交互最佳实践</title>
    <link href="https://zjrongxiang.github.io/2022/05/22/2022-05-22-Pyspark%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0-Pyspark%E5%92%8CElasticsearch%E4%BA%A4%E4%BA%92%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://zjrongxiang.github.io/2022/05/22/2022-05-22-Pyspark系列文章-Pyspark和Elasticsearch交互最佳实践/</id>
    <published>2022-05-22T14:42:00.000Z</published>
    <updated>2022-05-22T02:22:44.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分  Receiver接口模式</p></li><li><p>第二部分  Direct接口模式</p></li><li><p>第三部分  PySpark和Kafka交互</p></li><li><p>第四部分   任务提交</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、Improvements to Kafka integration of Spark Streaming，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分  Receiver接口模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分 
      
    
    </summary>
    
      <category term="pyspark" scheme="https://zjrongxiang.github.io/categories/pyspark/"/>
    
    
  </entry>
  
  <entry>
    <title>深入了解Elasticsearch存储</title>
    <link href="https://zjrongxiang.github.io/2022/05/21/2022-05-21-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Elasticsearch%E5%AD%98%E5%82%A8/"/>
    <id>https://zjrongxiang.github.io/2022/05/21/2022-05-21-深入了解Elasticsearch存储/</id>
    <published>2022-05-21T05:30:00.000Z</published>
    <updated>2022-05-22T02:05:11.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分  环境</li><li>第二部分 导入数据案例</li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>In this article we’ll investigate the files written to the data directory by various parts of Elasticsearch. We will look at node, index and shard level files and give a short explanation of their contents in order to establish an understanding of the data written to disk by Elasticsearch.</p><ul><li>本文对 Elasticsearch 7.10 适用</li><li>Elasticsearch 7.10 对应 Lucene 8.7</li><li>Lucene 8.7 关于扩展名的官方文档 <a href="https://link.segmentfault.com/?enc=maaL0qyPvtzhx0pLpP63Zg%3D%3D.6lwR2Qobh5pP5f95LPdK2YZK9xUnToUGCS%2B1QSdnCbOYDXTYswndMWZqzoxMfnwqKis74FN4pmzmCmDuijCHm26fi7To0EotR0xjFeLxXCQLW0y8QYsw6QvIXRf2Wa6p8PLICL7OfWIPnaxMAf8Z8g%3D%3D" target="_blank" rel="noopener">https://lucene.apache.org/cor…</a></li></ul><h2 id="第一部分-路径"><a href="#第一部分-路径" class="headerlink" title="第一部分 路径"></a>第一部分 路径</h2><p><code>Elasticsearch</code> 运行前需要配置多种文件系统存储路径。分别在<code>JVM</code>启动参数或者配置文件中<code>config/elasticsearch.yml</code>中进行配置。</p><h3 id="1-1-JVM中路径参数"><a href="#1-1-JVM中路径参数" class="headerlink" title="1.1 JVM中路径参数"></a>1.1 <code>JVM</code>中路径参数</h3><ul><li><p><strong><code>path.home</code></strong>：运行 <code>Elasticsearch</code> 进程的用户的主目录。默认为 <code>Java</code> 系统属性<code>user.dir</code>，它是进程所有者的默认主目录。我们在<code>bin/elasticsearch</code>执行脚本中找到下面的<code>Java</code>启动参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Des.path.home="$ES_HOME"</span><br></pre></td></tr></table></figure><p>而这个变量<code>ES_HOME</code>在<code>bin/elasticsearch-env</code>(<code>source</code> 这个变量文件)中定义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ES_HOME=`dirname "$SCRIPT"`</span><br><span class="line">ES_HOME=`cd "$ES_HOME"; pwd`</span><br></pre></td></tr></table></figure><p>所以默认路径为<code>bin</code>同路径，例如我们测试<code>Elasticsearch</code>的<code>path.home</code>路径为：<code>/usr/share/elasticsearch/bin</code>。</p></li><li><p><strong><code>path.conf</code></strong>: 服务的配置文件路径。和<code>path.home</code>定义方式相同，在<code>bin/elasticsearch</code>中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Des.path.conf="$ES_PATH_CONF"</span><br></pre></td></tr></table></figure><p>变量值在<code>bin/elasticsearch-env</code>中定义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ -z "$ES_PATH_CONF" ]; then ES_PATH_CONF="$ES_HOME"/config;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>path.plugins</code></strong>：Elasticsearch 插件目录。用于存放各类插件。位置为：<code>$ES_HOME/plugins</code>。</p></li></ul><h3 id="1-2-配置文件中路径"><a href="#1-2-配置文件中路径" class="headerlink" title="1.2 配置文件中路径"></a>1.2 配置文件中路径</h3><ul><li><strong><code>path.logs</code></strong>：<code>Elasticsearch</code> 运行日志存储路径。配置文件<code>config/elasticsearch.yml</code>可指定。</li><li><strong><code>path.data</code></strong>：<code>Elasticsearch</code> 数据存储路径。</li></ul><h3 id="1-3-全部文件树"><a href="#1-3-全部文件树" class="headerlink" title="1.3 全部文件树"></a>1.3 全部文件树</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tree -L 1 elasticsearch/</span></span><br><span class="line">elasticsearch/</span><br><span class="line">|-- LICENSE.txt       # 证书</span><br><span class="line">|-- NOTICE.txt        # 提示</span><br><span class="line">|-- README.asciidoc   # 说明</span><br><span class="line">|-- bin               # 可执行文件</span><br><span class="line">|-- config            # 配置路径</span><br><span class="line">|-- data              # 数据路径</span><br><span class="line">|-- jdk               # JDK路径，高版本为了解决jdk兼容问题，自带。减少用户自配置各类兼容问题。</span><br><span class="line">|-- lib               # 依赖包路径</span><br><span class="line">|-- logs              # 日志路径</span><br><span class="line">|-- modules           # 各类模块</span><br><span class="line">|-- plugins           # 插件路径</span><br></pre></td></tr></table></figure><p>本文我们将详细介绍数据存储路径 ( <code>path.data</code>) 中的存储内容和用途。</p><h2 id="第二部分-数据路径"><a href="#第二部分-数据路径" class="headerlink" title="第二部分 数据路径"></a>第二部分 数据路径</h2><p>我们现在谈到全文检索，通常都是<code>Elasticsearch</code>或者<code>solr</code>。其实两者都是对搜索引擎<code>Lucene</code>的封装，<code>Lucene</code>成为一个依赖包。</p><blockquote><p>我们查了一下<code>Elasticsearch</code>和<code>solr</code>两个词在<code>Google</code>趋势对比（<code>2004-2022</code>），明显<code>Elasticsearch</code>占优势（<code>Elasticsearch</code> 蓝色曲线，<code>solr</code>红色曲线）。</p><p><img src="images\picture\es_files\Elasticsearch-vs-solr.PNG" alt="Elasticsearch-vs-solr"></p></blockquote><h3 id="2-1-存储架构"><a href="#2-1-存储架构" class="headerlink" title="2.1 存储架构"></a>2.1 存储架构</h3><p><code>Elasticsearch</code> 底层使用 <code>Lucene</code> 来处理分片级别的索引和查询，因此数据目录中的文件由 <code>Elasticsearch</code> 和 <code>Lucene</code> 编写。其中<code>Lucene</code> 负责读写维护 <code>Lucene</code> 索引文件，而 <code>Elasticsearch</code> 在 <code>Lucene</code> 之上读写管理相关的元数据，例如字段映射、索引设置等。</p><p><code>Elasticsearch</code>中一个<code>Shard</code>分片就是一个<code>Lucene Index</code>，每个<code>Lucene</code>里的<code>Segment</code>为<code>Lucene</code>存储的最小管理单元。例如下图中对于分片<code>I1P2</code>进行了案例说明。</p><p><img src="images\picture\es_files\lucene.png" alt="lucene"></p><p>我们先看看 <code>Elasticsearch</code> 写入的数据的外部级别。</p><h3 id="2-2-数据路径"><a href="#2-2-数据路径" class="headerlink" title="2.2 数据路径"></a>2.2 数据路径</h3><p>数据节点<code>data/nodes/0</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tree -L 3 data/</span></span><br><span class="line">data/</span><br><span class="line">`-- nodes</span><br><span class="line">    `-- 0</span><br><span class="line">        |-- _state</span><br><span class="line">        |-- indices</span><br><span class="line">        `-- node.lock</span><br></pre></td></tr></table></figure><ul><li><code>node.lock</code>，文件用于确保一次只有一个 <code>Elasticsearch</code> 安装从单个数据目录读取/写入。</li><li><code>_state</code>，目录中存放集群元数据信息。</li><li><code>indices</code>，目录中存放集群<code>index</code>索引数据。</li></ul><h3 id="2-3-集群元数据"><a href="#2-3-集群元数据" class="headerlink" title="2.3 集群元数据"></a>2.3 集群元数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tree _state/ </span></span><br><span class="line">_state/</span><br><span class="line">|-- _1q.fdt</span><br><span class="line">|-- _1q.fdx</span><br><span class="line">|-- _1q.fnm</span><br><span class="line">|-- _1q.si</span><br><span class="line">|-- _1q_2.liv</span><br><span class="line">|-- _1q_Lucene84_0.doc</span><br><span class="line">|-- _1q_Lucene84_0.tim</span><br><span class="line">|-- _1q_Lucene84_0.tip</span><br><span class="line">|-- _1u.cfe</span><br><span class="line">|-- _1u.cfs</span><br><span class="line">|-- _1u.si</span><br><span class="line">|-- _1x.cfe</span><br><span class="line">|-- _1x.cfs</span><br><span class="line">|-- _1x.si</span><br><span class="line">|-- _1z.cfe</span><br><span class="line">|-- _1z.cfs</span><br><span class="line">|-- _1z.si</span><br><span class="line">|-- manifest-2.st</span><br><span class="line">|-- node-2.st</span><br><span class="line">|-- segments_27</span><br><span class="line">`-- write.lock</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Extension</th><th style="text-align:left">Brief Description</th></tr></thead><tbody><tr><td style="text-align:left">Segments File</td><td style="text-align:left">segments_N</td><td style="text-align:left">Stores information about a commit point</td></tr><tr><td style="text-align:left">Lock File</td><td style="text-align:left">write.lock</td><td style="text-align:left">The Write lock prevents multiple IndexWriters from writing to the same file.(写入锁，防止多个IndexWriters 同时写一个文件)</td></tr><tr><td style="text-align:left">Segment Info</td><td style="text-align:left">.si</td><td style="text-align:left">Stores metadata about a segment（segment的元数据信息，指明这个segment都包含哪些文件）</td></tr><tr><td style="text-align:left">Compound File</td><td style="text-align:left">.cfs, .cfe</td><td style="text-align:left">An optional “virtual” file consisting of all the other index files for systems that frequently run out of file handles.</td></tr><tr><td style="text-align:left">Fields</td><td style="text-align:left">.fnm</td><td style="text-align:left">Stores information about the fields</td></tr><tr><td style="text-align:left">Field Index</td><td style="text-align:left">.fdx</td><td style="text-align:left">Contains pointers to field data</td></tr><tr><td style="text-align:left">Field Data</td><td style="text-align:left">.fdt</td><td style="text-align:left">The stored fields for documents(Field数据文件)</td></tr><tr><td style="text-align:left">Term Dictionary</td><td style="text-align:left">.tim</td><td style="text-align:left">The term dictionary, stores term info</td></tr><tr><td style="text-align:left">Term Index</td><td style="text-align:left">.tip</td><td style="text-align:left">The index into the Term Dictionary</td></tr><tr><td style="text-align:left">Frequencies</td><td style="text-align:left">.doc</td><td style="text-align:left">Contains the list of docs which contain each term along with frequency（保留包含每个Term的文档列表）</td></tr><tr><td style="text-align:left">Positions</td><td style="text-align:left">.pos</td><td style="text-align:left">Stores position information about where a term occurs in the index</td></tr><tr><td style="text-align:left">Payloads</td><td style="text-align:left">.pay</td><td style="text-align:left">Stores additional per-position metadata information such as character offsets and user payloads</td></tr><tr><td style="text-align:left">Norms</td><td style="text-align:left">.nvd, .nvm</td><td style="text-align:left">Encodes length and boost factors for docs and fields</td></tr><tr><td style="text-align:left">Per-Docukment Values</td><td style="text-align:left">.dvd, .dvm</td><td style="text-align:left">Encodes additional scoring factors or other per-document information.</td></tr><tr><td style="text-align:left">Term Vector Index</td><td style="text-align:left">.tvx</td><td style="text-align:left">Stores offset into the document data file</td></tr><tr><td style="text-align:left">Term Vector Documents</td><td style="text-align:left">.tvd</td><td style="text-align:left">Contains information about each document that has term vectors</td></tr><tr><td style="text-align:left">Term Vector Fields</td><td style="text-align:left">.tvf</td><td style="text-align:left">The field level info about term vectors</td></tr><tr><td style="text-align:left">Live Documents</td><td style="text-align:left">.liv</td><td style="text-align:left">Info about what files are live</td></tr></tbody></table><p>更有趣的是<code>global-0.st</code>-file。<code>global-</code>前缀表示这是一个全局状态文件，而扩展<code>.st</code>名表示这是一个包含元数据的状态文件。正如您可能已经猜到的那样，这个二进制文件包含有关集群的全局元数据，前缀后面的数字表示集群元数据版本，这是遵循集群的严格递增的版本控制方案。</p><blockquote><p>虽然技术上可以在紧急情况下使用十六进制编辑器编辑这些文件，但强烈建议不要这样做，因为它会很快导致数据丢失。</p></blockquote><p><a href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-index-files/" target="_blank" rel="noopener">https://www.shenyanchao.cn/blog/2018/12/04/lucene-index-files/</a></p><h3 id="2-4-索引数据"><a href="#2-4-索引数据" class="headerlink" title="2.4 索引数据"></a>2.4 索引数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@f1f4420ca021 0]# tree -L 1 indices/</span><br><span class="line">indices/</span><br><span class="line">|-- Ce1hPxBFTc6xLH9zyzWRog</span><br><span class="line">|-- LFTAEix1Q6u79iWX5wFdAg</span><br><span class="line">|-- cNEZTRZGTtWn2f5r7zjveQ</span><br><span class="line">|-- pg9zI9o1QNKFav7KsxVQ-Q</span><br><span class="line">|-- r0lRikPvTUOWZaloPg7QXw</span><br><span class="line">`-- wHQ5gnEESM2GWgQsybPTKA</span><br></pre></td></tr></table></figure><p>让我们创建一个单一的分片索引并查看 Elasticsearch 更改的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tree cNEZTRZGTtWn2f5r7zjveQ</span></span><br><span class="line">cNEZTRZGTtWn2f5r7zjveQ</span><br><span class="line">|-- 0</span><br><span class="line">|   |-- _state</span><br><span class="line">|   |   |-- retention-leases-9.st</span><br><span class="line">|   |   `-- state-0.st</span><br><span class="line">|   |-- index</span><br><span class="line">|   |   |-- _6.cfe</span><br><span class="line">|   |   |-- _6.cfs</span><br><span class="line">|   |   |-- _6.si</span><br><span class="line">|   |   |-- _6_1.fnm</span><br><span class="line">|   |   |-- _6_1_Lucene80_0.dvd</span><br><span class="line">|   |   |-- _6_1_Lucene80_0.dvm</span><br><span class="line">|   |   |-- _7.cfe</span><br><span class="line">|   |   |-- _7.cfs</span><br><span class="line">|   |   |-- _7.si</span><br><span class="line">|   |   |-- segments_6</span><br><span class="line">|   |   `-- write.lock</span><br><span class="line">|   `-- translog</span><br><span class="line">|       |-- translog-4.tlog</span><br><span class="line">|       `-- translog.ckp</span><br><span class="line">`-- _state</span><br><span class="line">    `-- state-2.st</span><br></pre></td></tr></table></figure><p>我们看到已经创建了一个与索引名称对应的新目录。该目录有两个子文件夹：<code>_state</code>和<code>0</code>. 前者包含所谓的索引状态文件 ( <code>indices/{index-name}/_state/state-{version}.st</code>)，其中包含有关索引的元数据，例如其创建时间戳。它还包含唯一标识符以及索引的设置和映射。后者包含与索引的第一个（也是唯一一个）分片（分片 0）相关的数据。接下来，我们将仔细研究一下。</p><h2 id="分片数据"><a href="#分片数据" class="headerlink" title="分片数据"></a>分片数据</h2><p>分片数据目录包含分片的状态文件，其中包括版本控制以及有关分片被视为主分片还是副本的信息。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tree -h data/elasticsearch/nodes/<span class="number">0</span>/indices/foo/<span class="number">0</span></span><br><span class="line">data/elasticsearch/nodes/<span class="number">0</span>/indices/foo/<span class="number">0</span></span><br><span class="line">├── [ <span class="number">102</span>]  _state</span><br><span class="line">│   └── [  <span class="number">81</span>]  <span class="section">state</span><span class="number">-0.</span>st</span><br><span class="line">├── [ <span class="number">170</span>]  index</span><br><span class="line">│   ├── [  <span class="number">36</span>]  segments.gen</span><br><span class="line">│   ├── [  <span class="number">79</span>]  segments_1</span><br><span class="line">│   └── [   <span class="number">0</span>]  write.lock</span><br><span class="line">└── [ <span class="number">102</span>]  translog</span><br><span class="line">    └── [  <span class="number">17</span>]  translog<span class="number">-1429697028120</span></span><br></pre></td></tr></table></figure><p>在早期的 Elasticsearch 版本中，在分片数据目录中也可以找到单独的<code>{shard_id}/index/_checksums-</code>文件（和<code>.cks</code>-files）。在当前版本中，这些校验和现在位于 Lucene 文件的页脚中，因为 Lucene 已为其所有索引文件添加了端到端校验和。</p><p>该<code>{shard_id}/index</code>目录包含 Lucene 拥有的文件。Elasticsearch 通常不会直接写入此文件夹（在早期版本中发现较旧的校验和实现除外）。这些目录中的文件构成了任何 Elasticsearch 数据目录的大部分大小。</p><p>在我们进入 Lucene 的世界之前，我们将看一下 Elasticsearch 事务日志，不出所料，它位于每个分片<code>translog</code>目录中，前缀为<code>translog-</code>. 事务日志对于 Elasticsearch 的功能和性能非常重要，因此我们将在下一节更深入地解释它的使用。</p><h3 id="每个分片的事务日志"><a href="#每个分片的事务日志" class="headerlink" title="每个分片的事务日志"></a>每个分片的事务日志</h3><p>Elasticsearch事务<a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-translog.html" target="_blank" rel="noopener">日志</a>确保数据可以安全地被索引到 Elasticsearch 中，而无需为每个文档执行低级别的 Lucene 提交。提交 Lucene 索引会在 Lucene 级别创建一个新段，该段是<code>fsync()</code>-ed 并导致大量磁盘 I/O 影响性能。</p><p>为了接受文档进行索引并使其可搜索而不需要完整的 Lucene 提交，Elasticsearch 将其添加到<a href="http://lucene.apache.org/core/5_1_0/core/org/apache/lucene/index/IndexWriter.html" target="_blank" rel="noopener">Lucene<code>IndexWriter</code></a>并将其附加到事务日志中。每次之后<a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-update-settings.html" target="_blank" rel="noopener"><code>refresh_interval</code></a>，它都会调用<code>reopen()</code>Lucene 索引，这将使数据无需提交即可搜索。这是 Lucene 近实时 API 的一部分。当<code>IndexWriter</code>由于事务日志的自动刷新或显式<a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-flush.html" target="_blank" rel="noopener">刷新操作</a>而最终提交时，先前的事务日志将被丢弃，而新的事务日志将取而代之。</p><p>如果需要恢复，Lucene中写入磁盘的段将首先恢复，然后重放事务日志，以防止丢失尚未完全提交到磁盘的操作。</p><h2 id="Lucene-索引文件"><a href="#Lucene-索引文件" class="headerlink" title="Lucene 索引文件"></a><a href="https://www.elastic.co/cn/blog/found-dive-into-elasticsearch-storage#lucene-index-files" target="_blank" rel="noopener">Lucene 索引文件</a></h2><p><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/package-summary.html#package_description" target="_blank" rel="noopener">Lucene 在记录Lucene 索引目录</a>中的文件方面做得很好，为了方便起见，在此处复制（Lucene 中的链接文档还详细介绍了这些文件自 Lucene 2.1 以来所经历的更改，因此请检查出来）：</p><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Extension</th><th style="text-align:left">Brief Description</th></tr></thead><tbody><tr><td style="text-align:left">Segments File</td><td style="text-align:left">segments_N</td><td style="text-align:left">Stores information about a commit point</td></tr><tr><td style="text-align:left">Lock File</td><td style="text-align:left">write.lock</td><td style="text-align:left">The Write lock prevents multiple IndexWriters from writing to the same file.</td></tr><tr><td style="text-align:left">Segment Info</td><td style="text-align:left">.si</td><td style="text-align:left">Stores metadata about a segment</td></tr><tr><td style="text-align:left">Compound File</td><td style="text-align:left">.cfs, .cfe</td><td style="text-align:left">An optional “virtual” file consisting of all the other index files for systems that frequently run out of file handles.</td></tr><tr><td style="text-align:left">Fields</td><td style="text-align:left">.fnm</td><td style="text-align:left">Stores information about the fields</td></tr><tr><td style="text-align:left">Field Index</td><td style="text-align:left">.fdx</td><td style="text-align:left">Contains pointers to field data</td></tr><tr><td style="text-align:left">Field Data</td><td style="text-align:left">.fdt</td><td style="text-align:left">The stored fields for documents</td></tr><tr><td style="text-align:left">Term Dictionary</td><td style="text-align:left">.tim</td><td style="text-align:left">The term dictionary, stores term info</td></tr><tr><td style="text-align:left">Term Index</td><td style="text-align:left">.tip</td><td style="text-align:left">The index into the Term Dictionary</td></tr><tr><td style="text-align:left">Frequencies</td><td style="text-align:left">.doc</td><td style="text-align:left">Contains the list of docs which contain each term along with frequency</td></tr><tr><td style="text-align:left">Positions</td><td style="text-align:left">.pos</td><td style="text-align:left">Stores position information about where a term occurs in the index</td></tr><tr><td style="text-align:left">Payloads</td><td style="text-align:left">.pay</td><td style="text-align:left">Stores additional per-position metadata information such as character offsets and user payloads</td></tr><tr><td style="text-align:left">Norms</td><td style="text-align:left">.nvd, .nvm</td><td style="text-align:left">Encodes length and boost factors for docs and fields</td></tr><tr><td style="text-align:left">Per-Docukment Values</td><td style="text-align:left">.dvd, .dvm</td><td style="text-align:left">Encodes additional scoring factors or other per-document information.</td></tr><tr><td style="text-align:left">Term Vector Index</td><td style="text-align:left">.tvx</td><td style="text-align:left">Stores offset into the document data file</td></tr><tr><td style="text-align:left">Term Vector Documents</td><td style="text-align:left">.tvd</td><td style="text-align:left">Contains information about each document that has term vectors</td></tr><tr><td style="text-align:left">Term Vector Fields</td><td style="text-align:left">.tvf</td><td style="text-align:left">The field level info about term vectors</td></tr><tr><td style="text-align:left">Live Documents</td><td style="text-align:left">.liv</td><td style="text-align:left">Info about what files are live</td></tr></tbody></table><p>通常，您还会<code>segments.gen</code>在 Lucene 索引目录中看到一个文件，该文件是一个帮助文件，其中包含有关当前/最新<code>segments_N</code>文件的信息，用于可能无法通过目录列表返回足够信息来确定最新一代段文件的文件系统.</p><p>在较旧的 Lucene 版本中，您还可以找到带有<code>.del</code>后缀的文件。它们与 Live Documents ( ) 文件的用途相同<code>.liv</code>——换句话说，它们是删除列表。如果您想知道所有这些关于实时文档和删除列表的讨论是关于什么的，您可能想阅读<a href="https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up/#building-indexes" target="_blank" rel="noopener">自下而上文章中关于在我们的 Elasticsearch</a>中构建索引的部分。</p><h2 id="修复有问题的碎片"><a href="#修复有问题的碎片" class="headerlink" title="修复有问题的碎片"></a>修复有问题的碎片</h2><p>由于 Elasticsearch 分片包含 Lucene 索引，因此我们可以使用 Lucene 出色的<a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/index/CheckIndex.html" target="_blank" rel="noopener">CheckIndex 工具</a>，它使我们能够扫描和修复有问题的段，通常数据丢失最少。我们通常会建议 Elasticsearch 用户简单地重新索引数据，但如果由于某种原因无法重新索引并且数据非常重要，那么即使需要相当多的手动工作和时间，也可以采用这种方法，取决于分片的数量及其大小。</p><blockquote><p>Lucene<code>CheckIndex</code>工具包含在默认的 Elasticsearch 发行版中，无需额外下载。</p></blockquote><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改它以反映您的分片路径，格式为# &#123;path.data&#125;/&#123;cluster_name&#125;/nodes/&#123;node_id&#125;/indices/&#123;index_name&#125;/&#123;shard_id&#125;/index/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ export SHARD_PATH = data / elasticsearch / nodes / <span class="number">0</span> / indices / foo / <span class="number">0</span> / index / </span><br><span class="line">$java - cp <span class="class"><span class="keyword">lib</span> / <span class="title">elasticsearch</span>- *。<span class="title">jar</span> : <span class="title">lib</span> /*:<span class="title">lib</span>/<span class="title">sigar</span>/* -<span class="title">ea</span>:<span class="title">org</span>.<span class="title">apache</span>.<span class="title">lucene</span>... <span class="title">org</span>.<span class="title">apache</span>.<span class="title">lucene</span>.<span class="title">index</span>.<span class="title">CheckIndex</span> $<span class="title">SHARD_PATH</span></span></span><br></pre></td></tr></table></figure><p><code>-fix</code>如果 CheckIndex 检测到问题并且它的修复建议看起来很合理，您可以通过添加命令行参数 告诉 CheckIndex 应用修复程序。</p><h2 id="存储快照"><a href="#存储快照" class="headerlink" title="存储快照"></a>存储快照</h2><p>您可能想知道所有这些文件如何转换为<a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html" target="_blank" rel="noopener">快照存储库</a>使用的存储。不要再想了：获取这个集群，将其作为<code>my-snapshot</code>基于文件系统的网关进行快照，然后检查存储库中的文件，我们会找到这些文件（为简洁起见，省略了一些文件）：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ tree -h snapshots</span><br><span class="line">snapshots</span><br><span class="line">├── [  <span class="number">31</span>]  index</span><br><span class="line">├── [ <span class="number">102</span>]  indices</span><br><span class="line">│   └── [ <span class="number">136</span>]  foo</span><br><span class="line">│       ├── [<span class="number">1.2</span>K]  <span class="number">0</span></span><br><span class="line">│       │   ├── [ <span class="number">350</span>]  __0</span><br><span class="line">│       │   ├── [<span class="number">1.8</span>K]  __1</span><br><span class="line">...</span><br><span class="line">│       │   ├── [ <span class="number">350</span>]  __w</span><br><span class="line">│       │   ├── [ <span class="number">380</span>]  __x</span><br><span class="line">│       │   └── [<span class="number">8.2</span>K]  snapshot-my-snapshot</span><br><span class="line">│       └── [ <span class="number">249</span>]  snapshot-my-snapshot</span><br><span class="line">├── [  <span class="number">79</span>]  metadata-my-snapshot</span><br><span class="line">└── [ <span class="number">171</span>]  snapshot-my-snapshot$ tree - h 快照</span><br><span class="line">快照</span><br><span class="line">├── [ <span class="number">31</span> ]  索引</span><br><span class="line">├── [ <span class="number">102</span> ]  索引</span><br><span class="line">│ └── [ <span class="number">136</span> ]   foo</span><br><span class="line"> │ ├── [ <span class="number">1.2</span>K ] <span class="number">0</span> │ │ ├── [ <span class="number">350</span> ]   __0</span><br><span class="line"> │ │ ├── [ <span class="number">1.8</span>K ]   __1</span><br><span class="line"> ... │ │ ├── [ <span class="number">350</span> ]   __w</span><br><span class="line"> │ │ ├── [ <span class="number">380</span> ]   __x</span><br><span class="line"> │ │ └── [                    </span><br><span class="line">                       </span><br><span class="line">                                   <span class="number">8.2</span>K ]  快照-我的-快照</span><br><span class="line">│ └── [ <span class="number">249</span> ]  快照-我的-快照</span><br><span class="line">├── [ <span class="number">79</span> ]  元数据-我的-快照</span><br><span class="line">└── [ <span class="number">171</span> ]  快照-我的-快照</span><br></pre></td></tr></table></figure><p>在根目录下，我们有一个<code>index</code>文件，其中包含有关此存储库中所有快照的信息，并且每个快照都有一个关联的文件<code>snapshot-</code>和一个<code>metadata-</code>文件。根目录中的<code>snapshot-</code>文件包含有关快照状态的信息，它包含哪些索引等等。<code>metadata-</code>根目录中 的文件包含快照时的集群元数据。</p><blockquote><p><code>compress: true</code>设置时， 文件<code>metadata-</code>使用<code>snapshot-</code>LZF 进行压缩<a href="https://github.com/ning/compress" target="_blank" rel="noopener">，</a>它侧重于压缩和解压缩速度，这使得它非常适合 Elasticsearch。数据与标题一起存储：<code>ZV + 1 byte indicating whether the data is compressed</code>。在标头之后会有一个或多个压缩的 64K 块，格式为：<code>2 byte block length + 2 byte uncompressed size + compressed data</code>. 使用此信息，您可以使用任何<a href="http://freecode.com/projects/liblzf" target="_blank" rel="noopener">与 LibLZF</a>兼容的解压缩器。如果您想了解有关 LZF 的更多信息，请查看<a href="https://github.com/ning/compress/wiki/LZFFormat" target="_blank" rel="noopener">此格式的精彩描述</a>。</p></blockquote><p>在索引级别有另一个文件，<code>indices/{index_name}/snapshot-{snapshot_name}</code>其中包含索引元数据，例如快照时索引的设置和映射。</p><p>在分片级别，您会发现两种文件：重命名的 Lucene 索引文件和分片快照文件：<code>indices/{index_name}/{shard_id}/snapshot-{snapshot_name}</code>. 该文件包含有关快照中使用了分片目录中的哪些文件的信息，以及从快照中的逻辑文件名到它们在恢复时应存储为磁盘上的具体文件名的映射。它还包含可用于检测和防止数据损坏的所有相关文件的校验和、Lucene 版本控制和大小信息。</p><blockquote><p>您可能想知道为什么这些文件被重命名，而不是仅仅保留它们的原始文件名，这可能更容易直接在磁盘上使用。原因很简单：可以对索引进行快照、删除并在再次创建快照之前重新创建它。在这种情况下，几个文件最终将具有相同的名称，但内容不同。</p></blockquote><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、官网，链接：<a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">https://www.elastic.co/cn/</a></p><p>2、<a href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-index-files/" target="_blank" rel="noopener">https://www.shenyanchao.cn/blog/2018/12/04/lucene-index-files/</a></p><p>3、<a href="https://www.elastic.co/cn/blog/found-dive-into-elasticsearch-storage" target="_blank" rel="noopener">https://www.elastic.co/cn/blog/found-dive-into-elasticsearch-storage</a></p><p>4、<a href="https://elasticsearch.cn/article/6178" target="_blank" rel="noopener">https://elasticsearch.cn/article/6178</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分  环境&lt;/li&gt;
&lt;li&gt;第二部分 导入数据案例&lt;/li&gt;
&lt;li&gt;参考文献及资料&lt;/li&gt;

      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://zjrongxiang.github.io/categories/Elasticsearch/"/>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch测试数据快速导入</title>
    <link href="https://zjrongxiang.github.io/2022/05/19/2022-05-19-Elasticsearch%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5/"/>
    <id>https://zjrongxiang.github.io/2022/05/19/2022-05-19-Elasticsearch测试数据快速导入/</id>
    <published>2022-05-19T05:30:00.000Z</published>
    <updated>2022-05-20T11:14:47.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分  环境</li><li>第二部分 导入数据案例</li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>测试<code>elasticsearch</code>需要一些案例数据导入，然后进行相关工程测试和验证。<code>elasticsearch</code>官方提供了一个公开数据集：莎士比亚作品对白文本数据。</p><p>使用这个数据进行测试。</p><h3 id="第一部分-环境"><a href="#第一部分-环境" class="headerlink" title="第一部分 环境"></a>第一部分 环境</h3><p>本次实战的环境信息如下：</p><ul><li><p>操作系统：Ubuntu 16.04 LTS</p></li><li><p>JDK：1.8.0</p></li><li>elasticsearch：7.6.0</li></ul><h3 id="第二部分-导入数据案例"><a href="#第二部分-导入数据案例" class="headerlink" title="第二部分 导入数据案例"></a>第二部分 导入数据案例</h3><p>测试环境地址：<code>192.168.52.142</code>是<code>elasticsearch</code>服务的<code>IP</code>地址，<code>9200</code>是<code>elasticsearch</code>服务的端口号。导入的<code>shell</code>脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">ES_HOST=$1</span><br><span class="line">ES_PORT=$2</span><br><span class="line"></span><br><span class="line">echo "elasticsearch server is $ES_HOST:$ES_PORT"</span><br><span class="line">echo "downloading data from github"</span><br><span class="line"></span><br><span class="line">wget --no-check-certificate https://download.elastic.co/demos/kibana/gettingstarted/7.x/shakespeare.json</span><br><span class="line">echo "downloading data success"</span><br><span class="line">echo "creating index ..."</span><br><span class="line">curl -X PUT \</span><br><span class="line">http://$&#123;ES_HOST&#125;:$&#123;ES_PORT&#125;/shakespeare \</span><br><span class="line">-H 'Accept: application/json' \</span><br><span class="line">-H 'Content-Type: application/json' \</span><br><span class="line">-H 'cache-control: no-cache' \</span><br><span class="line">-d '&#123;</span><br><span class="line">  "mappings": &#123;</span><br><span class="line">    "properties": &#123;</span><br><span class="line">    "speaker": &#123;"type": "keyword"&#125;,</span><br><span class="line">    "play_name": &#123;"type": "keyword"&#125;,</span><br><span class="line">    "line_id": &#123;"type": "integer"&#125;,</span><br><span class="line">    "speech_number": &#123;"type": "integer"&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;'</span><br><span class="line"></span><br><span class="line">echo ""</span><br><span class="line">echo "loading data ..."</span><br><span class="line"></span><br><span class="line">curl -u elastic -H 'Content-Type: application/x-ndjson' -XPOST '$ES_HOST:$ES_PORT/shakespeare/_bulk?pretty' --data-binary @shakespeare.json &gt; result.log</span><br><span class="line"></span><br><span class="line">echo "finish"</span><br></pre></td></tr></table></figure><p>保存为执行脚本：<code>create_shakespeare_index</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x create_shakespeare_index.sh \</span><br><span class="line">&amp;&amp; ./create_shakespeare_index.sh <span class="number">192.168</span><span class="number">.52</span><span class="number">.142</span> <span class="number">9200</span></span><br></pre></td></tr></table></figure><p>执行完毕后，会创建名为<code>shakespeare</code>的索引，并带有111,396个文档，案例数据如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_index"</span>: <span class="string">"shakespeare"</span>,</span><br><span class="line">  <span class="string">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">  <span class="string">"_id"</span>: <span class="string">"111395"</span>,</span><br><span class="line">  <span class="string">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"_score"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"_source"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"line"</span>,</span><br><span class="line">    <span class="string">"line_id"</span>: <span class="number">111396</span>,</span><br><span class="line">    <span class="string">"play_name"</span>: <span class="string">"A Winters Tale"</span>,</span><br><span class="line">    <span class="string">"speech_number"</span>: <span class="number">38</span>,</span><br><span class="line">    <span class="string">"line_number"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="string">"speaker"</span>: <span class="string">"LEONTES"</span>,</span><br><span class="line">    <span class="string">"text_entry"</span>: <span class="string">"Exeunt"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：由于特殊网络限制，大陆下载较慢可以先下载文件，然后再导入:</p><p><a href="https://download.elastic.co/demos/kibana/gettingstarted/7.x/shakespeare.json" target="_blank" rel="noopener">https://download.elastic.co/demos/kibana/gettingstarted/7.x/shakespeare.json</a></p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、官网，链接：<a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">https://www.elastic.co/cn/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分  环境&lt;/li&gt;
&lt;li&gt;第二部分 导入数据案例&lt;/li&gt;
&lt;li&gt;参考文献及资料&lt;/li&gt;

      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://zjrongxiang.github.io/categories/Elasticsearch/"/>
    
    
  </entry>
  
  <entry>
    <title>Python项目打包实践</title>
    <link href="https://zjrongxiang.github.io/2022/05/19/2022-05-19-Python%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%AE%9E%E8%B7%B5/"/>
    <id>https://zjrongxiang.github.io/2022/05/19/2022-05-19-Python项目打包实践/</id>
    <published>2022-05-19T05:30:00.000Z</published>
    <updated>2022-05-19T03:35:41.607Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h3><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、<code>Logging</code>包，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;h2 id=&quot;第一部分&quot;&gt;&lt;a href=&quot;#第一部分&quot; class=&quot;headerlink&quot; title=&quot;第一部分
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python研发单元测试实践</title>
    <link href="https://zjrongxiang.github.io/2022/05/17/2022-05-17-Python%E7%A0%94%E5%8F%91%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/"/>
    <id>https://zjrongxiang.github.io/2022/05/17/2022-05-17-Python研发单元测试实践/</id>
    <published>2022-05-17T05:30:00.000Z</published>
    <updated>2022-05-17T12:47:43.908Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>python 标准库的 unittest 已经满足了所有功能，但是为啥很多人还是不喜欢写单测呢？因为不够简单，程序员是最嫌麻烦的人，但凡有点费事都会避开。按照 unittest 的写法，必须得创建一个测试类，创建个单独的测试文件，各种都是面向对象的写法，太重。</p><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h3><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、<code>Logging</code>包，链接：<a href="https://docs.python.org/3.9/library/logging.html" target="_blank" rel="noopener">https://docs.python.org/3.9/library/logging.html</a></p><p>2、日志介绍，链接：<a href="https://rmcomplexity.com/article/2020/12/01/introduction-to-python-logging.html" target="_blank" rel="noopener">https://rmcomplexity.com/article/2020/12/01/introduction-to-python-logging.html</a></p><p>3、日志介绍，链接：<a href="https://coralogix.com/blog/python-logging-best-practices-tips/" target="_blank" rel="noopener">https://coralogix.com/blog/python-logging-best-practices-tips/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;python 标准库的 unittest 已经满足了所有功能，但是为啥很多人还是不喜欢写单测呢？因为不够简单，程序
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>logstash、Flume、filebeat文件解析如何实现exactly once语义</title>
    <link href="https://zjrongxiang.github.io/2022/05/13/2022-05-13-logstash%E3%80%81Flume%E3%80%81filebeat%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0exactly%20once%E8%AF%AD%E4%B9%89/"/>
    <id>https://zjrongxiang.github.io/2022/05/13/2022-05-13-logstash、Flume、filebeat文件解析如何实现exactly once语义/</id>
    <published>2022-05-13T05:30:00.000Z</published>
    <updated>2022-05-13T11:58:36.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><ul><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;h2 id=&quot;参考文献及资料&quot;&gt;&lt;a href=&quot;#参考文献及资料&quot; class=&quot;headerlink&quot; title=&quot;参考文献及资料&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="logstash Flume filebeat" scheme="https://zjrongxiang.github.io/categories/logstash-Flume-filebeat/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中日志框架（Logging库）</title>
    <link href="https://zjrongxiang.github.io/2022/05/05/2022-05-05-Python%E4%B8%AD%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%EF%BC%88Logging%E5%BA%93%EF%BC%89/"/>
    <id>https://zjrongxiang.github.io/2022/05/05/2022-05-05-Python中日志框架（Logging库）/</id>
    <published>2022-05-05T05:30:00.000Z</published>
    <updated>2022-06-15T05:32:53.179Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://murphypei.github.io/blog/2019/09/python-logging" target="_blank" rel="noopener">https://murphypei.github.io/blog/2019/09/python-logging</a></p><p>Python版本为Python 3.8.8</p><h2 id="第一部分-内置Logging包"><a href="#第一部分-内置Logging包" class="headerlink" title="第一部分 内置Logging包"></a>第一部分 内置<code>Logging</code>包</h2><h3 id="1-1-日志级别"><a href="#1-1-日志级别" class="headerlink" title="1.1 日志级别"></a>1.1 日志级别</h3><table><thead><tr><th style="text-align:left">等级</th><th></th><th style="text-align:left">数值</th></tr></thead><tbody><tr><td style="text-align:left"><code>CRITICAL</code></td><td>严重；导致应用无法运行的重大错误；</td><td style="text-align:left">50</td></tr><tr><td style="text-align:left"><code>ERROR</code></td><td>错误</td><td style="text-align:left">40</td></tr><tr><td style="text-align:left"><code>WARNING</code></td><td>警告</td><td style="text-align:left">30</td></tr><tr><td style="text-align:left"><code>INFO</code></td><td>信息</td><td style="text-align:left">20</td></tr><tr><td style="text-align:left"><code>DEBUG</code></td><td>调试</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left"><code>NOTSET</code></td><td>通知</td><td style="text-align:left">0</td></tr></tbody></table><p>当然<code>logging</code>包也提供用户自定义日志级别。日志级别通过数值量化比较。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增格式：</span></span><br><span class="line"><span class="comment"># logging.addLevelName(level, levelName)</span></span><br><span class="line">logging.addLevelName(<span class="number">25</span>, <span class="string">'POINT'</span>)</span><br></pre></td></tr></table></figure><p>代码中定义了新的日志级别：<code>POINT</code>，级别值25，在<code>DEBUG</code>和<code>INFO</code>之间。</p><h3 id="1-2-日志流"><a href="#1-2-日志流" class="headerlink" title="1.2 日志流"></a>1.2 日志流</h3><p>参考官网文档：<a href="https://docs.python.org/3/howto/logging.html#logging-basic-tutorial" target="_blank" rel="noopener">https://docs.python.org/3/howto/logging.html#logging-basic-tutorial</a></p><p>详细流程如下图，其中涉及角色有：</p><ul><li><code>Logger</code>：日志对象。定义后供业务程序调用。判断可用性开关参数，日志级别。不满足条件结束。</li><li><code>LogRecord</code> ：日志记录器。多于满足过滤器条件，流程结束。否则继续给将日志传到相应的处理器（Handler）处理。</li><li><code>Handler</code> ：处理器。将日志记录器产生的日志记录发送至合适的目的地。提供各类处理器配置。</li><li><code>Filter</code> ：过滤器。提供了更好的粒度控制,可以决定输出哪些日志记录。</li><li><code>Formatter</code>：格式化器。指明了最终输出中日志记录的格式。</li></ul><p><img src="D:\myblog\source\_posts\images\picture\PythonLogging\logging_flow.png" alt="logging_flow"></p><p>官网中将日志<code>Flow</code>分为<code>Logger Flow</code>和<code>Handler Flow</code>，具体处理如下：</p><ul><li>判断 <code>Logger</code> 对象对于设置的级别是否可用，如果可用，则往下执行，否则，流程结束。</li><li>创建 <code>LogRecord</code> 对象，如果注册到 <code>Logger</code>对象中的 <code>Filter</code> 对象过滤后返回 <code>False</code>，则不记录日志，流程结束，否则，则向下执行。</li><li><code>LogRecord</code> 对象将 <code>Handler</code> 对象传入当前的 <code>Logger</code> 对象，（图中的子流程）如果 <code>Handler</code> 对象的日志级别大于设置的日志级别，再判断注册到 Handler 对象中的 Filter 对象过滤后是否返回 <code>True</code> 而放行输出日志信息，否则不放行，流程结束。</li><li>如果传入的 <code>Handler</code> 大于 <code>Logger</code> 中设置的级别，也即 <code>Handler</code> 有效，则往下执行，否则，流程结束。</li><li>判断这个 <code>Logger</code> 对象是否还有父 <code>Logger</code> 对象，如果没有（代表当前 <code>Logger</code> 对象是最顶层的 <code>Logger</code> 对象 <code>root Logger</code>），流程结束。否则将 <code>Logger</code> 对象设置为它的父 <code>Logger</code> 对象，重复上面的 3、4 两步，输出父类 <code>Logger</code> 对象中的日志输出，直到是 <code>root Logger</code> 为止。</li></ul><p>上述流程我们后面会结合具体配置文件详细说明。</p><h3 id="1-3-基本使用"><a href="#1-3-基本使用" class="headerlink" title="1.3 基本使用"></a>1.3 基本使用</h3><h4 id="1-3-1-例子"><a href="#1-3-1-例子" class="headerlink" title="1.3.1 例子"></a>1.3.1 例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(filename=<span class="string">"test.log"</span>,</span><br><span class="line">                    filemode=<span class="string">"a"</span>,</span><br><span class="line">                    format=<span class="string">"%(asctime)s %(name)s:%(levelname)s:%(message)s"</span>,</span><br><span class="line">                    datefmt=<span class="string">"%d-%M-%Y %H:%M:%S"</span>,</span><br><span class="line">                    level=logging.INFO)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">'debug'</span>)</span><br><span class="line">logging.info(<span class="string">'info'</span>)</span><br><span class="line">logging.warning(<span class="string">'warning'</span>)</span><br><span class="line">logging.error(<span class="string">'error'</span>)</span><br><span class="line">logging.critical(<span class="string">'critical'</span>)</span><br><span class="line"><span class="comment"># 输出test.log（文件若不存在，自动创建），追加写入。</span></span><br><span class="line"><span class="comment">#05-38-2022 20:38:32 root:INFO:info</span></span><br><span class="line"><span class="comment">#05-38-2022 20:38:32 root:WARNING:warning</span></span><br><span class="line"><span class="comment">#05-38-2022 20:38:32 root:ERROR:error</span></span><br><span class="line"><span class="comment">#05-38-2022 20:38:32 root:CRITICAL:critical</span></span><br></pre></td></tr></table></figure><p><code>basicConfig</code> 定义了日志的各类配置参数，具体如下：</p><table><thead><tr><th>参数名</th><th style="text-align:left">参数说明</th></tr></thead><tbody><tr><td><code>filename</code></td><td style="text-align:left">日志输出到文件的文件名</td></tr><tr><td><code>filemode</code></td><td style="text-align:left">文件模式，r[+]、w[+]、a[+]</td></tr><tr><td><code>format</code></td><td style="text-align:left">日志输出的格式</td></tr><tr><td><code>datefmt</code></td><td style="text-align:left">日志附带日期时间的格式</td></tr><tr><td><code>style</code></td><td style="text-align:left">格式占位符，默认为 “%” 和 “{}”</td></tr><tr><td><code>level</code></td><td style="text-align:left">设置日志输出级别</td></tr><tr><td><code>stream</code></td><td style="text-align:left">定义输出流，用来初始化 <code>StreamHandler</code> 对象，不能 <code>filename</code> 参数一起使用，否则会<code>ValueError</code> 异常</td></tr><tr><td><code>handles</code></td><td style="text-align:left">定义处理器，用来创建 <code>Handler</code> 对象，不能和 <code>filename</code> 、<code>stream</code> 参数一起使用，否则也会抛出 <code>ValueError</code> 异常</td></tr></tbody></table><h4 id="1-3-2-日志记录"><a href="#1-3-2-日志记录" class="headerlink" title="1.3.2 日志记录"></a>1.3.2 日志记录</h4><p>每条日志都是一个<code>LogRecord</code> 对象，<code>record</code>对象对象的全部属性如下表。例子中，通过<code>format</code>参数定义日志输出格式，例如：<code>format=&quot;%(asctime)s %(name)s:%(levelname)s:%(message)s&quot;</code>。其中<code>message</code>参数是用户提供，其他参数有用户自定义选取和组织。</p><table><thead><tr><th>参数名</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>args</td><td>You shouldn’t need to format this yourself.</td><td>The tuple of arguments merged into <code>msg</code> to produce <code>message</code>, or a dict whose values are used for the merge (when there is only one argument, and it is a dictionary).</td></tr><tr><td>asctime</td><td><code>%(asctime)s</code></td><td>将日志的时间构造成可读的形式，默认情况下是精确到毫秒，如 <code>2018-10-13 23:24:57,832</code>，可以额外指定 <code>datefmt</code> 参数来指定该变量的格式</td></tr><tr><td>created</td><td><code>%(created)f</code></td><td>Time when the <a href="https://docs.python.org/3.4/library/logging.html#logging.LogRecord" target="_blank" rel="noopener"><code>LogRecord</code></a> was created (as returned by <a href="https://docs.python.org/3.4/library/time.html#time.time" target="_blank" rel="noopener"><code>time.time()</code></a>).</td></tr><tr><td>exc_info</td><td>You shouldn’t need to format this yourself.</td><td>Exception tuple (à la <code>sys.exc_info</code>) or, if no exception has occurred, <em>None</em>.</td></tr><tr><td>filename</td><td><code>%(filename)s</code></td><td>不包含路径的文件名</td></tr><tr><td>funcName</td><td><code>%(funcName)s</code></td><td>日志记录所在的函数名</td></tr><tr><td>levelname</td><td><code>%(levelname)s</code></td><td>日志的级别名称 (<code>&#39;DEBUG&#39;</code>, <code>&#39;INFO&#39;</code>, <code>&#39;WARNING&#39;</code>, <code>&#39;ERROR&#39;</code>,<code>&#39;CRITICAL&#39;</code>).</td></tr><tr><td>levelno</td><td><code>%(levelno)s</code></td><td>Numeric logging level for the message (<code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>,<code>CRITICAL</code>).</td></tr><tr><td>lineno</td><td><code>%(lineno)d</code></td><td>日志记录所在的行号</td></tr><tr><td>module</td><td><code>%(module)s</code></td><td>Module (name portion of <code>filename</code>).</td></tr><tr><td>msecs</td><td><code>%(msecs)d</code></td><td>Millisecond portion of the time when the <a href="https://docs.python.org/3.4/library/logging.html#logging.LogRecord" target="_blank" rel="noopener"><code>LogRecord</code></a> was created.</td></tr><tr><td>message</td><td><code>%(message)s</code></td><td>具体的日志信息, computed as <code>msg % args</code>. This is set when<a href="https://docs.python.org/3.4/library/logging.html#logging.Formatter.format" target="_blank" rel="noopener"><code>Formatter.format()</code></a> is invoked.</td></tr><tr><td>msg</td><td>You shouldn’t need to format this yourself.</td><td>The format string passed in the original logging call. Merged with <code>args</code> to produce <code>message</code>, or an arbitrary object (see <a href="https://docs.python.org/3.4/howto/logging.html#arbitrary-object-messages" target="_blank" rel="noopener">Using arbitrary objects as messages</a>).</td></tr><tr><td>name</td><td><code>%(name)s</code></td><td>日志对象的名称</td></tr><tr><td>pathname</td><td><code>%(pathname)s</code></td><td>进行日志调用的源文件的完整路径名</td></tr><tr><td>process</td><td><code>%(process)d</code></td><td>当前进程ID</td></tr><tr><td>processName</td><td><code>%(processName)s</code></td><td>当前进程名称</td></tr><tr><td>relativeCreated</td><td><code>%(relativeCreated)d</code></td><td>Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.</td></tr><tr><td>stack_info</td><td>You shouldn’t need to format this yourself.</td><td>Stack frame information (where available) from the bottom of the stack in the current thread, up to and including the stack frame of the logging call which resulted in the creation of this record.</td></tr><tr><td>thread</td><td><code>%(thread)d</code></td><td>当前线程ID</td></tr><tr><td>threadName</td><td><code>%(threadName)s</code></td><td>当前线程名称</td></tr></tbody></table><p>如果对于系统自带的参数集合不满足需求。<code>logging</code>包从<code>Python 3.2</code>起提供了<code>Factory</code>函数<code>getLogRecordFactory()</code> 和<code>setLogRecordFactory()</code>支持用户自定义record属性。例如对于分布式部署的环境，日志需要有程序部署节点和主机名和<code>ip</code>信息，需要用户自己新增定义。例如下面的案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">historyFactory = logging.getLogRecordFactory()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_factory</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    record = historyFactory(*args, **kwargs)</span><br><span class="line">    record.hostname = socket.gethostname()</span><br><span class="line">    record.hostip = socket.gethostbyname(socket.gethostname())</span><br><span class="line">    <span class="keyword">return</span> record</span><br><span class="line"></span><br><span class="line">logging.setLogRecordFactory(record_factory)</span><br></pre></td></tr></table></figure><p>这样就可以配置<code>format</code>的时候就可以引用已经定义的参数<code>hostname</code>和<code>hostip</code>。上面的函数相当于在<code>record</code>中新增两个参数的定义。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">format:</span> <span class="string">"%(asctime)s - %(hostname)s - %(hostip)s - %(levelname)s - %(name)s(%(lineno)d) - %(message)s"</span></span><br><span class="line"><span class="comment"># 输出：2022-05-08 15:24:54,163 - localhost-PC - 192.168.152.1 - INFO - TestLogger(48) - info</span></span><br></pre></td></tr></table></figure><p>另外还可以继承<code>logging.Formatter</code>，例如（代码片段放在<code>__ini__.py</code>中，<code>Python</code>的模块名为：<code>logTest</code>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomFormatter</span><span class="params">(logging.Formatter)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        record.hostname = socket.gethostname()</span><br><span class="line">        record.hostip = socket.gethostbyname(socket.gethostname())</span><br><span class="line">        <span class="keyword">return</span> super().format(record)</span><br></pre></td></tr></table></figure><p>使用<code>yaml</code>配置文件时，配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">formatters:</span></span><br><span class="line"><span class="attr">  custom:</span></span><br><span class="line"><span class="attr">    format:</span> <span class="string">"%(asctime)s - %(hostname)s - %(hostip)s - %(levelname)s - %(name)s(%(lineno)d) - %(message)s"</span></span><br><span class="line">    <span class="string">():</span> <span class="string">logTest.CustomFormatter</span></span><br></pre></td></tr></table></figure><p>另外也可以通过自定义日志过滤器 <code>filter</code> 方法来实现。<code>filter</code>实际上既可以过滤日志，也可以添加字段参数和改写<code>record</code>，具有灵活的表达能力。我们在后文介绍。</p><h4 id="1-3-3-日志切割"><a href="#1-3-3-日志切割" class="headerlink" title="1.3.3 日志切割"></a>1.3.3 日志切割</h4><p>生产环境程序常驻运行，为了避免日志文件过大，需要有生命周期管理。通常采用日志切割配置，将日志按照规则进行切割，并按照生命周期策略清理历史文件。</p><p><code>logging</code>包中提供两种方式切割：按照时间和按照大小。</p><ul><li><p>按大小：<code>logging.handlers.RotatingFileHandler</code>类；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> logging.handlers <span class="keyword">import</span> RotatingFileHandler</span><br><span class="line"></span><br><span class="line"><span class="comment"># logging.basicConfig()</span></span><br><span class="line">logger = logging.getLogger(<span class="string">'test'</span>)</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line">formatter = logging.Formatter(<span class="string">'"%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s"'</span>)</span><br><span class="line"><span class="comment"># 定义一个RotatingFileHandler，最多备份5个日志文件，每个日志文件最大0.01M</span></span><br><span class="line">rotatingHandler = RotatingFileHandler(<span class="string">'test.log'</span>, maxBytes=<span class="number">0.01</span>*<span class="number">1024</span>*<span class="number">1024</span>, backupCount=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">rotatingHandler.setFormatter(formatter)</span><br><span class="line">logger.addHandler(rotatingHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是测试案例</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"__name__"</span> == <span class="string">"__main__"</span>:</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">    logger.info(<span class="string">"info"</span>)</span><br><span class="line"><span class="comment"># 会有5个日志文件：test.log test.log.1 test.log.2 test.log.3 test.log.4 test.log.5</span></span><br></pre></td></tr></table></figure></li><li><p>按时间：<code>logging.handlers.TimedRotatingFileHandler</code>类；</p><p>其中参数：<code>TimedRotatingFileHandler(filename [,when [,interval [,backupCount]]])</code></p><ul><li><p><code>filename</code> 输出文件名前缀；</p></li><li><p><code>when</code> 时间单位，字典如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">“S”: Seconds </span><br><span class="line">“M”: Minutes</span><br><span class="line">“H”: Hours</span><br><span class="line">“D”: Days</span><br><span class="line">“W”: Week day (0=Monday)</span><br><span class="line">“midnight”: Roll over at midnight（半夜）</span><br></pre></td></tr></table></figure></li><li><p><code>interval</code> 等待多少个单位<code>when</code>的时间后，<code>Logger</code>会自动重建文件。</p></li><li><p><code>backupCount</code> 是保留日志个数，默认的0是不会自动删除掉日志。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> logging.handlers <span class="keyword">import</span> TimedRotatingFileHandler</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">'test'</span>)</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line">formatter = logging.Formatter(<span class="string">'"%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s"'</span>)</span><br><span class="line"><span class="comment"># 定义一个TimedRotatingFileHandler，最多备份5个日志文件，1分钟切割一次</span></span><br><span class="line">timedRotatingFileHandler = TimedRotatingFileHandler(<span class="string">'Test.log'</span>, <span class="string">"M"</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">timedRotatingFileHandler.suffix = <span class="string">"%Y%m%d-%H%M.log"</span></span><br><span class="line">timedRotatingFileHandler.setFormatter(formatter)</span><br><span class="line">logger.addHandler(timedRotatingFileHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是测试案例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">        logger.info(<span class="string">"info"</span>)</span><br><span class="line"><span class="comment"># 输出日志：Test.log.20220505-2309.log，文件名为：filename+suffix</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-4-handler类"><a href="#1-3-4-handler类" class="headerlink" title="1.3.4 handler类"></a>1.3.4 <code>handler</code>类</h4><p><code>logging</code>包提供大量的<code>handler</code>方法类，其中<code>StreamHandler</code>、<code>FileHandler</code>、<code>NullHandler</code>源码在<code>__init__.py</code>文件中。其他<code>handler</code>在<code>handlers.py</code>中。全部说明如下：</p><ul><li><code>StreamHandler</code> 实例发送消息到流（类似文件对象）。可以是sys.stderr、sys.stdout或者文件。</li><li><code>FileHandler</code> 实例将消息发送到硬盘文件。</li><li><code>BaseRotatingHandler</code> 是轮换日志文件的处理程序的基类。它并不应该直接实例化。而应该使用 <code>RotatingFileHandler</code> 或 <code>TimedRotatingFileHandler</code> 代替它。</li><li><code>RotatingFileHandler</code> 实例将消息发送到硬盘文件，支持最大日志文件大小和日志文件轮换。</li><li><code>TimedRotatingFileHandler</code> 实例将消息发送到硬盘文件，以特定的时间间隔轮换日志文件。</li><li><code>SocketHandler</code> 实例将消息发送到 <code>TCP/IP</code> 套接字。从 3.4 开始，也支持 Unix 域套接字。</li><li><code>DatagramHandler</code> 实例将消息发送到 <code>UDP</code> 套接字。从 3.4 开始，也支持 Unix 域套接字。</li><li><code>SMTPHandler</code> 实例将消息发送到指定的电子邮件地址。</li><li><code>SysLogHandler</code> 实例将消息发送到 <code>Unix syslog</code> 守护程序，可能在远程计算机上。</li><li><code>NTEventLogHandler</code> 实例将消息发送到 <code>Windows NT/2000/XP</code> 事件日志。</li><li><code>MemoryHandler</code> 实例将消息发送到内存中的缓冲区，只要满足特定条件，缓冲区就会刷新。</li><li><code>HTTPHandler</code> 实例使用 <code>GET</code> 或 <code>POST</code> 方法将消息发送到 <code>HTTP</code> 服务器。</li><li><code>WatchedFileHandler</code> 实例会监视他们要写入日志的文件。如果文件发生更改，则会关闭该文件并使用文件名重新打开。此处理程序仅在类 <code>Unix</code> 系统上有用； <code>Windows</code> 不支持依赖的基础机制。</li><li><code>QueueHandler</code> 实例将消息发送到队列，例如在 <code>queue</code> 或 <code>multiprocessing</code> 模块中实现的队列。</li><li><code>NullHandler</code> 实例对错误消息不执行任何操作。它们由想要使用日志记录的库开发人员使用，但是想要避免如果库用户没有配置日志记录，则显示 “无法找到记录器<code>XXX</code>的消息处理器” 消息的情况。有关更多信息，请参阅 配置库的日志记录 。</li></ul><p>另外用户也可以自己实现<code>logging.Handler</code>方法，定义自己的<code>Handler</code>方法。然后在配置中引用使用即可。</p><h4 id="1-3-5-日志开关"><a href="#1-3-5-日志开关" class="headerlink" title="1.3.5 日志开关"></a>1.3.5 日志开关</h4><p>在特殊场景下，如果不需要输出日志。logging也提供响应的参数开关。例如对于定义的logger可以进行关闭，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger = logging.getLogger(<span class="string">"FileLogger"</span>)</span><br><span class="line">logger.disabled = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>这样就关闭了。如果是配置文件中，可以将<code>handlers</code>的<code>list</code>置为空，即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileLogger:</span><br><span class="line">   handlers: []</span><br><span class="line">   level: DEBUG</span><br><span class="line">   propagate: no</span><br></pre></td></tr></table></figure><p>如果需要禁用某个级别以下所有日志输出，可以使用下面的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.disable(logging.INFO)</span><br><span class="line"><span class="comment"># 禁用INFO级别以下的所有日志</span></span><br></pre></td></tr></table></figure><p>注：这个参数会限制所有的<code>logger</code>的日志输出级别。</p><h4 id="1-3-5-日志过滤器"><a href="#1-3-5-日志过滤器" class="headerlink" title="1.3.5 日志过滤器"></a>1.3.5 日志过滤器</h4><p>业务代码产生的日志通常并不是都要作为日志输出的。所以在打印日志的时候我们对每条日志紧要程度进行了量化划分等级，即<code>INFO</code>、<code>DEBUG</code> 等。但是一些特殊的需求，这种粗粒度的等级划分并不能满足需求。能否提供可编程自定义的过滤函数<code>filter(record)</code>？</p><p><code>logging</code>并没有像<code>Handler</code>一样，为用户提供丰富的<code>filter</code>工具类。建议项目组可以像<code>java</code>中日志框架 <code>logback</code>一样提供部分常用的<code>filter</code>工具类。</p><p>logging没有现成可用的<code>filter</code>工具，就需要用户自己继承实现（<code>logging.Filter</code>）。例如下面的案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoStringFilter</span><span class="params">(logging.Filter)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> record.getMessage().startswith(<span class="string">'user'</span>)</span><br><span class="line"></span><br><span class="line">logger.addFilter(NoStringFilter())</span><br></pre></td></tr></table></figure><p>定义 <code>filter</code> 方法，日志记录 record 作为唯一参数，返回值为 <code>0</code> 或 <code>False</code> 表示日志记录将被抛弃，<code>1</code> 或 <code>True</code>则表示记录别放过。</p><p>上面的案例实现了过滤<code>message</code>中以<code>user</code>开头的日志消息。对于<code>yaml</code>文件配置方式，我们在后文介绍。</p><p>另外从<code>Python3.2</code>起，用户自定义<code>filter</code>也可以不继承<code>logging.Filter</code>，只需要定义一个实现函数，<code>logger.addFilter</code>方法引入即可。例如我们在打印日志的时候，需要对于日志中一些敏感信息进行脱敏处理，例如密码信息。</p><p>下面的代码片段放在<code>__ini__.py</code>中，<code>Python</code>的模块名为：<code>logTest</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomFilter</span><span class="params">(logging.Filter)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'password'</span> <span class="keyword">in</span> record.msg:</span><br><span class="line">            record.msg = record.msg.replace(<span class="string">"password"</span>, <span class="string">"*****"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'pwd'</span> <span class="keyword">in</span> record.msg:</span><br><span class="line">            record.msg = record.msg.replace(<span class="string">"pwd"</span>, <span class="string">"*****"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>对于<code>msg</code>中的字符串进行关键字替换脱密，对于含有<code>password</code>和<code>pwd</code>的字段。</p><p>在<code>yaml</code>配置文件中配置如下，在<code>handlers</code>中<code>console</code>应用该过滤器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line"><span class="attr">    filter_pwd:</span></span><br><span class="line">      <span class="string">():</span> <span class="string">logTest.CustomFilter</span></span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line"><span class="attr">  console:</span></span><br><span class="line"><span class="attr">     class:</span> <span class="string">logging.StreamHandler</span></span><br><span class="line"><span class="attr">     level:</span> <span class="string">INFO</span></span><br><span class="line"><span class="attr">     formatter:</span> <span class="string">custom</span></span><br><span class="line"><span class="attr">     filters:</span> <span class="string">[filter_pwd]</span></span><br></pre></td></tr></table></figure><p>这样对于日志中还有相关关键字的日志将被过滤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger.error(<span class="string">"user：admin and password"</span>)</span><br><span class="line"><span class="comment"># user：admin and *****</span></span><br></pre></td></tr></table></figure><h3 id="1-4-最佳实践"><a href="#1-4-最佳实践" class="headerlink" title="1.4  最佳实践"></a>1.4  最佳实践</h3><h4 id="1-4-1-yaml配置文件"><a href="#1-4-1-yaml配置文件" class="headerlink" title="1.4.1 yaml配置文件"></a>1.4.1 <code>yaml</code>配置文件</h4><p>对于生产环境<code>Python</code>项目运行，最佳实践当然是日志相关参数需要配置化，而不是耦合在业务代码中。所以首先是日志配置参数配置文件化。通常有几种方式：<code>ini</code>格式、<code>yaml</code>格式、<code>JSON</code> 格式、<code>Python</code>文件等，建议使用<code>yaml</code>格式。</p><p>例如下面的配置文件（<code>logConfig.yaml</code>）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">disable_existing_loggers:</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">incremental:</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="attr">formatters:</span></span><br><span class="line"><span class="attr">  standard:</span></span><br><span class="line"><span class="attr">      format:</span> <span class="string">"%(asctime)s - %(levelname)s - %(name)s(%(lineno)d) - %(message)s"</span></span><br><span class="line"><span class="attr">  error:</span></span><br><span class="line"><span class="attr">    format:</span> <span class="string">"%(asctime)s-%(levelname)s &lt;PID %(process)d:%(processName)s&gt; %(name)s.%(funcName)s(): %(message)s"</span></span><br><span class="line"><span class="attr">  custom:</span></span><br><span class="line"><span class="attr">    format:</span> <span class="string">"%(asctime)s - %(hostname)s - %(hostip)s - %(levelname)s - %(name)s(%(lineno)d) - %(message)s"</span></span><br><span class="line">    <span class="string">():</span> <span class="string">logTest.CustomFormatter</span></span><br><span class="line"></span><br><span class="line"><span class="attr">filters:</span></span><br><span class="line"><span class="attr">    require_debug_false:</span></span><br><span class="line">      <span class="string">():</span> <span class="string">logTest.NoParsingFilter</span></span><br><span class="line"><span class="attr">    filter_pwd:</span></span><br><span class="line">      <span class="string">():</span> <span class="string">logTest.CustomFilter</span></span><br><span class="line"></span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line"><span class="attr">  console:</span></span><br><span class="line"><span class="attr">     class:</span> <span class="string">logging.StreamHandler</span></span><br><span class="line"><span class="attr">     level:</span> <span class="string">INFO</span></span><br><span class="line"><span class="attr">     formatter:</span> <span class="string">custom</span></span><br><span class="line"><span class="attr">     filters:</span> <span class="string">[filter_pwd]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  file:</span></span><br><span class="line"><span class="attr">     class:</span> <span class="string">logging.FileHandler</span></span><br><span class="line"><span class="attr">     filename:</span> <span class="string">./logs/logging.log</span></span><br><span class="line"><span class="attr">     level:</span> <span class="string">DEBUG</span></span><br><span class="line"><span class="attr">     formatter:</span> <span class="string">standard</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  TimedRotatingfile:</span></span><br><span class="line"><span class="attr">      class:</span> <span class="string">logging.handlers.TimedRotatingFileHandler</span></span><br><span class="line"><span class="attr">      level:</span> <span class="string">DEBUG</span></span><br><span class="line"><span class="attr">      formatter:</span> <span class="string">standard</span></span><br><span class="line"><span class="attr">      filters:</span> <span class="string">[require_debug_false]</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">M</span></span><br><span class="line"><span class="attr">      backupCount:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">      filename:</span> <span class="string">./logs/timedRotating.log</span></span><br><span class="line"><span class="attr">      encoding:</span> <span class="string">utf8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  rotatingFileHandler:</span></span><br><span class="line"><span class="attr">      class:</span> <span class="string">logging.handlers.RotatingFileHandler</span></span><br><span class="line"><span class="attr">      level:</span> <span class="string">DEBUG</span></span><br><span class="line"><span class="attr">      formatter:</span> <span class="string">standard</span></span><br><span class="line"><span class="attr">      filename:</span> <span class="string">./logs/RotatingFile.log</span></span><br><span class="line"><span class="attr">      maxBytes:</span> <span class="number">100000</span></span><br><span class="line"><span class="attr">      backupCount:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">      encoding:</span> <span class="string">utf8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">loggers:</span></span><br><span class="line"><span class="attr">  FileLogger:</span></span><br><span class="line"><span class="attr">     handlers:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">     level:</span> <span class="string">DEBUG</span></span><br><span class="line">     <span class="comment">#propagate: no</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  SampleLogger:</span></span><br><span class="line"><span class="attr">    level:</span> <span class="string">DEBUG</span></span><br><span class="line"><span class="attr">    handlers:</span> <span class="string">[console,rotatingFileHandler]</span></span><br><span class="line">    <span class="comment">#propagate: no</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  TestLogger:</span></span><br><span class="line"><span class="attr">    level:</span> <span class="string">DEBUG</span></span><br><span class="line"><span class="attr">    handlers:</span> <span class="string">[console]</span></span><br><span class="line">    <span class="comment">#propagate: no</span></span><br><span class="line"></span><br><span class="line"><span class="attr">root:</span></span><br><span class="line"><span class="attr">  level:</span> <span class="string">DEBUG</span></span><br><span class="line"><span class="attr">  handlers:</span> <span class="string">[]</span></span><br></pre></td></tr></table></figure><p>配置文件中参数说明如下：</p><ul><li><p><code>version</code>，版本参数，目前限定为1（或者1.0）；</p></li><li><p><code>disable_existing_loggers</code> ,参数值默认为True。</p><p>关于这个参数需要重点讲解一下，因为网上各类文章解释均有出入，笔者做了实验并查看了代码，解释如下。首先从字面意思来看，是否禁止已经存在的<code>loggers</code>。那么怎么理解已经存在的<code>loggers</code>？有下面的例子，我们有两个配置文件中分别定义了日志配置（<code>Config.yaml</code>和<code>logConfig.yaml</code>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'Config.yaml'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    config = yaml.safe_load(f.read())</span><br><span class="line">    logging.config.dictConfig(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'logConfig.yaml'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    config = yaml.safe_load(f.read())</span><br><span class="line">    logging.config.dictConfig(config)</span><br></pre></td></tr></table></figure><p>两个配置文件中均定义了名称为<code>TestLogger</code>的<code>loggers</code>（但是配置定义不同，例如<code>Handler</code>参数不同）。但是配置文件<code>Config.yaml</code>和<code>logConfig.yaml</code>有加载先后顺序，那么哪个<code>loggers</code>是有效的呢？</p><p>这时候配置文件<code>logConfig.yaml</code>中<code>disable_existing_loggers</code>参数值为<code>True</code>，那么旧的配置失效，否则新的配置失效。</p></li><li><p><code>incremental</code>，中文是增加的意思。是否将此配置文件解释为现有配置的增量, 默认为<code>False</code>。该参数<code>True</code>是有不明错误，暂未研究参数用途。</p></li><li><p><code>formatters</code> ，日志格式化器。可以定义多个日志格式类型，供<code>handler</code>配置使用。</p></li><li><p><code>filters</code>，日志过滤器。配置</p></li><li><p><code>handlers</code>，日志处理器。例如配置文件中我们定义了：<code>console</code>、<code>file</code>、<code>TimedRotatingfile</code>、<code>RotatingFileHandler</code>。供后续<code>loggers</code>配置使用。举个例子，其他<code>handler</code>不在展开讲了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># handler名称标签</span></span><br><span class="line"><span class="attr">TimedRotatingfile:</span></span><br><span class="line">    <span class="comment"># handler实现类，也可以配置用户自己实现的Handler方法</span></span><br><span class="line"><span class="attr">    class:</span> <span class="string">logging.handlers.TimedRotatingFileHandler</span></span><br><span class="line">    <span class="comment"># 日志过滤级别</span></span><br><span class="line"><span class="attr">    level:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="comment"># 日志格式化方式而error，配置文件中配置使用</span></span><br><span class="line"><span class="attr">    formatter:</span> <span class="string">error</span></span><br><span class="line">    <span class="comment"># 过滤器选择，配置文件中需要已配置</span></span><br><span class="line"><span class="attr">    filters:</span> <span class="string">[require_debug_false]</span></span><br><span class="line">    <span class="comment"># 日志切割时间，M为分钟切割</span></span><br><span class="line"><span class="attr">    when:</span> <span class="string">M</span></span><br><span class="line">    <span class="comment"># 日志切割保存的文件数量</span></span><br><span class="line"><span class="attr">    backupCount:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment"># 日志文件名称，注意这里的绝对路径</span></span><br><span class="line"><span class="attr">    filename:</span> <span class="string">./logs/timedRotating.log</span></span><br><span class="line">    <span class="comment"># 日志输出编码，utf8支持中文</span></span><br><span class="line"><span class="attr">    encoding:</span> <span class="string">utf8</span></span><br><span class="line">    <span class="comment"># 注意配置文件方式不支持自定义suffix值，目前只支持在代码中basicConfig配置</span></span><br><span class="line">    <span class="comment"># suffix: "%Y-%m-%d_%H-%M"</span></span><br></pre></td></tr></table></figure></li><li><p><code>loggers</code>，日志对象。配置文件中可以定义多个<code>loggers</code>。程序中使用下面方式调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger = logging.getLogger(<span class="string">"FileLogger"</span>)</span><br></pre></td></tr></table></figure><p>另外<code>logger</code>有一个重要的概念：父子<code>logger</code>。每个用户自定义的<code>logger</code>默认都是<code>root</code>的子<code>logger</code>，这时候，子<code>logger</code>的日志会发送给父级的<code>Logger</code>。当其中的参数<code>propagate</code>为<code>no</code>时候，则不再发送给父。例如下面的配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FileLogger:</span></span><br><span class="line"><span class="attr">   handlers:</span> <span class="string">[TimedRotatingfile]</span></span><br><span class="line"><span class="attr">   level:</span> <span class="string">DEBUG</span></span><br><span class="line"><span class="attr">   propagate:</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure><p>另外除了默认的<code>root</code>作为父<code>logger</code>，用户也可以自己定义，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger = logging.getLogger(<span class="string">"FileLogger.SampleLogger"</span>)</span><br></pre></td></tr></table></figure><p>这时候<code>FileLogger.SampleLogger</code>的父<code>logger</code>为<code>FileLogger</code>，并且默认<code>FileLogger</code>的父<code>logger</code>是<code>root</code>（如果有配置和定义）。即关系为：<code>FileLogger.SampleLogger----&gt;FileLogger---&gt;root</code>。</p><blockquote><p>那么对于<code>FileLogger.SampleLogger.TestLogger</code>，是否有多重父子传递呢？经过测试验证是不支持的，也就是说最多就2层。</p></blockquote></li><li><p><code>root</code>，终极父<code>logger</code>，接受所有子<code>logger</code>的日志发送，属于兜底处理。例如下面的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">root:</span></span><br><span class="line"><span class="attr">  level:</span> <span class="string">DEBUG</span></span><br><span class="line"><span class="attr">  handlers:</span> <span class="string">[]</span></span><br><span class="line">  <span class="comment"># handlers: [console]</span></span><br></pre></td></tr></table></figure><p><code>root</code>属于可选配置项。另外<code>handlers</code>配置为空，并且所有的子<code>logger</code>的<code>handlers</code>配置也为空，这时候会有默认输出，输出格式较为简单只有<code>%(message)s</code>信息。</p><p>如果一个日志对象没有指定具体的<code>logger</code>，那么就是<code>root</code>，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(logging.getLogger() == logging.root)</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>查看一下<code>root</code>的配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(logging.root.handlers)</span><br><span class="line">print(logging.lastResort)</span><br><span class="line">print(logging.root.filters)</span><br><span class="line"><span class="comment"># []</span></span><br><span class="line"><span class="comment"># &lt;_StderrHandler &lt;stderr&gt; (WARNING)&gt;</span></span><br><span class="line"><span class="comment"># []</span></span><br></pre></td></tr></table></figure><p>所以root默认的Handler是StderrHandler，并且日志级别是warning，输出到stderr（默认显示的字体是红色）。如果是shell脚本运行可以配置日志重定向：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python log.py 2&gt; /dev/null</span></span><br></pre></td></tr></table></figure><p>业务代码中如下加载配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'logConfig.yaml'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    config = yaml.safe_load(f.read())</span><br><span class="line">    logging.config.dictConfig(config)</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">"FileLogger"</span>)</span><br><span class="line">logger1 = logging.getLogger(<span class="string">"SampleLogger"</span>)</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">"debug"</span>)</span><br><span class="line">logger1.debug(<span class="string">"debug"</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-4-2-其他配置文件"><a href="#1-4-2-其他配置文件" class="headerlink" title="1.4.2 其他配置文件"></a>1.4.2 其他配置文件</h4><p>对于<code>yaml</code>文件读取，使用了<code>yaml</code>包方式先将配置文件解释成字典对象，然后再通过下面的方法解析配置信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.config.dictConfig()</span><br></pre></td></tr></table></figure><p>其实<code>logging</code>提供原生接口直接读取配置文件的解析方法（如下）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.config.fileConfig()</span><br></pre></td></tr></table></figure><p>方式该方法目前只支持<code>configparser</code>类型的文件，即下面的<code>ini</code>格式的配置文件（截取片段）：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[loggers]</span></span><br><span class="line"><span class="attr">keys</span>=root,sampleLogger</span><br><span class="line"></span><br><span class="line"><span class="section">[handlers]</span></span><br><span class="line"><span class="attr">keys</span>=consoleHandler</span><br></pre></td></tr></table></figure><p><code>fileConfig()</code>是一个较老的接口，不支持配置Filter。官方建议后续尽量使用<code>dictConfig()</code>接口，后续新功能都将增加到<code>dictConfig()</code>接口。</p><p>对于<code>json</code>文件，<code>logConfig.json</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"disable_existing_loggers"</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"formatters"</span>:&#123;</span><br><span class="line">        <span class="attr">"simple"</span>:&#123;</span><br><span class="line">            <span class="attr">"format"</span>:<span class="string">"%(asctime)s - %(name)s - %(levelname)s - %(message)s"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"handlers"</span>:&#123;</span><br><span class="line">        <span class="attr">"console"</span>:&#123;</span><br><span class="line">            <span class="attr">"class"</span>:<span class="string">"logging.StreamHandler"</span>,</span><br><span class="line">            <span class="attr">"level"</span>:<span class="string">"DEBUG"</span>,</span><br><span class="line">            <span class="attr">"formatter"</span>:<span class="string">"simple"</span>,</span><br><span class="line">            <span class="attr">"stream"</span>:<span class="string">"ext://sys.stdout"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"loggers"</span>:&#123;</span><br><span class="line">        <span class="attr">"my_module"</span>:&#123;</span><br><span class="line">            <span class="attr">"level"</span>:<span class="string">"ERROR"</span>,</span><br><span class="line">            <span class="attr">"handlers"</span>:[<span class="string">"console"</span>],</span><br><span class="line">            <span class="attr">"propagate"</span>:<span class="string">"no"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"root"</span>:&#123;</span><br><span class="line">        <span class="attr">"level"</span>:<span class="string">"INFO"</span>,</span><br><span class="line">        <span class="attr">"handlers"</span>:[<span class="string">"console"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件解析代码案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'logConfig.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    config = json.load(f)</span><br><span class="line">    logging.config.dictConfig(config)</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">"FileLogger"</span>)</span><br><span class="line">logger.debug(<span class="string">"debug"</span>)</span><br></pre></td></tr></table></figure><h3 id="1-5-线程安全和进程不安全"><a href="#1-5-线程安全和进程不安全" class="headerlink" title="1.5 线程安全和进程不安全"></a>1.5 线程安全和进程不安全</h3><h4 id="1-5-1-线程安全"><a href="#1-5-1-线程安全" class="headerlink" title="1.5.1 线程安全"></a>1.5.1 线程安全</h4><p><code>logging</code> 库是线程安全的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span><span class="params">(Filterer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level=NOTSET)</span>:</span></span><br><span class="line">        <span class="comment"># ......</span></span><br><span class="line">        self.createLock()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createLock</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Acquire a thread lock for serializing access to the underlying I/O.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.lock = threading.RLock()</span><br><span class="line">        _register_at_fork_reinit_lock(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Acquire the I/O thread lock.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.lock:</span><br><span class="line">            self.lock.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Release the I/O thread lock.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.lock:</span><br><span class="line">            self.lock.release()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Conditionally emit the specified logging record.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Emission depends on filters which may have been added to the handler.</span></span><br><span class="line"><span class="string">        Wrap the actual emission of the record with acquisition/release of</span></span><br><span class="line"><span class="string">        the I/O thread lock. Returns whether the filter passed the record for</span></span><br><span class="line"><span class="string">        emission.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rv = self.filter(record)</span><br><span class="line">        <span class="keyword">if</span> rv:</span><br><span class="line">            self.acquire()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.emit(record)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.release()</span><br><span class="line">        <span class="keyword">return</span> rv</span><br></pre></td></tr></table></figure><h4 id="1-5-2-进程安全"><a href="#1-5-2-进程安全" class="headerlink" title="1.5.2 进程安全"></a>1.5.2 进程安全</h4><h3 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h3><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、<code>Logging</code>包，链接：<a href="https://docs.python.org/3.9/library/logging.html" target="_blank" rel="noopener">https://docs.python.org/3.9/library/logging.html</a></p><p>2、日志介绍，链接：<a href="https://rmcomplexity.com/article/2020/12/01/introduction-to-python-logging.html" target="_blank" rel="noopener">https://rmcomplexity.com/article/2020/12/01/introduction-to-python-logging.html</a></p><p>3、日志介绍，链接：<a href="https://coralogix.com/blog/python-logging-best-practices-tips/" target="_blank" rel="noopener">https://coralogix.com/blog/python-logging-best-practices-tips/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://murphypei.github.io/blog/2019/09/python-
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>impala使用总结</title>
    <link href="https://zjrongxiang.github.io/2022/05/05/2022-05-11-impala%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://zjrongxiang.github.io/2022/05/05/2022-05-11-impala使用总结/</id>
    <published>2022-05-05T05:30:00.000Z</published>
    <updated>2022-05-11T07:08:08.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><ul><li>官网：<a href="http://impala.apache.org/" target="_blank" rel="noopener">http://impala.apache.org/</a></li><li>使用手册：<a href="http://impala.apache.org/docs/build/html/index.html" target="_blank" rel="noopener">http://impala.apache.org/docs/build/html/index.html</a></li><li>Sql：<a href="http://impala.apache.org/docs/build/html/topics/impala_langref_sql.html" target="_blank" rel="noopener">http://impala.apache.org/docs/build/html/topics/impala_langref_sql.html</a></li><li>窗口函数：<a href="http://impala.apache.org/docs/build/html/topics/impala_functions.html" target="_blank" rel="noopener">http://impala.apache.org/docs/build/html/topics/impala_functions.html</a></li><li>基本操作：<a href="http://impala.apache.org/docs/build/html/topics/impala_tutorial.html" target="_blank" rel="noopener">http://impala.apache.org/docs/build/html/topics/impala_tutorial.html</a></li><li>impala-shell：<a href="http://impala.apache.org/docs/build/html/topics/impala_impala_shell.html" target="_blank" rel="noopener">http://impala.apache.org/docs/build/html/topics/impala_impala_shell.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;h2 id=&quot;参考文献及资料&quot;&gt;&lt;a href=&quot;#参考文献及资料&quot; class=&quot;headerlink&quot; title=&quot;参考文献及资料&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>JDBC使用小结</title>
    <link href="https://zjrongxiang.github.io/2022/05/05/2022-05-05-JDBC%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://zjrongxiang.github.io/2022/05/05/2022-05-05-JDBC使用小结/</id>
    <published>2022-05-05T05:30:00.000Z</published>
    <updated>2022-05-05T06:27:45.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分 scope标签作用</li><li>第二部分 打包</li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>Java 数据库连接</strong>( <strong>JDBC</strong> ) 是<a href="https://en.wikipedia.org/wiki/Java_(programming_language" target="_blank" rel="noopener">Java编程语言的</a>)<a href="https://en.wikipedia.org/wiki/Application_programming_interface" target="_blank" rel="noopener">应用程序编程接口</a>(API) ，它定义了客户端如何访问<a href="https://en.wikipedia.org/wiki/Database" target="_blank" rel="noopener">数据库</a>。它是一种基于 Java 的数据访问技术，用于 Java 数据库连接。它是<a href="https://en.wikipedia.org/wiki/Oracle_Corporation" target="_blank" rel="noopener">Oracle Corporation的</a><a href="https://en.wikipedia.org/wiki/Java_Standard_Edition" target="_blank" rel="noopener">Java 标准版</a>平台的一部分。它提供了查询和更新数据库中数据的方法，面向<a href="https://en.wikipedia.org/wiki/Relational_database" target="_blank" rel="noopener">关系数据库</a>。JDBC 到<a href="https://en.wikipedia.org/wiki/ODBC" target="_blank" rel="noopener">ODBC</a>桥允许连接到<a href="https://en.wikipedia.org/wiki/Java_virtual_machine" target="_blank" rel="noopener">Java 虚拟机</a>(JVM) 主机环境中的任何 ODBC 可访问的数据源。</p><p><a href="https://en.wikipedia.org/wiki/Sun_Microsystems" target="_blank" rel="noopener">Sun Microsystems</a>于 1997 年 2 月 19 日将 JDBC 作为<a href="https://en.wikipedia.org/wiki/Java_Development_Kit" target="_blank" rel="noopener">Java 开发工具包</a>(JDK) 1.1 的一部分发布。 <a href="https://en.wikipedia.org/wiki/Java_Database_Connectivity#cite_note-1" target="_blank" rel="noopener">[1]</a> 从那时起，它就成为<a href="https://en.wikipedia.org/wiki/Java_Platform,_Standard_Edition" target="_blank" rel="noopener">Java 平台标准版</a>(Java SE) 的一部分。</p><h2 id="第一部分-实践"><a href="#第一部分-实践" class="headerlink" title="第一部分 实践"></a>第一部分 实践</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p><img src="D:\myblog\source\_posts\images\picture\JDBC\design-of-jdbc.png" alt="design-of-jdbc"></p><h3 id="1-2-各类DBMS数据库链接实践"><a href="#1-2-各类DBMS数据库链接实践" class="headerlink" title="1.2 各类DBMS数据库链接实践"></a>1.2 各类<code>DBMS</code>数据库链接实践</h3><h3 id="1-2-1-Oracle"><a href="#1-2-1-Oracle" class="headerlink" title="1.2.1 Oracle"></a>1.2.1 <code>Oracle</code></h3><p>连接驱动名：<code>oracle.jdbc.driver.OracleDriver</code></p><p>Maven坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc7<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>12.1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"oracle.jdbc.dirver.OracleDriver"</span>).newInstance();</span><br><span class="line">String url=<span class="string">"jdbc:oracle:thin:@localhost:1521:orcl"</span>;</span><br><span class="line">String user=<span class="string">"user"</span>;</span><br><span class="line">String pwd=<span class="string">"password"</span>;</span><br><span class="line">java.sql.Connection conn=DriverManager.getConnection(url,user,pwd);</span><br></pre></td></tr></table></figure><h3 id="1-2-2-Mysql"><a href="#1-2-2-Mysql" class="headerlink" title="1.2.2 Mysql"></a>1.2.2 <code>Mysql</code></h3><p>按照版本的不同，<code>Mysql</code>有两种驱动：</p><ul><li><code>Mysql 6</code>：<code>com.mysql.cj.jdbc.Driver</code></li><li><code>Mysql 5</code>：<code>com.mysql.jdbc.Driver</code></li></ul><p>Maven 坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mysql 6 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Mysql 5 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.49<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Mysql 6</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>).new Instance(); </span><br><span class="line"><span class="comment">//Mysql 5</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>).new Instance();</span><br><span class="line">String URL=<span class="string">"jdbc:mysql://localhost:3306/db_name?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false"</span>; </span><br><span class="line">String Username=<span class="string">"username"</span>;  </span><br><span class="line">String Password=<span class="string">"password"</span>;  </span><br><span class="line">java.sql.Connection con=DriverManager.getConnection(URL,Username,Password);</span><br></pre></td></tr></table></figure><h3 id="1-2-3-Sql-Server"><a href="#1-2-3-Sql-Server" class="headerlink" title="1.2.3 Sql Server"></a>1.2.3 <code>Sql Server</code></h3><p>连接驱动名：<code>com.microsoft.jdbc.sqlserver.SQLServerDriver</code></p><p>Maven:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.microsoft.sqlserver<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sqljdbc4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.microsoft.jdbc.sqlserver.SQLServerDriver"</span>).newInstance();</span><br><span class="line">String url=<span class="string">"jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=dbName"</span>;</span><br><span class="line">String user=<span class="string">"user"</span>;</span><br><span class="line">String pwd=<span class="string">"password"</span>;</span><br><span class="line">java.sql.Connection conn=DriverManager.getConnection(url,user,pwd);</span><br></pre></td></tr></table></figure><h2 id="第二部分-原理"><a href="#第二部分-原理" class="headerlink" title="第二部分 原理"></a>第二部分 原理</h2><p><a href="https://facingissuesonit.com/2018/07/22/jdbc-history-and-features-evaluations/" target="_blank" rel="noopener">https://facingissuesonit.com/2018/07/22/jdbc-history-and-features-evaluations/</a></p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、<code>JDBC</code>维基百科，链接：<a href="https://en.wikipedia.org/wiki/Java_Database_Connectivity" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Java_Database_Connectivity</a></p><p>2、<code>Java JDBC Tutorial</code>，链接：<a href="https://www.javatpoint.com/java-jdbc" target="_blank" rel="noopener">https://www.javatpoint.com/java-jdbc</a></p><p>3、<code>Open Database Connectivity</code>，链接：<a href="https://en.wikipedia.org/wiki/Open_Database_Connectivity" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Open_Database_Connectivity</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分 scope标签作用&lt;/li&gt;
&lt;li&gt;第二部分 打包&lt;/li&gt;
&lt;li&gt;参考文献及资料&lt;/li
      
    
    </summary>
    
      <category term="Maven" scheme="https://zjrongxiang.github.io/categories/Maven/"/>
    
    
  </entry>
  
  <entry>
    <title>Maven使用总结</title>
    <link href="https://zjrongxiang.github.io/2022/05/05/2022-05-05-Maven%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://zjrongxiang.github.io/2022/05/05/2022-05-05-Maven使用总结/</id>
    <published>2022-05-05T05:30:00.000Z</published>
    <updated>2022-05-05T01:55:22.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分 scope标签作用</li><li>第二部分 打包</li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://segmentfault.com/a/1190000021609439" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021609439</a></p><p><a href="https://www.cnblogs.com/lenve/p/12047793.html" target="_blank" rel="noopener">https://www.cnblogs.com/lenve/p/12047793.html</a></p><h2 id="Maven-安装部署"><a href="#Maven-安装部署" class="headerlink" title="Maven 安装部署"></a>Maven 安装部署</h2><h2 id="构建项目的主要环节"><a href="#构建项目的主要环节" class="headerlink" title="构建项目的主要环节"></a>构建项目的主要环节</h2><ul><li>clean  </li><li>validate  </li><li>compile  </li><li>test  </li><li>package  </li><li>verify  </li><li>install  </li><li>site  </li><li>deploy</li></ul><ul><li>清理（clean）：删除以前的编译结果，为重新编译做好准备</li><li>编译（compile）：将Java 源程序编译为字节码文件</li><li>测试（test）：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性</li><li>报告（）：在每一次测试后以标准的格式记录和展示测试结果</li><li>打包（package）：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web工程对应 war 包。</li><li>安装（install）：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。</li><li>部署（deploy）：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。</li></ul><h2 id="Maven核心概念"><a href="#Maven核心概念" class="headerlink" title="Maven核心概念"></a>Maven核心概念</h2><p>Maven 能够实现自动化构建是和它的内部原理分不开的，这里我们从 Maven 的九个核心概念入手， 看看 Maven 是如何实现自动化构建的</p><ul><li>POM</li><li>约定的目录结构</li><li>坐标</li><li>依赖管理</li><li>仓库管理</li><li>生命周期</li><li>插件和目标</li><li>继承</li><li>聚合</li></ul><p><strong>Maven 的核心程序中仅仅定义了抽象的生命周期，而具体的操作则是由 Maven 的插件来完成的</strong>。可是 Maven 的插件并不包含在 Maven 的核心程序中，在首次使用时需要联网下载。 下载得到的插件会被保存到本地仓库中。本地仓库默认的位置是：~.m2repository。</p><h3 id="5-1-Maven约定的工程目录："><a href="#5-1-Maven约定的工程目录：" class="headerlink" title="5.1. Maven约定的工程目录："></a>5.1. Maven约定的工程目录：</h3><p><img src="https://segmentfault.com/img/remote/1460000021609443" alt="maven-project.png"></p><p>Java开发领域普遍认同的一个观点：<strong>约定&gt;配置&gt;编码</strong>（能用配置解决的问题就不编码，能基于约定的就不配置）</p><h3 id="5-2-POM"><a href="#5-2-POM" class="headerlink" title="5.2. POM"></a>5.2. POM</h3><p><strong>Project Object Model：项目对象模型</strong>。将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。</p><p>Maven 工程的核心配置。</p><h3 id="5-3-坐标"><a href="#5-3-坐标" class="headerlink" title="5.3. 坐标"></a>5.3. 坐标</h3><ul><li>Maven 的坐标 使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程。</li><li><ul><li>groupid：公司或组织的域名倒序+当前项目名称</li><li>artifactId：当前项目的模块名称</li><li>version：当前模块的版本</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.lazyegg.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>如何通过坐标到仓库中查找 jar 包？</p><ul><li>将 gav 三个向量连起来</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">net</span>.lazyegg.maven+Hello+0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><ul><li><p>以连起来的字符串作为目录结构到仓库中查找</p><p>net/lazyegg/maven/Hello/0.0.1-SNAPSHOT/Hello-0.0.1-SNAPSHOT.jar</p></li></ul></li></ul><p>※ 注意：我们自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：<strong>mvn install</strong></p><h3 id="5-4-依赖"><a href="#5-4-依赖" class="headerlink" title="5.4. 依赖"></a>5.4. 依赖</h3><p>Maven 中最关键的部分，我们使用 Maven 最主要的就是使用它的依赖管理功能。要理解和掌握 Maven 的依赖管理，我们只需要解决以下几个问题：</p><h5 id="①-依赖的目的是什么"><a href="#①-依赖的目的是什么" class="headerlink" title="① 依赖的目的是什么"></a>① 依赖的目的是什么</h5><p>当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖，这是概念上的描述。那么如何在项目中以依赖的方式引入一个我们需要的 jar 包呢？ 答案非常简单，就是使用 <code>dependency</code> 标签指定被依赖 jar 包的坐标就可以了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.lazyegg.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="②-依赖的范围"><a href="#②-依赖的范围" class="headerlink" title="② 依赖的范围"></a>② 依赖的范围</h5><p>有时依赖信息中除了目标 jar 包的坐标还有一个 scope 设置，这就是依赖的范围。依赖的范围有几个可选值，常用的有：compile、test、provided 三个，当然还有不常用的 runtime、system..</p><ul><li><strong>compile</strong>：<strong>默认范围</strong>，编译测试运行都有效</li><li><strong>provided</strong>：在编译和测试时有效</li><li><strong>runtime</strong>：在测试和运行时有效</li><li><strong>test：</strong>只在测试时有效</li><li><strong>system</strong>：在编译和测试时有效，与本机系统关联，可移植性差</li><li>常用依赖范围有效性总结</li></ul><table><thead><tr><th></th><th>compile</th><th>test</th><th>provided</th></tr></thead><tbody><tr><td>主程序</td><td>√</td><td>×</td><td>√</td></tr><tr><td>测试程序</td><td>√</td><td>√</td><td>√</td></tr><tr><td>参与部署</td><td>√</td><td>×</td><td>×</td></tr></tbody></table><h5 id="③-依赖的传递性"><a href="#③-依赖的传递性" class="headerlink" title="③ 依赖的传递性"></a>③ 依赖的传递性</h5><p>A 依赖 B，B 依赖 C，A 能否使用 C 呢？那要看 B 依赖 C 的范围是不是 compile，如果是则可用，否则不可用。</p><h5 id="④-依赖的排除"><a href="#④-依赖的排除" class="headerlink" title="④ 依赖的排除"></a>④ 依赖的排除</h5><p>如果我们在当前工程中引入了一个依赖是 A，而 A 又依赖了 B，那么 Maven 会自动将 A 依赖的 B 引入当 前工程，但是个别情况下 B 有可能是一个不稳定版，或对当前工程有不良影响。这时我们可以在引入 A 的时候将 B 排除。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.lazyegg.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="⑤-统一管理所依赖-jar-包的版本，对同一个框架的一组-jar-包最好使用相同的版本。为了方便升级框架，可以将-jar-包的版本信息统一提取出来"><a href="#⑤-统一管理所依赖-jar-包的版本，对同一个框架的一组-jar-包最好使用相同的版本。为了方便升级框架，可以将-jar-包的版本信息统一提取出来" class="headerlink" title="⑤ 统一管理所依赖 jar 包的版本，对同一个框架的一组 jar 包最好使用相同的版本。为了方便升级框架，可以将 jar 包的版本信息统一提取出来"></a>⑤ 统一管理所依赖 jar 包的版本，对同一个框架的一组 jar 包最好使用相同的版本。为了方便升级框架，可以将 jar 包的版本信息统一提取出来</h5><ul><li>统一声明版本号</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">starfish.spring.version</span>&gt;</span>4.1.1.RELEASE<span class="tag">&lt;/<span class="name">starfish.spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>引用前面声明的版本号</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;starfish.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="⑥-依赖的原则：解决-jar-包冲突"><a href="#⑥-依赖的原则：解决-jar-包冲突" class="headerlink" title="⑥ 依赖的原则：解决 jar 包冲突"></a>⑥ 依赖的原则：解决 jar 包冲突</h5><ul><li>路径最短者优先</li><li>路径相同时先声明者优先</li></ul><p>项目版本冲突时候的那种蛋疼的感觉，只有疼过的才知道，所以，我们来看看疼过的人是怎么解决的，推荐一个IDEA插件，Maven Helper，比自带的好用，一目了然</p><p><img src="https://segmentfault.com/img/remote/1460000021609445" alt="maven-helper.png"></p><h3 id="5-5-仓库"><a href="#5-5-仓库" class="headerlink" title="5.5. 仓库"></a>5.5. 仓库</h3><ul><li>分类<ul><li>本地仓库：为当前本机电脑上的所有 Maven 工程服务</li><li>远程仓库<ul><li><strong>私服</strong>：架设在当前局域网环境下，为当前局域网范围内的所有 Maven 工程服务</li><li><strong>中央仓库</strong>：架设在 Internet 上，为全世界所有 Maven 工程服务</li><li><strong>中央仓库的镜像</strong>：架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求，比如阿里的镜像</li></ul></li></ul></li><li>仓库中的文件<ul><li>Maven 的插件</li><li>我们自己开发的项目的模块</li><li>第三方框架或工具的 jar 包</li></ul></li></ul><p>※ 不管是什么样的 jar 包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖，查询地址：<a href="https://link.segmentfault.com/?enc=Qhd%2BlYKRAwXR9x37URpGjQ%3D%3D.Mthm2dJVBm1FGe%2Bm5IjVzNWB3bHjxY8FzETynx0Zdgc%3D" target="_blank" rel="noopener">http://mvnrepository.com/</a></p><h3 id="5-6-生命周期"><a href="#5-6-生命周期" class="headerlink" title="5.6. 生命周期"></a>5.6. 生命周期</h3><h4 id="5-6-1-什么是-Maven-的生命周期？"><a href="#5-6-1-什么是-Maven-的生命周期？" class="headerlink" title="5.6.1. 什么是 Maven 的生命周期？"></a>5.6.1. 什么是 Maven 的生命周期？</h4><p>Maven 生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。</p><p>Maven 有三套相互独立的生命周期，分别是：</p><ul><li><strong>Clean Lifecycle</strong> 在进行真正的构建之前进行一些清理工作</li><li><strong>Default Lifecycle</strong> 构建的核心部分，编译，测试，打包，安装，部署等等</li><li><strong>Site Lifecycle</strong> 生成项目报告，站点，发布站点</li></ul><p>它们是相互独立的，你可以仅仅调用 clean 来清理工作目录，仅仅调用 site 来生成站点。当然你也可以直接运行 <strong>mvn clean install site</strong> 运行所有这三套生命周期。 每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比 如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。</p><h4 id="5-6-2-Clean-生命周期"><a href="#5-6-2-Clean-生命周期" class="headerlink" title="5.6.2. Clean 生命周期"></a>5.6.2. Clean 生命周期</h4><p>Clean 生命周期一共包含了三个阶段：</p><ul><li>pre-clean 执行一些需要在 clean 之前完成的工作</li><li>clean 移除所有上一次构建生成的文件</li><li>post-clean 执行一些需要在 clean 之后立刻完成的工作</li></ul><h4 id="5-6-3-Site-生命周期"><a href="#5-6-3-Site-生命周期" class="headerlink" title="5.6.3. Site 生命周期"></a>5.6.3. Site 生命周期</h4><ul><li>pre-site 执行一些需要在生成站点文档之前完成的工作</li><li>site 生成项目的站点文档</li><li>post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li><li>site-deploy 将生成的站点文档部署到特定的服务器上 这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大 的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。</li></ul><h4 id="5-6-4-Default-生命周期"><a href="#5-6-4-Default-生命周期" class="headerlink" title="5.6.4. Default 生命周期"></a>5.6.4. Default 生命周期</h4><p>Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中（列出一些重要阶段）</p><ul><li>validate：验证工程是否正确，所有需要的资源是否可用。</li><li>compile：编译项目的源代码。</li><li>test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。</li><li>package：把已编译的代码打包成可发布的格式，比如 jar、war 等。</li><li>integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。</li><li>verify：运行所有检查，验证包是否有效且达到质量标准。</li><li>install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。</li><li>deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享</li></ul><h4 id="5-6-5-生命周期与自动化构建"><a href="#5-6-5-生命周期与自动化构建" class="headerlink" title="5.6.5. 生命周期与自动化构建"></a>5.6.5. 生命周期与自动化构建</h4><p><strong>运行任何一个阶段的时候，它前面的所有阶段都会被运行</strong>，例如我们运行 mvn install 的时候，代码会被编译，测试，打包。这就是 Maven 为什么能够自动执行构建过程的各个环节的原因。此外，Maven 的插件机制是完全依赖 Maven 的生命周期的，因此理解生命周期至关重要。</p><h3 id="5-7-插件和目标"><a href="#5-7-插件和目标" class="headerlink" title="5.7. 插件和目标"></a>5.7. 插件和目标</h3><ul><li><p>Maven 的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的</p></li><li><p>每个插件都能实现多个功能，每个功能就是一个插件目标</p></li><li><p>Maven 的生命周期与插件目标相互绑定，以完成某个具体的构建任务</p><p>例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标</p></li></ul><h3 id="5-8-继承"><a href="#5-8-继承" class="headerlink" title="5.8. 继承"></a>5.8. 继承</h3><ul><li><p>为什么需要继承机制？</p><p>由于非 compile 范围的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置</p></li><li><p>创建父工程 创建父工程和创建一般的 Java 工程操作一致，唯一需要注意的是：打包方式处要设置为 pom</p></li><li><p>在子工程中引用父工程 ，从当前目录到父项目的 pom.xml 文件的相对路径</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.starfish.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 以当前文件为基准的父工程pom.xml文件的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时如果子工程的 groupId 和 version 如果和父工程重复则可以删除。</p><ul><li>在父工程中管理依赖 将 Parent 项目中的 dependencies 标签，用 <strong>dependencyManagement</strong> 标签括起来</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在子项目中重新指定需要的依赖，删除范围和版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-9-聚合"><a href="#5-9-聚合" class="headerlink" title="5.9. 聚合"></a>5.9. 聚合</h3><ul><li>为什么要使用聚合？</li></ul><p>将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进 行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。</p><p>如何配置聚合？ 在总的聚合工程中使用 modules/module 标签组合，指定模块工程的相对路径即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置聚合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定各个子工程的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>starfish-learn-grpc<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>starfish-learn-kafka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>starfish-web-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、Maven官网，链接：<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html" target="_blank" rel="noopener">https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html</a></p><p>2、Maven依赖访问，链接：<a href="https://www.baeldung.com/maven-dependency-scopes" target="_blank" rel="noopener">https://www.baeldung.com/maven-dependency-scopes</a></p><p>2、案例，链接：<a href="https://stackoverflow.com/questions/7070570/can-a-program-depend-on-a-library-during-compilation-but-not-runtime/59964828#59964828" target="_blank" rel="noopener">https://stackoverflow.com/questions/7070570/can-a-program-depend-on-a-library-during-compilation-but-not-runtime/59964828#59964828</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分 scope标签作用&lt;/li&gt;
&lt;li&gt;第二部分 打包&lt;/li&gt;
&lt;li&gt;参考文献及资料&lt;/li
      
    
    </summary>
    
      <category term="Maven" scheme="https://zjrongxiang.github.io/categories/Maven/"/>
    
    
  </entry>
  
  <entry>
    <title>Maven中scope标签使用总结</title>
    <link href="https://zjrongxiang.github.io/2022/04/28/2022-04-28-Maven%E4%B8%ADscope%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://zjrongxiang.github.io/2022/04/28/2022-04-28-Maven中scope参数使用总结/</id>
    <published>2022-04-28T05:30:00.000Z</published>
    <updated>2022-05-05T01:00:57.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分 scope标签作用</li><li>第二部分 打包</li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们在使用<code>Maven</code>管理包依赖的时候，经常看到下面的配置（一个<code>Flink Java</code>项目的<code>pom</code>文件片段）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-api-java-bridge_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>&lt;scope&gt;provided&lt;/scope&gt;</code>标签参数是什么含义呢？</p><p>我们在编码过程通常有：程序测试、程序运行、程序编译等阶段，不同阶段依赖的包并不完全相同。即依赖包是有依赖作用范围的。最直观的例子是我们经常使用的测试依赖包<code>junit</code>，我们只在测试阶段会使用。所以限定依赖包的生效范围为：<code>test</code>，参考下面的配置方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们将详细展开讲解。</p><h2 id="第一部分-scope标签作用"><a href="#第一部分-scope标签作用" class="headerlink" title="第一部分 scope标签作用"></a>第一部分 scope标签作用</h2><h3 id="1-1-六种依赖范围"><a href="#1-1-六种依赖范围" class="headerlink" title="1.1 六种依赖范围"></a>1.1 六种依赖范围</h3><p>通过背景介绍，我们知道<code>Maven</code>中将使用 <code>scope</code> 标签参数来配置依赖包的依赖范围。<code>scope</code> 主要是用在 <code>pom.xml</code> 文件中的依赖定义部分。常见的可选值有<code>compile, provided, runtime, test, system</code>，一共6个。</p><ul><li><p><strong>compile</strong><br>这是默认参数，如果用户没有指定时，<code>scope</code>标签值为<code>compile</code>。编译依赖项在项目的编译、运行、测试所有阶段均有效。是一个比较强的依赖。打包的时候通常包含进去。</p></li><li><p><strong>provided</strong><br>这很像<code>compile</code>，但表示您希望 JDK 或容器在运行时提供依赖项。例如，在为 Java 企业版构建 Web 应用程序时，您可以将 Servlet API 和相关 Java EE API 的依赖设置为范围<code>provided</code>，因为 Web 容器提供了这些类。具有此范围的依赖项被添加到用于编译和测试的类路径中，而不是运行时类路径中。它不是传递的。</p><p>provided意味着打包的时候可以不用包进去，别的设施(Web Container)会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包阶段做了exclude的动作。</p></li><li><p><strong>runtime</strong></p><p>classpaths</p><p>这个范围表示编译时不需要依赖，但测试和运行有效。Maven在运行时和测试类路径中包含具有此范围的依赖项，但不包括编译类路径。</p><p>runntime表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过编译而已，说实话在终端的项目（非开源，企业内部系统）中，和compile区别不是很大。比较常见的如JSR×××的实现，对应的API jar是compile的，具体实现是runtime的，compile只需要知道接口就足够了。oracle jdbc驱动架包就是一个很好的例子，一般scope为runntime。另外runntime的依赖通常和optional搭配使用，optional为true。我可以用A实现，也可以用B实现。</p><p>范围是为了<code>runtime</code>防止程序员在代码中向实现库添加直接依赖项，而不是使用抽象或外观。</p><p>换句话说，它强制使用接口。</p><p>具体例子：</p><p>1）您的团队正在使用 SLF4J 而不是 Log4j。您希望您的程序员使用 SLF4J API，而不是 Log4j。Log4j 仅供 SLF4J 在内部使用。解决方案：</p><ul><li>将 SLF4J 定义为常规编译时依赖项</li><li>将 log4j-core 和 log4j-api 定义为运行时依赖项。</li></ul></li></ul><p>  2) 您的应用程序正在使用 JDBC 访问 MySQL。您希望您的程序员针对标准 JDBC 抽象进行编码，而不是直接针对 MySQL 驱动程序实现。</p><ul><li><p><code>mysql-connector-java</code>将（MySQL JDBC 驱动程序）定义为运行时依赖项。</p><p>运行时依赖项在编译期间被隐藏（如果您的代码对它们具有“直接”依赖关系，则会引发编译时错误），但在执行期间和创建可部署工件（WAR 文件、SHADED jar 文件等）时包含在内。</p></li></ul>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- From Log4j 2.x API to Log4j 2.x Core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.17.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- For DataBase connection --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>test</strong><br>这个范围表示应用程序的正常使用不需要依赖，只在测试编译和执行阶段可用。这个范围不是传递的。通常，此范围用于测试库，例如 JUnit 和 Mockito。如果这些库用于单元测试 (src/test/java) 但不在模型代码 (src/main/java) 中，它也用于非测试库，例如 Apache Commons IO。</p><p>scope为test表示依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。比较典型的如junit。</p></li></ul><ul><li><p><strong>system</strong><br>范围类似于<code>provided</code>，除了你必须提供明确包含它的 JAR 之外。工件始终可用，不会在存储库中查找。</p><p>从参与度来说，也provided相同，不过被依赖项不会从maven仓库抓，而是从本地文件系统拿，一定需要配合systemPath属性使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.sql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdbc-stdext<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/lib/rt.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>import</strong>（only available in Maven 2.0.9 or later）</p><p>此范围仅受该部分中类型的依赖项支持。它表示依赖项将被指定 POM部分中的有效依赖项列表替换。由于它们被替换，范围为 的依赖项实际上并不参与限制依赖项的传递性。<code>pom`</code><dependencymanagement><code>&lt;dependencyManagement&gt;</code>import`</dependencymanagement></p></li></ul><p>test<br>scope为test表示依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。比较典型的如junit。</p><p>runntime<br>runntime表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过编译而已，说实话在终端的项目（非开源，企业内部系统）中，和compile区别不是很大。比较常见的如JSR×××的实现，对应的API jar是compile的，具体实现是runtime的，compile只需要知道接口就足够了。oracle jdbc驱动架包就是一个很好的例子，一般scope为runntime。另外runntime的依赖通常和optional搭配使用，optional为true。我可以用A实现，也可以用B实现。</p><p>provided<br>provided意味着打包的时候可以不用包进去，别的设施(Web Container)会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包阶段做了exclude的动作。</p><p>system<br>从参与度来说，也provided相同，不过被依赖项不会从maven仓库抓，而是从本地文件系统拿，一定需要配合systemPath属性使用。</p><h3 id="1-2-小结"><a href="#1-2-小结" class="headerlink" title="1.2 小结"></a>1.2 小结</h3><table><thead><tr><th style="text-align:center">scope取值</th><th style="text-align:left">编译</th><th>测试</th><th>运行</th><th style="text-align:left">依赖传递</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:center"><strong>compile</strong></td><td style="text-align:left">✓</td><td>✓</td><td>✓</td><td style="text-align:left">是</td><td style="text-align:left"><code>spring-core</code>、<code>log4j</code></td></tr><tr><td style="text-align:center"><strong>provided</strong></td><td style="text-align:left">✓</td><td>✓</td><td></td><td style="text-align:left">否</td><td style="text-align:left"><code>servlet-api</code></td></tr><tr><td style="text-align:center"><strong>runtime</strong></td><td style="text-align:left"></td><td></td><td>✓</td><td style="text-align:left">是</td><td style="text-align:left"><code>JDBC-driver</code></td></tr><tr><td style="text-align:center"><strong>test</strong></td><td style="text-align:left"></td><td>✓</td><td></td><td style="text-align:left">否</td><td style="text-align:left"><code>junit</code></td></tr><tr><td style="text-align:center"><strong>system</strong></td><td style="text-align:left">✓</td><td>✓</td><td></td><td style="text-align:left">是</td><td style="text-align:left">非<code>Maven</code>仓库且本地</td></tr></tbody></table><h3 id="1-3-依赖传递"><a href="#1-3-依赖传递" class="headerlink" title="1.3 依赖传递"></a>1.3 依赖传递</h3><p>Maven中依赖包本身具有依赖链关系。例如：项目A—(依赖)–&gt;<code>B.jar</code>—(依赖)–&gt;<code>C.jar</code>，当前A项目的<code>pom</code>文件中引用的<code>B.jar</code>，并且<code>B.jar</code>依赖包的<code>scope</code>的标签属性已知。那么<code>C.jar</code>在项目A中的依赖怎么确定呢？</p><table><thead><tr><th>初始项目scope值</th><th>compile</th><th>provided</th><th>runtime</th><th>test</th></tr></thead><tbody><tr><td>compile</td><td>compile(*)</td><td>-</td><td>runtime</td><td>-</td></tr><tr><td>provided</td><td>provided</td><td>-</td><td>provided</td><td>-</td></tr><tr><td>runtime</td><td>runtime</td><td>-</td><td>runtime</td><td>-</td></tr><tr><td>test</td><td>test</td><td>-</td><td>test</td><td>-</td></tr></tbody></table><p>scope的依赖传递<br>A–&gt;B–&gt;C。当前项目为A，A依赖于B，B依赖于C。知道B在A项目中的scope，那么怎么知道C在A中的scope呢？答案是：<br>当C是test或者provided时，C直接被丢弃，A不依赖C；<br>否则A依赖C，C的scope继承于B的scope。</p><p>每个范围（除了<code>import</code>）以不同的方式影响传递依赖关系，如下表所示。如果将依赖项设置为左列中的范围，则该依赖项的传递依赖项具有跨顶行的范围会导致主项目中的依赖项具有交叉点列出的范围。如果没有列出范围，则意味着省略了依赖项。</p><h2 id="第二部分-打包"><a href="#第二部分-打包" class="headerlink" title="第二部分 打包"></a>第二部分 打包</h2><h3 id="2-1-打包范围"><a href="#2-1-打包范围" class="headerlink" title="2.1 打包范围"></a>2.1 打包范围</h3><p>在<code>Java</code>项目完成开发后，我们最终会把项目打包成<code>jar</code>后部署在生产运行。对于项目中依赖的jar包可能在项目运行的<code>classpath</code>（部署服务器环境）中了。特别常见就是对于大数开发（<code>MapReduce</code>、<code>Spark</code>、<code>Flink</code>）中，很多依赖包已经在客户端<code>lib</code>目录中了，无需重复将依赖包重复打入应用包中，甚至造成包冲突。</p><p>对于不用打包至应用包的依赖包我们配置<code>scope</code>标签为<code>provided</code>（即目标服务器已经提供了）。</p><ul><li><p><strong>compile</strong></p><p>在开发项目的<code>classpath</code>（编译环境）和打包时候都有效。</p></li><li><p><strong>provided</strong></p><p>表示该依赖包已经由目标服务器环境（<code>hadoop</code>）、容器（如<code>tomcat</code>的<code>libs</code>目录）和<code>JDK</code>提供。只在编译的<code>classpath</code>中加载和使用，打包的时候不会包含在项目目标包中。</p></li><li><p><strong>runtime</strong></p><p>一般是运行和测试环境使用，编译时候不用加入classpath，打包时候会打包到目标包中。一般是通过动态加载或接口反射加载的情况比较多。也就是说程序只使用了接口，具体的时候可能有多个，运行时通过配置文件或jar包扫描动态加载的情况。典型的包括：JDBC驱动等。 </p></li><li><p><strong>test</strong></p><p>单元测试场景使用。在编译环境加入<code>classpath</code>，但打包时不会加入。</p></li><li><p><strong>system</strong></p><p>不会打包至项目目标包。如果需要本地的依赖包，需要将该包注册制本地镜像库。然后再使用<code>compile</code>打包至项目目标包。</p></li></ul><h3 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h3><p>对于上面的分析总结成表格如下：</p><table><thead><tr><th>scope标签值</th><th>打包情况（是否打入项目包）</th></tr></thead><tbody><tr><td><strong>compile</strong></td><td>是。打包环境有效，依赖包打包至项目包</td></tr><tr><td><strong>provided</strong></td><td>否。打包环境无效，不会打包至项目包</td></tr><tr><td><strong>runtime</strong></td><td>是。打包环境有效，依赖包打包至项目包</td></tr><tr><td><strong>test</strong></td><td>否。打包环境无效，不会打包至项目包</td></tr><tr><td><strong>system</strong></td><td>否。打包环境无效，不会打包至项目包</td></tr></tbody></table><h2 id="第三部分-总结"><a href="#第三部分-总结" class="headerlink" title="第三部分 总结"></a>第三部分 总结</h2><p><a href="https://segmentfault.com/a/1190000019266080" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019266080</a></p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、Maven官网，链接：<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html" target="_blank" rel="noopener">https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html</a></p><p>2、Maven依赖访问，链接：<a href="https://www.baeldung.com/maven-dependency-scopes" target="_blank" rel="noopener">https://www.baeldung.com/maven-dependency-scopes</a></p><p>2、案例，链接：<a href="https://stackoverflow.com/questions/7070570/can-a-program-depend-on-a-library-during-compilation-but-not-runtime/59964828#59964828" target="_blank" rel="noopener">https://stackoverflow.com/questions/7070570/can-a-program-depend-on-a-library-during-compilation-but-not-runtime/59964828#59964828</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分 scope标签作用&lt;/li&gt;
&lt;li&gt;第二部分 打包&lt;/li&gt;
&lt;li&gt;参考文献及资料&lt;/li
      
    
    </summary>
    
      <category term="Maven" scheme="https://zjrongxiang.github.io/categories/Maven/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink CDC实现实时数仓</title>
    <link href="https://zjrongxiang.github.io/2022/04/26/2022-04-26-%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93%EF%BC%88Flink%20CDC%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
    <id>https://zjrongxiang.github.io/2022/04/26/2022-04-26-实时数仓（Flink CDC实现）/</id>
    <published>2022-04-26T05:30:00.000Z</published>
    <updated>2022-05-12T12:29:13.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分 Spark内存管理详解</li><li>第二部分 Spark参数说明</li><li>第三部分 Spark内存优化</li><li>第四部分 常见线上问题解决</li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Flink 1.11 引入了 Flink SQL CDC，由阿里巴巴技术专家伍翀 (云邪）个人兴趣项目孵化而来。从最开始支持Mysql到现在支持各类数据库，具体见项目说明。</p><p>关于Flink CDC的原理介绍可以参考Flink中文社区文章介绍。本位以Mysql为例详细介绍实际使用，供大家参考。</p><p>实验环境：</p><ul><li>os:ubuntu 16.4</li><li></li></ul><h2 id="第一部分-环境准备"><a href="#第一部分-环境准备" class="headerlink" title="第一部分 环境准备"></a>第一部分 环境准备</h2><p>目前对于Mysql版本支持如下：</p><table><thead><tr><th>Connector</th><th>Database</th><th>Driver</th></tr></thead><tbody><tr><td><a href="https://ververica.github.io/flink-cdc-connectors/master/content/connectors/mysql-cdc.html#" target="_blank" rel="noopener">mysql-cdc</a></td><td><a href="https://dev.mysql.com/doc" target="_blank" rel="noopener">MySQL</a>: 5.6, 5.7, 8.0.x<a href="https://www.aliyun.com/product/rds/mysql" target="_blank" rel="noopener">RDS MySQL</a>: 5.6, 5.7, 8.0.x<a href="https://www.aliyun.com/product/polardb" target="_blank" rel="noopener">PolarDB MySQL</a>: 5.6, 5.7, 8.0.x<a href="https://aws.amazon.com/cn/rds/aurora" target="_blank" rel="noopener">Aurora MySQL</a>: 5.6, 5.7, 8.0.x<a href="https://mariadb.org/" target="_blank" rel="noopener">MariaDB</a>: 10.x<a href="https://github.com/ApsaraDB/galaxysql" target="_blank" rel="noopener">PolarDB X</a>: 2.0.1</td><td>JDBC Driver: 8.0.2</td></tr></tbody></table><h3 id="1-1-Mysql开启binlog日志"><a href="#1-1-Mysql开启binlog日志" class="headerlink" title="1.1 Mysql开启binlog日志"></a>1.1 <code>Mysql</code>开启<code>binlog</code>日志</h3><p>检查Mysql数据库是否开启<code>binlog</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%log_bin%'</span></span><br></pre></td></tr></table></figure><p>如果回显如下，说明已经开启：</p><table><thead><tr><th>变量名</th><th>变量值</th></tr></thead><tbody><tr><td>log_bin</td><td>ON</td></tr><tr><td>log_bin_basename</td><td>/var/lib/mysql/mysql-bin</td></tr><tr><td>log_bin_index</td><td>/var/lib/mysql/mysql-bin.index</td></tr><tr><td>log_bin_trust_function_creators</td><td>OFF</td></tr><tr><td>log_bin_use_v1_row_events</td><td>OFF</td></tr><tr><td>sql_log_bin</td><td>ON</td></tr></tbody></table><p>如果没有开启，修改<code>my.cnf</code>配置文件增加下面的参数配置（重启生效）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启binlog日志，binlog格式必须设置成：ROW模式</span></span><br><span class="line">log_bin=/var/lib/mysql/mysql-bin</span><br><span class="line">binlog-format=ROW</span><br></pre></td></tr></table></figure><p>进一步还可以通过下面的命令查看<code>binlog</code>日志文件:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="built_in">BINARY</span> <span class="keyword">LOGS</span>;</span><br></pre></td></tr></table></figure><p>回显如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Log_name, File_size</span><br><span class="line">mysql-bin.00000313979</span><br><span class="line">mysql-bin.000004177</span><br><span class="line">mysql-bin.000005872</span><br></pre></td></tr></table></figure><p>还使用<code>show binlog events</code>命令，查看<code>binlog</code>日志事件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Log_name, Pos, Event_type, Server_id, End_log_pos, Info</span><br><span class="line">'mysql-bin.000003', '742', 'Anonymous_Gtid', '223344', '807', 'SET @@SESSION.GTID_NEXT= \'ANONYMOUS\''</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 字段说明：</span></span><br><span class="line">log_name：指定要查询的binlog文件名(不指定就是第一个binlog文件)</span><br></pre></td></tr></table></figure><h3 id="1-2-为CDC创建专用用户"><a href="#1-2-为CDC创建专用用户" class="headerlink" title="1.2 为CDC创建专用用户"></a>1.2 为CDC创建专用用户</h3><p><code>Flink CDC</code> 使用 <code>Debezium</code> 同步<code>Mysql</code>，所以用户权限需要满足<code>Debezium</code>组件要求。</p><ul><li>Create the MySQL user（ex：FlinkCdc）:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE USER <span class="string">'FlinkCdc'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'password'</span>;</span></span><br></pre></td></tr></table></figure><ul><li>Grant the required permissions to the user:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT SELECT, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class="string">'FlinkCdc'</span> IDENTIFIED BY <span class="string">'password'</span>;</span></span><br></pre></td></tr></table></figure><p><strong>注:</strong> The RELOAD permissions is not required any more when <code>scan.incremental.snapshot.enabled</code> is enabled (enabled by default).</p><table><thead><tr><th style="text-align:left">Keyword</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><code>SELECT</code></td><td style="text-align:left"><code>SELECT</code>查询权限。只被用在初始化阶段。</td></tr><tr><td style="text-align:left"><code>RELOAD</code></td><td style="text-align:left">执行 <code>FLUSH</code> 语句清除重新加载内部缓存。只被用在初始化阶段。</td></tr><tr><td style="text-align:left"><code>SHOW DATABASES</code></td><td style="text-align:left">执行 <code>SHOW DATABASE</code> 语句。只被用在初始化阶段。</td></tr><tr><td style="text-align:left"><code>REPLICATION SLAVE</code></td><td style="text-align:left">读取MySQL binlog。</td></tr><tr><td style="text-align:left"><code>REPLICATION CLIENT</code></td><td style="text-align:left">执行<code>SHOW MASTER STATUS</code>、<code>SHOW SLAVE STATUS</code>、<code>SHOW BINARY LOGS</code>等语句。</td></tr></tbody></table><ul><li>生效权限:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> FLUSH PRIVILEGES;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-注意事项"><a href="#1-3-注意事项" class="headerlink" title="1.3 注意事项"></a>1.3 注意事项</h3><h4 id="1-3-1-service-id"><a href="#1-3-1-service-id" class="headerlink" title="1.3.1 service id"></a>1.3.1 service id</h4><p>原因：MySQL binlog 数据同步的原理是，CDC source 会伪装成 MySQL 集群的一个 slave（使用指定的 server id 作为唯一 id），然后从 MySQL 拉取 binlog 数据。如果一个 MySQL 集群中有多个 slave 有同样的 id，就会导致拉取数据错乱的问题。<br>解决方法：默认会随机生成一个 server id，容易有碰撞的风险。所以建议使用动态参数（table hint）在 query 中覆盖 server id。如下所示：<br>SELECT <em><br>FROM bill_info /</em>+ OPTIONS(‘server-id’=’123456’) */ ;</p><p>每个作业需显式配置不同的SERVER ID<br>每个同步数据库数据的客户端，都会有一个唯一ID，即SERVER ID。MySQL SERVER会根据该ID来维护网络连接以及Binlog位点。因此如果有大量不同的SERVER ID的客户端一起连接MySQL SERVER，可能导致MySQL SERVER的CPU陡增，影响线上业务稳定性。此外，多个作业共享相同的SERVER ID，会导致Binlog位点错乱，多读或少读数据。因此建议您通过动态Hints，在每个CDC作业都配置上不同的SERVER ID，例如SELECT <em> FROM source_table /</em>+ OPTIONS(‘server-id’=’123456’) */ ;。动态Hints详情请参见动态Hints</p><h4 id="1-3-2-session-超时"><a href="#1-3-2-session-超时" class="headerlink" title="1.3.2 session 超时"></a>1.3.2 session 超时</h4><h2 id="第二部分-实践案例"><a href="#第二部分-实践案例" class="headerlink" title="第二部分 实践案例"></a>第二部分 实践案例</h2><h3 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h3><ul><li><p>snapshot.mode</p><p>Debezium 支持五种模式:</p><ol><li><code>initial</code> ：默认模式，在没有找到 offset 时(记录在 Kafka topic 的 <code>connect-offsets</code> 中，Kafka connect 框架维护)，做一次 snapshot——遍历有 SELECT 权限的表，收集列名，并且将每个表的所有行 select 出来写入 Kafka；</li><li><code>when_needed</code>: 跟 <code>initial</code> 类似，只是增加了一种情况，当记录的 offset 对应的 binlog 位置已经在 MySQL 服务端被 purge 了时，就重新做一个 snapshot。</li><li><code>never</code>: 不做 snapshot，也就是不拿所有表的列名，也不导出表数据到 Kafka，这个模式下，要求<a href="https://dieken.gitlab.io/posts/use-debezium-to-replicate-mysql-binlog/" target="_blank" rel="noopener">从最开头</a>消费 binlog，以获取完整的 DDL 信息，MySQL 服务端的 binlog 不能被 purge 过，否则由于 DML binlog 里只有 database name、table name、column type 却没有 column name，Debezium 会报错 <code>Encountered change event for table some_db.some_table whose schema isn&#39;t known to this connector</code>；</li><li><code>schema_only</code>: 这种情况下会拿所有表的列名信息，但不会导出表数据到 Kafka，而且只从 Debezium 启动那刻起的 binlog 末尾开始消费，所以很适合不关心历史数据，只关心最近变更的场合。</li><li><code>schema_only_recovery</code>: 在 Debezium 的 schema_only 模式出错时，用这个模式恢复，一般不会用到。</li></ol></li></ul><p><a href="https://www.jianshu.com/p/d6ac601438a5" target="_blank" rel="noopener">https://www.jianshu.com/p/d6ac601438a5</a></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><table><thead><tr><th>Connector</th><th>Database</th><th>Driver</th></tr></thead><tbody><tr><td><a href="https://ververica.github.io/flink-cdc-connectors/master/content/connectors/mongodb-cdc.html" target="_blank" rel="noopener">mongodb-cdc</a></td><td><a href="https://www.mongodb.com/" target="_blank" rel="noopener">MongoDB</a>: 3.6, 4.x, 5.0</td><td>MongoDB Driver: 4.3.1</td></tr><tr><td><a href="https://ververica.github.io/flink-cdc-connectors/master/content/connectors/mysql-cdc.html" target="_blank" rel="noopener">mysql-cdc</a></td><td><a href="https://dev.mysql.com/doc" target="_blank" rel="noopener">MySQL</a>: 5.6, 5.7, 8.0.x<a href="https://www.aliyun.com/product/rds/mysql" target="_blank" rel="noopener">RDS MySQL</a>: 5.6, 5.7, 8.0.x<a href="https://www.aliyun.com/product/polardb" target="_blank" rel="noopener">PolarDB MySQL</a>: 5.6, 5.7, 8.0.x<a href="https://aws.amazon.com/cn/rds/aurora" target="_blank" rel="noopener">Aurora MySQL</a>: 5.6, 5.7, 8.0.x<a href="https://mariadb.org/" target="_blank" rel="noopener">MariaDB</a>: 10.x<a href="https://github.com/ApsaraDB/galaxysql" target="_blank" rel="noopener">PolarDB X</a>: 2.0.1</td><td>JDBC Driver: 8.0.27</td></tr><tr><td><a href="https://ververica.github.io/flink-cdc-connectors/master/content/connectors/oceanbase-cdc.html" target="_blank" rel="noopener">oceanbase-cdc</a></td><td><a href="https://open.oceanbase.com/" target="_blank" rel="noopener">OceanBase CE</a>: 3.1.x</td><td>JDBC Driver: 5.7.4x</td></tr><tr><td><a href="https://ververica.github.io/flink-cdc-connectors/master/content/connectors/oracle-cdc.html" target="_blank" rel="noopener">oracle-cdc</a></td><td><a href="https://www.oracle.com/index.html" target="_blank" rel="noopener">Oracle</a>: 11, 12, 19</td><td>Oracle Driver: 19.3.0.0</td></tr><tr><td><a href="https://ververica.github.io/flink-cdc-connectors/master/content/connectors/postgres-cdc.html" target="_blank" rel="noopener">postgres-cdc</a></td><td><a href="https://www.postgresql.org/" target="_blank" rel="noopener">PostgreSQL</a>: 9.6, 10, 11, 12</td><td>JDBC Driver: 42.2.12</td></tr><tr><td><a href="https://ververica.github.io/flink-cdc-connectors/master/content/connectors/sqlserver-cdc.html" target="_blank" rel="noopener">sqlserver-cdc</a></td><td><a href="https://www.microsoft.com/sql-server" target="_blank" rel="noopener">Sqlserver</a>: 2012, 2014, 2016, 2017, 2019</td><td>JDBC Driver: 7.2.2.jre8</td></tr><tr><td><a href="https://ververica.github.io/flink-cdc-connectors/master/content/connectors/tidb-cdc.html" target="_blank" rel="noopener">tidb-cdc</a></td><td><a href="https://www.pingcap.com/" target="_blank" rel="noopener">TiDB</a>: 5.1.x, 5.2.x, 5.3.x, 5.4.x, 6.0.0</td><td>JDBC Driver: 8.0.27</td></tr></tbody></table><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><ul><li>Flink CDC 2.0 正式发布，详解核心改进，链接：<a href="https://flink-learning.org.cn/article/detail/3ebe9f20774991c4d5eeb75a141d9e1e" target="_blank" rel="noopener">https://flink-learning.org.cn/article/detail/3ebe9f20774991c4d5eeb75a141d9e1e</a></li><li>Working with MySQL Binary Logs，链接：<a href="https://maxchadwick.xyz/blog/working-with-mysql-binary-logs" target="_blank" rel="noopener">https://maxchadwick.xyz/blog/working-with-mysql-binary-logs</a></li><li>debezium，链接：<a href="https://debezium.io/documentation/reference/1.5/connectors/mysql.html#mysql-creating-user" target="_blank" rel="noopener">https://debezium.io/documentation/reference/1.5/connectors/mysql.html#mysql-creating-user</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分 Spark内存管理详解&lt;/li&gt;
&lt;li&gt;第二部分 Spark参数说明&lt;/li&gt;
&lt;li&gt;第三
      
    
    </summary>
    
      <category term="Flink" scheme="https://zjrongxiang.github.io/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink 中的API</title>
    <link href="https://zjrongxiang.github.io/2022/04/26/2022-04-28-Flink%20%E4%B8%AD%E7%9A%84API/"/>
    <id>https://zjrongxiang.github.io/2022/04/26/2022-04-28-Flink 中的API/</id>
    <published>2022-04-26T05:30:00.000Z</published>
    <updated>2022-04-28T02:40:31.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分 Spark内存管理详解</li><li>第二部分 Spark参数说明</li><li>第三部分 Spark内存优化</li><li>第四部分 常见线上问题解决</li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="第一部分-Flink-中的-API"><a href="#第一部分-Flink-中的-API" class="headerlink" title="第一部分 Flink 中的 API"></a>第一部分 Flink 中的 API</h2><p>Flink 为流式/批式处理应用程序的开发提供了不同级别的抽象。</p><p><img src="https://nightlies.apache.org/flink/flink-docs-master/fig/levels_of_abstraction.svg" alt="Programming levels of abstraction"></p><ul><li><p>Flink API 最底层的抽象为<strong>有状态实时流处理</strong>。其抽象实现是 <a href="https://nightlies.apache.org/flink/flink-docs-master/zh/docs/dev/datastream/operators/process_function/" target="_blank" rel="noopener">Process Function</a>，并且 <strong>Process Function</strong> 被 Flink 框架集成到了 <a href="https://nightlies.apache.org/flink/flink-docs-master/zh/docs/dev/datastream/overview/" target="_blank" rel="noopener">DataStream API</a> 中来为我们使用。它允许用户在应用程序中自由地处理来自单流或多流的事件（数据），并提供具有全局一致性和容错保障的<em>状态</em>。此外，用户可以在此层抽象中注册事件时间（event time）和处理时间（processing time）回调方法，从而允许程序可以实现复杂计算。</p></li><li><p>Flink API 第二层抽象是 <strong>Core APIs</strong>。实际上，许多应用程序不需要使用到上述最底层抽象的 API，而是可以使用 <strong>Core APIs</strong> 进行编程：其中包含 <a href="https://nightlies.apache.org/flink/flink-docs-master/zh/docs/dev/datastream/overview/" target="_blank" rel="noopener">DataStream API</a>（应用于有界/无界数据流场景）和 <a href="https://nightlies.apache.org/flink/flink-docs-master/zh/docs/dev/dataset/overview/" target="_blank" rel="noopener">DataSet API</a>（应用于有界数据集场景）两部分。Core APIs 提供的流式 API（Fluent API）为数据处理提供了通用的模块组件，例如各种形式的用户自定义转换（transformations）、联接（joins）、聚合（aggregations）、窗口（windows）和状态（state）操作等。此层 API 中处理的数据类型在每种编程语言中都有其对应的类。</p><p><em>Process Function</em> 这类底层抽象和 <em>DataStream API</em> 的相互集成使得用户可以选择使用更底层的抽象 API 来实现自己的需求。<em>DataSet API</em> 还额外提供了一些原语，比如循环/迭代（loop/iteration）操作。</p></li><li><p>Flink API 第三层抽象是 <strong>Table API</strong>。<strong>Table API</strong> 是以表（Table）为中心的声明式编程（DSL）API，例如在流式数据场景下，它可以表示一张正在动态改变的表。<a href="https://nightlies.apache.org/flink/flink-docs-master/zh/docs/dev/table/overview/" target="_blank" rel="noopener">Table API</a> 遵循（扩展）关系模型：即表拥有 schema（类似于关系型数据库中的 schema），并且 Table API 也提供了类似于关系模型中的操作，比如 select、project、join、group-by 和 aggregate 等。Table API 程序是以声明的方式定义<em>应执行的逻辑操作</em>，而不是确切地指定程序<em>应该执行的代码</em>。尽管 Table API 使用起来很简洁并且可以由各种类型的用户自定义函数扩展功能，但还是比 Core API 的表达能力差。此外，Table API 程序在执行之前还会使用优化器中的优化规则对用户编写的表达式进行优化。</p><p>表和 <em>DataStream</em>/<em>DataSet</em> 可以进行无缝切换，Flink 允许用户在编写应用程序时将 <em>Table API</em> 与 <em>DataStream</em>/<em>DataSet</em> API 混合使用。</p></li><li><p>Flink API 最顶层抽象是 <strong>SQL</strong>。这层抽象在语义和程序表达式上都类似于 <em>Table API</em>，但是其程序实现都是 SQL 查询表达式。<a href="https://nightlies.apache.org/flink/flink-docs-master/zh/docs/dev/table/overview/#sql" target="_blank" rel="noopener">SQL</a> 抽象与 Table API 抽象之间的关联是非常紧密的，并且 SQL 查询语句可以在 <em>Table API</em> 中定义的表上执行。</p></li></ul><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、数据治理对运维数据体系的思考与启发，链接：<a href="https://github.com/ververica/flink-cdc-connectors" target="_blank" rel="noopener">https://github.com/ververica/flink-cdc-connectors</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分 Spark内存管理详解&lt;/li&gt;
&lt;li&gt;第二部分 Spark参数说明&lt;/li&gt;
&lt;li&gt;第三
      
    
    </summary>
    
      <category term="Flink" scheme="https://zjrongxiang.github.io/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>CDC总结</title>
    <link href="https://zjrongxiang.github.io/2022/04/26/2022-05-11-CDC%E6%80%BB%E7%BB%93/"/>
    <id>https://zjrongxiang.github.io/2022/04/26/2022-05-11-CDC总结/</id>
    <published>2022-04-26T05:30:00.000Z</published>
    <updated>2022-05-11T12:06:27.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分 Spark内存管理详解</li><li>第二部分 Spark参数说明</li><li>第三部分 Spark内存优化</li><li>第四部分 常见线上问题解决</li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="第一部分-概述"><a href="#第一部分-概述" class="headerlink" title="第一部分 概述"></a>第一部分 概述</h2><p><a href="https://www.striim.com/blog/change-data-capture-cdc-what-it-is-and-how-it-works/" target="_blank" rel="noopener">https://www.striim.com/blog/change-data-capture-cdc-what-it-is-and-how-it-works/</a></p><h2 id="第一部分-实践"><a href="#第一部分-实践" class="headerlink" title="第一部分 实践"></a>第一部分 实践</h2><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分 Spark内存管理详解&lt;/li&gt;
&lt;li&gt;第二部分 Spark参数说明&lt;/li&gt;
&lt;li&gt;第三
      
    
    </summary>
    
      <category term="Flink" scheme="https://zjrongxiang.github.io/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>数据仓库学习系列-血缘关系</title>
    <link href="https://zjrongxiang.github.io/2022/04/20/2022-04-24-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E8%A1%80%E7%BC%98%E5%85%B3%E7%B3%BB/"/>
    <id>https://zjrongxiang.github.io/2022/04/20/2022-04-24-数据仓库学习系列-血缘关系/</id>
    <published>2022-04-20T05:30:00.000Z</published>
    <updated>2022-04-25T01:45:20.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分 Spark内存管理详解</li><li>第二部分 Spark参数说明</li><li>第三部分 Spark内存优化</li><li>第四部分 常见线上问题解决</li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>血缘分析是一种技术手段，用于对数据处理过程的全面追踪，从而找到某个数据对象为起点的所有相关元数据对象以及这些元数据对象之间的关系。元数据对象之间的关系特指表示这些元数据对象的数据流输入输出关系。在元数据管理系统成型后，我们便可以通过血缘分析来对数据仓库中的数据健康、数据分布、集中度、数据热度等进行分析。</p><p>二 在企业的数据资产中，通过数据血缘，我们能够解决以下几个场景的问题：<br>1、快速了解到一张业务报表来源于那几个系统、来源于哪几张表。<br>2、快速洞察到这张业务报表经过了几个步骤生成的。<br>3、在数据仓库中，能快速判断一张ODS层的源表数据会流动到下游哪些DW、DM层数据表内。如果改动这张源表，会影响到哪些下游数据、哪些业务报表。<br>4、在生产环境中，如果有一张数据表出现错误，通过数据血缘图，可以快速知晓，数据错误来源于前面哪个环节、可能会影响到后面哪个环节。<br>5、通过分析数据血缘图的关键节点（即图中节点入度、出度较高的节点），我们能更好的总结出哪些业务数据是被经常用到的、是关键性的，更好的编排节点间的调度工作流，优化计算资源。</p><p><a href="https://cloud.tencent.com/developer/article/1876878" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1876878</a></p><p>魔改hive实现：<a href="https://www.i4k.xyz/article/qq_44962075/106945827" target="_blank" rel="noopener">https://www.i4k.xyz/article/qq_44962075/106945827</a></p><h2 id="第一部分-atlas开源项目"><a href="#第一部分-atlas开源项目" class="headerlink" title="第一部分 atlas开源项目"></a>第一部分 atlas开源项目</h2><p>Apache Atlas 是 Apache 基金会的孵化项目，是 Hadoop 生态圈的数据治理和元数据框架。Atlas 是一套核心基础治理服务的集合，有很好的伸缩性和可扩展性，能够满足企业对 Hadoop 生态系统的多样性需求，并能和企业的数据生态系统集成。它为 Hadoop 集群提供了包括数据分类、集中策略引擎、数据血缘、安全和生命周期管理在内的元数据治理核心能力。 </p><p>但 atlas 的缺点是：只能对 hadoop 的元数据进行管理（虽然也是连的 Mysql ），对传统数据库的支持力度非常小；同时血缘分析也只支持特定的数据库。</p><p>三 Atlas的数据溯源功能介绍<br>Atlas主要针对与Hadoop旗下的数据产品进行数据溯源。<br>Apache Hive等应用在产生元数据变化（比如新增表、新增字段）和数据流动（比如Insert into）的时候，通过钩子的方式主动告知Atlas更新数据血缘图。</p><p>四 Atlas是如何实现数据溯源的？</p><p>Atlas主要通过Hook方式让Hive将元数据信息通过Apache Kafka传送过来。<br>Atlas使用了JanusGraph[2]做图数据存储引擎。借助JanusGraph，数据血缘关系主要通过图的形式进行存储在Hbase中，每个节点的详细信息存储在Solr中。<br>除了前端UI，Atlas还支持第三方应用通过API、Kafka获取数据血缘相关信息。</p><p>元数据管理在数据仓库的实践应用<br><a href="https://blog.51cto.com/wang/4186308" target="_blank" rel="noopener">https://blog.51cto.com/wang/4186308</a></p><p><a href="https://atlas.apache.org/#/HookHive" target="_blank" rel="noopener">https://atlas.apache.org/#/HookHive</a></p><p><a href="https://www.csdn.net/tags/MtTaMg4sMDE5OTgyLWJsb2cO0O0O.html" target="_blank" rel="noopener">https://www.csdn.net/tags/MtTaMg4sMDE5OTgyLWJsb2cO0O0O.html</a></p><p>源码分析：<a href="https://www.1024sou.com/article/27372.html" target="_blank" rel="noopener">https://www.1024sou.com/article/27372.html</a></p><p><a href="https://aws.amazon.com/cn/blogs/china/apache-atlas-data-bloodline/" target="_blank" rel="noopener">https://aws.amazon.com/cn/blogs/china/apache-atlas-data-bloodline/</a></p><p>其他数据库的自定义方法:<a href="https://github.com/picomy/manually-catch-data-for-atlas" target="_blank" rel="noopener">https://github.com/picomy/manually-catch-data-for-atlas</a></p><p>另一个产品：</p><p><a href="https://absaoss.github.io/spline/" target="_blank" rel="noopener">https://absaoss.github.io/spline/</a></p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、数据治理对运维数据体系的思考与启发，链接：<a href="http://blog.itpub.net/69994525/viewspace-2762789/" target="_blank" rel="noopener">http://blog.itpub.net/69994525/viewspace-2762789/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分 Spark内存管理详解&lt;/li&gt;
&lt;li&gt;第二部分 Spark参数说明&lt;/li&gt;
&lt;li&gt;第三
      
    
    </summary>
    
      <category term="Hadoop" scheme="https://zjrongxiang.github.io/categories/Hadoop/"/>
    
    
  </entry>
  
  <entry>
    <title>Python语言中函数装饰器总结</title>
    <link href="https://zjrongxiang.github.io/2022/04/18/2022-04-18-Python%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0-Python%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://zjrongxiang.github.io/2022/04/18/2022-04-18-Python系列文章-Python语言中函数装饰器总结/</id>
    <published>2022-04-18T02:30:00.000Z</published>
    <updated>2022-04-19T03:26:32.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分   包和模块</li><li>第二部分   Import 方法</li><li>第三部分   命名空间（namespace）</li><li>第四部分  Import的过程</li><li>第五部分  将模块、包的路径加入检索路径</li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://foofish.net/python-decorator.html" target="_blank" rel="noopener">https://foofish.net/python-decorator.html</a></p><p>前面章节中，我们已经讲解了 <a href="http://c.biancheng.net/python/" target="_blank" rel="noopener">Python</a> 内置的 3 种函数装饰器，分别是 ＠staticmethod、＠classmethod 和 @property，其中 staticmethod()、classmethod() 和 property() 都是 Python 的内置函数。</p><p>在Python语言中，一切皆为对象，甚至于函数。函数可以像普通变量一样当做参数传给别的函数，也可以赋值给其他变量。我们看一下下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"func1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(func)</span>:</span></span><br><span class="line">    func()</span><br><span class="line">    print(<span class="string">"func2"</span>)</span><br><span class="line"></span><br><span class="line">func2(func1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> func1</span><br><span class="line">func3 = func1</span><br><span class="line">func3()</span><br></pre></td></tr></table></figure><ul><li><code>func1</code>作为参数传给<code>func2</code></li><li><code>func3</code>指向函数<code>func1</code>，即使<code>func1</code>被删除。</li></ul><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1、<a href="http://www.cnblogs.com/russellluo/p/3328683.html#" target="_blank" rel="noopener">http://www.cnblogs.com/russellluo/p/3328683.html#</a></p><p>2、<a href="https://github.com/Liuchang0812/slides/tree/master/pycon2015cn" target="_blank" rel="noopener">https://github.com/Liuchang0812/slides/tree/master/pycon2015cn</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分   包和模块&lt;/li&gt;
&lt;li&gt;第二部分   Import 方法&lt;/li&gt;
&lt;li&gt;第三部分 
      
    
    </summary>
    
      <category term="python" scheme="https://zjrongxiang.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink内存管理和优化</title>
    <link href="https://zjrongxiang.github.io/2022/04/17/2022-04-17-Flink%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96/"/>
    <id>https://zjrongxiang.github.io/2022/04/17/2022-04-17-Flink内存管理和优化/</id>
    <published>2022-04-17T05:30:00.000Z</published>
    <updated>2022-04-17T04:31:36.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分 Flink内存管理详解</li><li>第二部分 Flink内存优化</li><li>第三部分 总结</li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Flink计算框架和Spark相同，都是基于JVM虚拟机实现的。基于 JVM 的数据分析引擎都需要面对将大量数据存到内存中，这就不得不面对 JVM 存在的几个问题：</p><ol><li>Java 对象存储密度低。一个只包含 boolean 属性的对象占用了16个字节内存：对象头占了8个，boolean 属性占了1个，对齐填充占了7个。而实际上只需要一个bit（1/8字节）就够了。</li><li>Full GC 会极大地影响性能，尤其是为了处理更大数据而开了很大内存空间的JVM来说，GC 会达到秒级甚至分钟级。</li><li>OOM 问题影响稳定性。OutOfMemoryError是分布式计算框架经常会遇到的问题，当JVM中所有对象大小超过分配给JVM的内存大小时，就会发生OutOfMemoryError错误，导致JVM崩溃，分布式框架的健壮性和性能都会受到影响。</li></ol><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、《Deep Dive: Apache Spark Memory Management》介绍视频，链接：<a href="https://youtu.be/dPHrykZL8Cg" target="_blank" rel="noopener">https://youtu.be/dPHrykZL8Cg</a></p><p>2、探索Spark Tungsten的秘密，链接：<a href="https://github.com/hustnn/TungstenSecret" target="_blank" rel="noopener">https://github.com/hustnn/TungstenSecret</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分 Flink内存管理详解&lt;/li&gt;
&lt;li&gt;第二部分 Flink内存优化&lt;/li&gt;
&lt;li&gt;第三
      
    
    </summary>
    
      <category term="Flink" scheme="https://zjrongxiang.github.io/categories/Flink/"/>
    
    
  </entry>
  
</feed>
