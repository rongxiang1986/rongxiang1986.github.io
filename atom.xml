<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RongXiang</title>
  
  <subtitle>我的烂笔头</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zjrongxiang.github.io/"/>
  <updated>2022-10-25T15:01:29.404Z</updated>
  <id>https://zjrongxiang.github.io/</id>
  
  <author>
    <name>rong xiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql中用户资源配置</title>
    <link href="https://zjrongxiang.github.io/posts/d781f7da/"/>
    <id>https://zjrongxiang.github.io/posts/d781f7da/</id>
    <published>2022-10-25T05:30:00.000Z</published>
    <updated>2022-10-25T15:01:29.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分   </li><li>第二部分 </li><li>第三部分 </li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mysql.<span class="keyword">user</span></span><br></pre></td></tr></table></figure><p>mysql.user表中给用户授予权限字段的含义</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Select_priv：用户可以通过SELECT命令选择数据。</span><br><span class="line">Insert_priv：用户可以通过INSERT命令插入数据;</span><br><span class="line">Update_priv：用户可以通过UPDATE命令修改现有数据;</span><br><span class="line">Delete_priv：用户可以通过DELETE命令删除现有数据;</span><br><span class="line">Create_priv：用户可以创建新的数据库和表;</span><br><span class="line">Drop_priv： 用户可以删除现有数据库和表;</span><br><span class="line">Reload_priv：用户可以执行刷新和重新加载MySQL所用各种内部缓存的特定命令,包括日志、权限、主机、查询和表;重新加载权限表;</span><br><span class="line">Shutdown_priv：用户可以关闭MySQL服务器;在将此权限提供给root账户之外的任何用户时,都应当非常谨慎;</span><br><span class="line">Process_priv：用户可以通过SHOW PROCESSLIST命令查看其他用户的进程;服务器管理;</span><br><span class="line">File_priv：用户可以执行SELECT INTO OUTFILE和LOAD DATA INFILE命令;加载服务器上的文件;</span><br><span class="line">Grant_priv：用户可以将已经授予给该用户自己的权限再授予其他用户(任何用户赋予全部已有权限);</span><br><span class="line">References_priv：目前只是某些未来功能的占位符；现在没有作用;</span><br><span class="line">Index_priv：用户可以创建和删除表索引;用索引查询表;</span><br><span class="line">Alter_priv：用户可以重命名和修改表结构;</span><br><span class="line">Show_db_priv：用户可以查看服务器上所有数据库的名字,包括用户拥有足够访问权限的数据库;可以考虑对所有用户禁用这个权限,除非有特别不可抗拒的原因;</span><br><span class="line">Super_priv：用户可以执行某些强大的管理功能,例如通过KILL命令删除用户进程,使用SET **GLOBAL修改全局MySQL变量,执行关于复制和日志的各种命令;超级权限;</span><br><span class="line">Create_tmp_table_priv：用户可以创建临时表;</span><br><span class="line">Lock_tables_priv：用户可以使用LOCK TABLES命令阻止对表的访问/修改;</span><br><span class="line">Execute_priv：用户可以执行存储过程;此权限只在MySQL 5.0及更高版本中有意义;</span><br><span class="line">Repl_slave_priv：用户可以读取用于维护复制数据库环境的二进制日志文件;此用户位于主系统中,有利于主机和客户机之间的通信;主服务器管理;</span><br><span class="line">Repl_client_priv：用户可以确定复制从服务器和主服务器的位置;从服务器管理;</span><br><span class="line">Create_view_priv：用户可以创建视图;此权限只在MySQL 5.0及更高版本中有意义;</span><br><span class="line">Show_view_priv：用户可以查看视图或了解视图如何执行;此权限只在MySQL 5.0及更高版本中有意义;</span><br><span class="line">Create_routine_priv：用户可以更改或放弃存储过程和函数;此权限是在MySQL 5.0中引入的;</span><br><span class="line">Alter_routine_priv：用户可以修改或删除存储函数及函数;此权限是在MySQL 5.0中引入的;</span><br><span class="line">Create_user_priv：用户可以执行CREATE USER命令,这个命令用于创建新的MySQL账户;</span><br><span class="line">Event_priv：用户能否创建、修改和删除事件;这个权限是MySQL 5.1.6新增的;</span><br><span class="line">Trigger_priv：用户能否创建和删除触发器,这个权限是MySQL 5.1.6新增的;</span><br><span class="line">Create_tablespace_priv：创建表空间</span><br><span class="line">ssl_type：支持ssl标准加密安全字段</span><br><span class="line">ssl_cipher：支持ssl标准加密安全字段</span><br><span class="line">x509_issuer：支持x509标准字段</span><br><span class="line">x509_subject：支持x509标准字段</span><br><span class="line">max_questions：默认0，每小时允许执行多少次查询：0表示无限制</span><br><span class="line">max_updates：默认0， 每小时可以执行多少次更新 ：0表示无限制</span><br><span class="line">max_connections：默认0， 每小时可以建立的多少次连接：0表示无限制</span><br><span class="line">max_user_connections：默认0， 单用户可以同时具有的最大连接数：0表示无限制</span><br><span class="line">plugin：5.5.7开始,mysql引入plugins以进行用户连接时的密码验证,plugin创建外部/代理用户</span><br><span class="line">authentication_string：通过authentication_string可以控制两者的映射关系,(PAM plugin等,PAM可以支持多个服务名)尤其是在使用代理用户时，并须声明这一点</span><br><span class="line">password_expired：密码过期 Y,说明该用户密码已过期 N相反</span><br></pre></td></tr></table></figure><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分   &lt;/li&gt;
&lt;li&gt;第二部分 &lt;/li&gt;
&lt;li&gt;第三部分 &lt;/li&gt;
&lt;li&gt;参考文献及
      
    
    </summary>
    
      <category term="Mysql" scheme="https://zjrongxiang.github.io/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Python系列文章-高效Python代码技巧汇编(第1篇)</title>
    <link href="https://zjrongxiang.github.io/posts/d3640108/"/>
    <id>https://zjrongxiang.github.io/posts/d3640108/</id>
    <published>2022-10-21T14:42:00.000Z</published>
    <updated>2022-10-25T15:01:29.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分   第一个项目</p></li><li><p>第二部分  总结</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、官网介绍：<a href="https://seaborn.pydata.org/tutorial.html" target="_blank" rel="noopener">https://seaborn.pydata.org/tutorial.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分   第一个项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分  总结&lt;/p
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python系列文章-异常处理总结</title>
    <link href="https://zjrongxiang.github.io/posts/66a5c75d/"/>
    <id>https://zjrongxiang.github.io/posts/66a5c75d/</id>
    <published>2022-10-21T14:42:00.000Z</published>
    <updated>2022-10-25T15:01:29.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分 内置异常</p></li><li><p>第二部分 异常处理</p></li><li><p>第三部分 产生异常</p></li><li><p>第四部分 自定义异常</p></li><li><p>第五部分 traceback模块</p></li><li><p>第六部分 cgitb包</p></li><li><p>第七部分 最佳实践</p></li><li><p>第八部分 补遗</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>和宇宙空间和时间的无限相比，人类的历史和现有活动只是这个空间和时间上有限抽样。我们无法穷尽所有的可能性，所以新增的事情（错误或异常）是客观存在的。</p></blockquote><p>Python 中有两种错误：语法错误和异常（ <em>syntax errors</em> 和 <em>exceptions</em> ）。 </p><p>语法错误，也被称作解析错误。</p><p>异常。即使一条语句或表达式在语法上是正确的，当试图执行它时也可能会引发错误。运行期检测到的错误称为 <em>异常</em>，并且程序不会无条件的崩溃</p><p>案例环境：<code>Cpython 3.8.8</code></p><h2 id="第一部分-内置异常"><a href="#第一部分-内置异常" class="headerlink" title="第一部分 内置异常"></a>第一部分 内置异常</h2><p>Python中一切皆为对象，异常也是。<code>Python3</code>在<code>builtins.py</code>内置模块中定义了64个异常类，类继承关系如下。在<code>Python3</code>中所有异常类本质都是继承<code>BaseException</code>基类。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">BaseException # 异常基类</span><br><span class="line"> +-- SystemExit </span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception # 常规错误的基类。所有内置的非系统退出类异常都继承此类，用户自定义异常也应当继承此类</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StopAsyncIteration</span><br><span class="line">      +-- ArithmeticError # 此基类用于派生针对各种算术类错误而引发的内置异常</span><br><span class="line">      |    +-- FloatingPointError</span><br><span class="line">      |    +-- OverflowError</span><br><span class="line">      |    +-- ZeroDivisionError</span><br><span class="line">      +-- AssertionError</span><br><span class="line">      +-- AttributeError</span><br><span class="line">      +-- BufferError # 与缓冲区相关的操作无法执行时将被引发</span><br><span class="line">      +-- EOFError</span><br><span class="line">      +-- ImportError # Python导入失败错误</span><br><span class="line">      |    +-- ModuleNotFoundError # Python模块不存在错误</span><br><span class="line">      +-- LookupError # 此基类用于派生当映射或序列所使用的键或索引无效时引发的异常</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      |    +-- UnboundLocalError</span><br><span class="line">      +-- OSError # 操作系统错误</span><br><span class="line">      |    +-- BlockingIOError</span><br><span class="line">      |    +-- ChildProcessError</span><br><span class="line">      |    +-- ConnectionError</span><br><span class="line">      |    |    +-- BrokenPipeError</span><br><span class="line">      |    |    +-- ConnectionAbortedError</span><br><span class="line">      |    |    +-- ConnectionRefusedError</span><br><span class="line">      |    |    +-- ConnectionResetError</span><br><span class="line">      |    +-- FileExistsError</span><br><span class="line">      |    +-- FileNotFoundError</span><br><span class="line">      |    +-- InterruptedError</span><br><span class="line">      |    +-- IsADirectoryError</span><br><span class="line">      |    +-- NotADirectoryError</span><br><span class="line">      |    +-- PermissionError</span><br><span class="line">      |    +-- ProcessLookupError</span><br><span class="line">      |    +-- TimeoutError</span><br><span class="line">      +-- ReferenceError</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      |    +-- NotImplementedError</span><br><span class="line">      |    +-- RecursionError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      |    +-- IndentationError</span><br><span class="line">      |         +-- TabError</span><br><span class="line">      +-- SystemError</span><br><span class="line">      +-- TypeError</span><br><span class="line">      +-- ValueError</span><br><span class="line">      |    +-- UnicodeError</span><br><span class="line">      |         +-- UnicodeDecodeError</span><br><span class="line">      |         +-- UnicodeEncodeError</span><br><span class="line">      |         +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning # 警告类异常</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">           +-- ImportWarning</span><br><span class="line">           +-- UnicodeWarning</span><br><span class="line">           +-- BytesWarning</span><br><span class="line">           +-- ResourceWarning</span><br></pre></td></tr></table></figure><h2 id="第二部分-异常处理：try-except-else-finally"><a href="#第二部分-异常处理：try-except-else-finally" class="headerlink" title="第二部分 异常处理：try-except-else-finally"></a>第二部分 异常处理：try-except-else-finally</h2><h3 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h3><p>大部分语言中都有对异常处理的语法，例如Java中使用 try…catch 语句来捕获代码中的异常，而在Python中使用try…except。原理就是通过监视try语句中的错误，从而让except语句捕获异常信息并进行处理。基本语法结构为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 代码段1</span></span><br><span class="line"><span class="keyword">except</span> exception name:</span><br><span class="line">    <span class="comment"># 代码段2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 代码段3</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 代码段4</span></span><br></pre></td></tr></table></figure><ul><li><strong>try</strong>：正常情况下，程序计划执行的语句。</li><li><strong>except</strong>：程序异常是执行的语句。注意这里的exception name可以是多个。</li><li><strong>else</strong>：程序无异常即try段代码正常执行后会执行该语句。</li><li><strong>finally</strong>：不管有没有异常，都会执行的语句。</li></ul><p>另外exception name是异常名。</p><ol><li><code>except</code>语句不是必须的，<code>finally</code>语句也不是必须的，但是二者必须要有一个，否则就没有<code>try</code>的意义了。</li><li><code>except</code>语句可以有多个，Python会按<code>except</code>语句的顺序依次匹配你指定的异常，如果异常已经处理就不会再进入后面的<code>except</code>语句。</li><li><code>except</code>语句可以以元组形式同时指定多个异常，参见实例代码。</li><li><code>except</code>语句后面如果不指定异常类型，则默认捕获所有异常，你可以通过logging或者sys模块获取当前异常。</li></ol><h3 id="2-2-案例"><a href="#2-2-案例" class="headerlink" title="2.2 案例"></a>2.2 案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">"test.txt"</span>, <span class="string">"r"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f.write(<span class="string">"写入内容"</span>)</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"写入文件成功"</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><ul><li>文件以read模式打开，显然是无法写入的，except捕获IOError异常回显：not writable。但是程序能正常执行完成（exit code 0）</li><li>如果我们使用write模式打开，就能顺利执行完</li><li>另外如果文件不存在，程序不能正常执行完成（ exit code 1，非正常退出），中断显示异常：FileNotFoundError。注意这个报错其实是语句<code>f = open(&quot;test.txt&quot;, &quot;r&quot;)</code>的报错。</li></ul><p>另外语法中except可以是多个分别定义，Python编译器会顺序处理捕获的异常。</p><h2 id="第三部分-产生异常：raise和assert"><a href="#第三部分-产生异常：raise和assert" class="headerlink" title="第三部分 产生异常：raise和assert"></a>第三部分 产生异常：raise和assert</h2><h3 id="3-1-raise"><a href="#3-1-raise" class="headerlink" title="3.1 raise"></a>3.1 raise</h3><p>在调用Python第三方包或者内置包的时候，即使我们没有去捕获异常，通常遇到异常也会捕获。这就是因为第三方包开发者做好了严谨的异常生产和捕获。例如下面的例子我们直接使用raise方法产生一个IOError类型异常，然后被except捕获并处理。语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> [exceptionName [(reason)]]</span><br></pre></td></tr></table></figure><p>等同于C#和Java中的<code>throw</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">raise_test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> IOError(<span class="string">"异常生成测试"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    raise_test()</span><br><span class="line">    print(<span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">    exc_type, exc_value, exc_traceback = sys.exc_info()</span><br><span class="line">    traceback.print_tb(exc_traceback)</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">异常生成测试</span></span><br><span class="line"><span class="string">  File "D:/git/Python/bestPractice/exceptionExample/example6.py", line 10, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    raise_test()</span></span><br><span class="line"><span class="string">  File "D:/git/Python/bestPractice/exceptionExample/example6.py", line 6, in raise_test</span></span><br><span class="line"><span class="string">    raise IOError("异常生成测试")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Process finished with exit code 0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; raise</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">RuntimeError: No active exception to reraise</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; raise IOError</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">OSError</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; raise IOError(<span class="string">"write error"</span>)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">OSError: write error</span><br></pre></td></tr></table></figure><h3 id="3-2-assert-断言"><a href="#3-2-assert-断言" class="headerlink" title="3.2 assert 断言"></a>3.2 assert 断言</h3><p>Python中assert用于判断一个表达式（expression），在表达式条件为 false 的时候触发异常。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> expression</span><br></pre></td></tr></table></figure><p>也等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> expression:</span><br><span class="line">    <span class="keyword">raise</span> AssertionError</span><br></pre></td></tr></table></figure><p>看一个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; assert 1/0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; assert 1/1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; assert 1==False</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure><h2 id="第四部分-自定义异常"><a href="#第四部分-自定义异常" class="headerlink" title="第四部分 自定义异常"></a>第四部分 自定义异常</h2><h3 id="案例（requests）"><a href="#案例（requests）" class="headerlink" title="案例（requests）"></a>案例（requests）</h3><p>除了系统内置的异常类，用户还可以自己定义应用相关的异常类。例如requests包在requests.exceptions中定义自身异常类如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">IOError</span><br><span class="line"> +-- RequestException  # 处理不确定的异常请求</span><br><span class="line">      +-- HTTPError  # HTTP错误</span><br><span class="line">      +-- ConnectionError  # 连接错误</span><br><span class="line">      |    +-- ProxyError  # 代理错误</span><br><span class="line">      |    +-- SSLError  # SSL错误</span><br><span class="line">      |    +-- ConnectTimeout(+-- Timeout)  # (双重继承，下同)尝试连接到远程服务器时请求超时，产生此错误的请求可以安全地重试。</span><br><span class="line">      +-- Timeout  # 请求超时</span><br><span class="line">      |    +-- ReadTimeout  # 服务器未在指定的时间内发送任何数据</span><br><span class="line">      +-- URLRequired  # 发出请求需要有效的URL</span><br><span class="line">      +-- TooManyRedirects  # 重定向太多</span><br><span class="line">      +-- MissingSchema(+-- ValueError) # 缺少URL架构(例如http或https)</span><br><span class="line">      +-- InvalidSchema(+-- ValueError) # 无效的架构，有效架构请参见defaults.py</span><br><span class="line">      +-- InvalidURL(+-- ValueError)  # 无效的URL</span><br><span class="line">      |    +-- InvalidProxyURL  # 无效的代理URL</span><br><span class="line">      +-- InvalidHeader(+-- ValueError)  # 无效的Header</span><br><span class="line">      +-- ChunkedEncodingError  # 服务器声明了chunked编码但发送了一个无效的chunk</span><br><span class="line">      +-- ContentDecodingError(+-- BaseHTTPError)  # 无法解码响应内容</span><br><span class="line">      +-- StreamConsumedError(+-- TypeError)  # 此响应的内容已被使用</span><br><span class="line">      +-- RetryError  # 自定义重试逻辑失败</span><br><span class="line">      +-- UnrewindableBodyError  # 尝试倒回正文时，请求遇到错误</span><br><span class="line">      +-- FileModeWarning(+-- DeprecationWarning)  # 文件以文本模式打开，但Requests确定其二进制长度</span><br><span class="line">      +-- RequestsDependencyWarning  # 导入的依赖项与预期的版本范围不匹配</span><br><span class="line"> </span><br><span class="line">Warning</span><br><span class="line"> +-- RequestsWarning  # 请求的基本警告</span><br></pre></td></tr></table></figure><p>[‘BaseHTTPError’, ‘ChunkedEncodingError’, ‘CompatJSONDecodeError’, ‘ConnectTimeout’, ‘ConnectionError’, ‘ContentDecodingError’, ‘FileModeWarning’, ‘HTTPError’, ‘InvalidHeader’, ‘InvalidJSONError’, ‘InvalidProxyURL’, ‘InvalidSchema’, ‘InvalidURL’, ‘JSONDecodeError’, ‘MissingSchema’, ‘ProxyError’, ‘ReadTimeout’, ‘RequestException’, ‘RequestsDependencyWarning’, ‘RequestsWarning’, ‘RetryError’, ‘SSLError’, ‘StreamConsumedError’, ‘Timeout’, ‘TooManyRedirects’, ‘URLRequired’, ‘UnrewindableBodyError’, ‘<strong>builtins</strong>‘, ‘<strong>cached</strong>‘, ‘<strong>doc</strong>‘, ‘<strong>file</strong>‘, ‘<strong>loader</strong>‘, ‘<strong>name</strong>‘, ‘<strong>package</strong>‘, ‘<strong>spec</strong>‘]</p><h3 id="如何定义一个异常类"><a href="#如何定义一个异常类" class="headerlink" title="如何定义一个异常类"></a>如何定义一个异常类</h3><p>此外，你也可以通过创建一个新的异常类拥有自己的异常，异常应该是通过直接或间接的方式继承（直接或者间接）自Exception类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfExceptionError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> SelfExceptionError(<span class="string">'用户自定义异常'</span>)</span><br><span class="line"><span class="keyword">except</span> SelfExceptionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'user self defined exception occurred'</span>, e.msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行回显：</span></span><br><span class="line"><span class="comment"># user self defined exception occurred 用户自定义异常</span></span><br></pre></td></tr></table></figure><ul><li>自定义类内部实现了 <code>__init__()</code> 方法和 <code>__str__()</code> 方法</li><li>由于大多数 Python 内置异常的名字都以 “Error” 结尾，所以实际命名时尽量跟标准的异常命名一样</li></ul><h2 id="第五部分-traceback模块查看异常"><a href="#第五部分-traceback模块查看异常" class="headerlink" title="第五部分 traceback模块查看异常"></a>第五部分 traceback模块查看异常</h2><p><a href="https://www.jianshu.com/p/a8cb5375171a" target="_blank" rel="noopener">https://www.jianshu.com/p/a8cb5375171a</a></p><h3 id="5-1-案例"><a href="#5-1-案例" class="headerlink" title="5.1 案例"></a>5.1 案例</h3><p>在程序出现异常时候，如果只是打印异常（日志文件或回显），通常信息比较少，例如前面写文件的例子，只是返回：not writable。为了快速定位问题，需要知道是哪个文件、哪个模块以及哪一行出错。</p><p>Python程序的traceback信息均来源于一个叫做traceback object的对象，而这个traceback object通过函数sys.exc_info()来获取。我们先看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"test.txt"</span>, <span class="string">"r"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f.write(<span class="string">"写入内容"</span>)</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">    exc_type, exc_value, exc_traceback = sys.exc_info()</span><br><span class="line">    traceback.print_tb(exc_traceback)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"写入文件成功"</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>程序执行正常退出，回显如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">not writable</span><br><span class="line">  File "D:/git/Python/example4.py", line 7, in &lt;module&gt;</span><br><span class="line">    f.write("写入内容")</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>从回显信息中，有执行模块<code>example4.py</code>和异常发生的代码行信息：<code>line 7</code>。通过以上示例可以看出，sys.exc_info()获取了当前处理的exception的相关信息，并返回一个元组（对象名自定义）。</p><ul><li>exc_type，异常的类型(示例是NameError类型)；</li><li>exc_value, 异常的value值；</li><li>exc_traceback，traceback object；</li></ul><h3 id="5-2-Traceback-模块"><a href="#5-2-Traceback-模块" class="headerlink" title="5.2 Traceback 模块"></a>5.2 Traceback 模块</h3><p>模块提供了一个标准接口，用于提取，格式和打印Python程序的堆栈痕迹。 它完全模仿了Python解释器在打印堆栈跟踪时的行为。 当您想在程序控制下打印堆栈迹线时，这非常有用，例如在解释器周围的“包装器”中。<br>Python中的traceback信息均来源于一个叫做traceback object的对象，而这个traceback object通常是通过函数sys.exc_info()来获取的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"test.txt"</span>, <span class="string">"r"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f.write(<span class="string">"写入内容"</span>)</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">    exc_type, exc_value, exc_traceback = sys.exc_info()</span><br><span class="line">    print(<span class="string">"exc_type:"</span>, exc_type)</span><br><span class="line">    print(<span class="string">"exc_value:"</span>, exc_value)</span><br><span class="line">    print(<span class="string">"exc_traceback:"</span>, exc_traceback)</span><br><span class="line">    traceback.print_tb(exc_traceback)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"写入文件成功"</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>程序运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">not writable</span><br><span class="line">exc_type: &lt;class 'io.UnsupportedOperation'&gt;</span><br><span class="line">exc_value: not writable</span><br><span class="line">exc_traceback: &lt;traceback object at 0x000000000A7BBE40&gt;</span><br><span class="line">  File "D:/git/Python/example3.py", line 9, in &lt;module&gt;</span><br><span class="line">    f.write("写入内容")</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>sys.exc_info()获取了当前处理的exception的相关信息，并返回一个元组，元组的第一个数据是异常的类型，第二个返回值是异常的value值，第三个就是我们要的traceback objec</p><h3 id="5-3-Traceback中常用函数"><a href="#5-3-Traceback中常用函数" class="headerlink" title="5.3 Traceback中常用函数"></a>5.3 Traceback中常用函数</h3><h2 id="第六部分-cgitb包"><a href="#第六部分-cgitb包" class="headerlink" title="第六部分 cgitb包"></a>第六部分 cgitb包</h2><p><code>cgitb</code>模块为<code>Python</code>脚本提供了一个特殊的异常管理器。名字有点误导人，它最初设计是为了以HTML格式展示<code>cgi</code>脚本的大量异常信息。后来，他扩展为也可以展示纯文本信息。该模块激活后，如果发生了未捕获的异常，将会展示格式化的输出报告。该报告包括源代码每一层的回溯，以及当前执行程序的参数和局部变量。以及，你可以选择将这些信息存到一个文件里，而不是发送到浏览器。</p><h3 id="6-1-案例"><a href="#6-1-案例" class="headerlink" title="6.1 案例"></a>6.1 案例</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cgitb</span><br><span class="line">cgitb.<span class="keyword">enable</span>(<span class="keyword">format</span>=<span class="string">'text'</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">open</span>("test.txt", "r")</span><br><span class="line">f.<span class="keyword">write</span>("写入内容")</span><br><span class="line">f.<span class="keyword">close</span>()</span><br></pre></td></tr></table></figure><h3 id="6-2-内部方法和函数"><a href="#6-2-内部方法和函数" class="headerlink" title="6.2  内部方法和函数"></a>6.2  内部方法和函数</h3><p>两个函数：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgitb.encable(<span class="attribute">display</span>=1, <span class="attribute">logdir</span>=None, <span class="attribute">context</span>=5, <span class="attribute">format</span>=<span class="string">"html"</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>display</code> 1，发送至浏览器；0， 不发送<br><code>logdir</code> 如果有的话，写到该目录下<br><code>context</code> 显示错误代码周围的代码行数<br><code>format</code> 是否显示为HTML，除了’html’之外的所有值，都会显示为纯文本</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgitb.<span class="keyword">handle</span>(info=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><blockquote><p>如果你想用<code>cgitb</code>处理异常，你可以调用这个函数。<br><code>info</code> 应当是含有异常类型、异常值和traceback对象的三元组，——如同<code>sys.exc_info()</code>返回的那样。如果不提供info，则从<code>sys.exc_info</code>中获取。</p></blockquote><h2 id="第七部分-最佳实践"><a href="#第七部分-最佳实践" class="headerlink" title="第七部分 最佳实践"></a>第七部分 最佳实践</h2><ol><li>只处理你知道的异常，避免捕获所有异常然后吞掉它们。</li><li>抛出的异常应该说明原因，有时候你知道异常类型也猜不出所以然。</li><li>避免在<code>catch</code>语句块中干一些没意义的事情，捕获异常也是需要成本的。</li><li>不要使用异常来控制流程，那样你的程序会无比难懂和难维护。</li><li>如果有需要，切记使用<code>finally</code>来释放资源。</li><li><p>如果有需要，请不要忘记在处理异常后做清理工作或者回滚操作。</p></li><li><p>不建议捕获并抛出同一个异常，请考虑重构你的代码。</p></li><li>不建议在不清楚逻辑的情况下捕获所有异常，有可能你隐藏了很严重的问题。</li><li>尽量使用内置的异常处理语句来替换<code>try/except</code>语句，比如<code>with</code>语句，<code>getattr()</code>方法。</li></ol><h2 id="第八部分-补遗"><a href="#第八部分-补遗" class="headerlink" title="第八部分 补遗"></a>第八部分 补遗</h2><h3 id="8-1-except-Exception语法"><a href="#8-1-except-Exception语法" class="headerlink" title="8.1 except Exception语法"></a>8.1 except Exception语法</h3><p>在查看Python源码的时候经常看到下面2种写法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 执行逻辑</span></span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> KeyError, e:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在语法上，Python2可以使用2种语法均可。但是Python3中只能使用第一种，即：<code>except NameError as e</code>。为了统一，建议使用第一种写法。</p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、Understanding the Python Traceback：<a href="https://realpython.com/python-traceback/" target="_blank" rel="noopener">https://realpython.com/python-traceback/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分 内置异常&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分 异常处理&lt;/p&gt;

      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python系列文章-Seaborn包使用</title>
    <link href="https://zjrongxiang.github.io/posts/f9f8cf01/"/>
    <id>https://zjrongxiang.github.io/posts/f9f8cf01/</id>
    <published>2022-10-20T14:42:00.000Z</published>
    <updated>2022-10-25T15:01:29.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分   第一个项目</p></li><li><p>第二部分  总结</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Seaborn是一个基于matplotlib且数据结构与Pandas统一的统计图制作库。</p><p>官网地址：<a href="http://seaborn.pydata.org/index.html" target="_blank" rel="noopener">http://seaborn.pydata.org/index.html</a></p><p>Seaborn其实是在matplotlib的基础上进行了更高级的API封装，从而使得<strong>作图更加容易</strong>，在大多数情况下使用seaborn就能做出很具有吸引力的图，而使用matplotlib就能制作具有更多特色的图。应该把Seaborn视为matplotlib的补充，而不是替代物。同时它能高度兼容<strong>numpy</strong>与<strong>pandas</strong>数据结构以及<strong>scipy</strong>与<strong>statsmodels</strong>等统计模式。掌握seaborn能很大程度帮助我们更高效的观察数据与图表，并且更加深入了解它们。</p><p><a href="https://www.cnblogs.com/zuti666/p/16095634.html" target="_blank" rel="noopener">https://www.cnblogs.com/zuti666/p/16095634.html</a></p><h2 id="第一部分-初步"><a href="#第一部分-初步" class="headerlink" title="第一部分 初步"></a>第一部分 初步</h2><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pip install seaborn</span></span><br></pre></td></tr></table></figure><p>如果需要升级：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pip install seaborn --upgrade</span></span><br></pre></td></tr></table></figure><p>版本：0.12.1</p><h2 id="组合图标"><a href="#组合图标" class="headerlink" title="组合图标"></a>组合图标</h2><ol><li>多子图：在一个画布上绘制多个坐标系；</li><li>图表重叠：将多个图表在一个坐标系展示；</li></ol><h3 id="多子图"><a href="#多子图" class="headerlink" title="多子图"></a>多子图</h3><p>在之前的内容中我们讲到了<strong>seaborn</strong>的图表层级，<code>axes-level</code>图表是可以添加到matplotlib的复杂figure中的，seaborn中的<code>axes-level</code>都有添加一个<code>ax</code>参数用于指定在figure中的绘图位置；</p><p>如下面代码中，我们通过<code>plt.subplots()</code>创建一个1行2列的<code>figure</code>，我们可以非常便捷的将<strong>seaborn</strong>的图表添加进去；</p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、官网介绍：<a href="https://seaborn.pydata.org/tutorial.html" target="_blank" rel="noopener">https://seaborn.pydata.org/tutorial.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分   第一个项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分  总结&lt;/p
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习系列文章-数据处理（数据标准化）</title>
    <link href="https://zjrongxiang.github.io/posts/b8ea2443/"/>
    <id>https://zjrongxiang.github.io/posts/b8ea2443/</id>
    <published>2022-10-19T11:30:00.000Z</published>
    <updated>2022-10-25T15:01:29.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>数据的标准化(normalization)是将数据按比例缩放，使之落入一个小的特定区间。在某些比较和评价的指标处理中经常会用到，去除数据的单位限制，将其转化为无<a href="https://so.csdn.net/so/search?q=量纲&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">量纲</a>的纯数值，便于不同单位或量级的指标能够进行比较和加权。其中最典型的就是数据的归一化处理，即将数据统一映射到[0,1]区间上，<strong>常见的数据归一化的方法有:min-max标准化(Min-maxnormalization)也叫离差标准化</strong>，是对原始数据的线性变换，使结果落到[0,1]区间，转换函数如下:其中max为样本数据的最大值，min为样本数据的最小值。这种方法有一个缺陷就是当有新数据加入时，可能导致max和min的变化，需要重新定义。而并非所有数据标准化的结果都映射到[0,1]区间上，其中最常见的标准化方法就是Z标准化，也是SPSS中最为常用的标准化方法:z-score 标准化(zero-meannormalization)也叫标准差标准化，经过处理的数据符合标准正态分布，即均值为0，标准差为1，其转化函数为:其中μ为所有样本数据的均值，σ为所有样本数据的标准差。</p><h2 id="第一部分-规范化"><a href="#第一部分-规范化" class="headerlink" title="第一部分 规范化"></a>第一部分 规范化</h2><p>对序列 $x_1, x_2, \ldots, x_n$ 进行变换:<br>$$<br>y_i=\frac{x_i-\min _{1 \leq i \leq n}\left{x_j\right}}{\max _{1 \leq i \leq n}\left{x_j\right}-\min _{1 \leq i \leq n}\left{x_j\right}}<br>$$<br>则新序列 $y_1, y_2, \ldots, y_n \in[0,1]$ 且无量纲。一般的数据需要时都可以考虑先进行规范化处</p><ul><li>也叫离差标准化，是对原始数据的线性变换，使结果映射到[0,1]区间。</li></ul><h2 id="第二部分-正规化"><a href="#第二部分-正规化" class="headerlink" title="第二部分 正规化"></a>第二部分 正规化</h2><p>对序列 $x_1, x_2, \ldots, x_n$ 进行变换:<br>$$<br>y_i=\frac{x_i-\bar{x}}{s} \text {, 这里 } \bar{x}=\frac{1}{n} \sum_{i=1}^n x_i, s=\sqrt{\frac{1}{n-1} \sum_{i=1}^n\left(x_i-\bar{x}\right)^2}<br>$$<br>则新序列 $y_1, y_2, \ldots, y_n$ 的均值为 0 , 而方差为 1 , 且无量纲。</p><ul><li>这种方法基于原始数据的均值 (mean) 和标准差 (standard deviation) 进行数据的标准化。将A的原始值x使用zscore标准化到x’。</li><li>Z-score标准化方法适用于属性A的最大值和最小值末知的情况，或有超出取值范围的离群数据的情况。</li><li>spss默认的标准化方法就是Z-score标准化。</li></ul><h2 id="第三部分-归一化"><a href="#第三部分-归一化" class="headerlink" title="第三部分 归一化"></a>第三部分 归一化</h2><p>对正项序列 $x_1, x_2, \ldots, x_n$ 进行变换:<br>$$<br>y_i=\frac{x_i}{\sum_{i=1}^n x_i}<br>$$<br>则新序列 $y_1, y_2, \ldots, y_n \in[0,1]$ 且无量纲, 并且显然有 $\sum_{i=1}^n y_i=1$ 。</p><p>Z-Score标准化是数据处理的方法之一。在数据标准化中，常见的方法有如下三种：</p><ol><li>Z-Score 标准化</li><li>最大最小标准化</li><li>小数定标法</li></ol><p>需要注意的是，通过 z-score 转变后的分值，并没有被正态化。也就是说，原来是<a href="https://www.zhihu.com/search?q=正态分布&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1741114532}" target="_blank" rel="noopener">正态分布</a>的，转为 z-score 之后仍为<a href="https://www.zhihu.com/search?q=正太分布&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1741114532}" target="_blank" rel="noopener">正太分布</a>；原来不是正态分布的，转化为 z-score 之后并不会转换为正态分布</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>1、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;数据的标准化(normalization)是将数据按比例缩放，使之落入一个小的特定区间。在某些比较和评价的指标处理中经常会用到，去除数据的单
      
    
    </summary>
    
      <category term="machine learning" scheme="https://zjrongxiang.github.io/categories/machine-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>2022-10-19-机器学习系列文章-数据服从正态分布检验</title>
    <link href="https://zjrongxiang.github.io/posts/8c940df6/"/>
    <id>https://zjrongxiang.github.io/posts/8c940df6/</id>
    <published>2022-10-19T11:30:00.000Z</published>
    <updated>2022-10-25T15:01:29.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>正态分布（Normal Distribution）概念是由法国数学家棣莫弗（Abraham de Moivre）于1733年首次提出的，后由我们的数学王子德国数学家高斯（Gauss）率先将其应用于天文学研究，由于高斯的工作对后世的影响非常大，所以正态分布也有被叫作“高斯分布”。</p><p><a href="https://blog.csdn.net/qq_33924470/article/details/114668701" target="_blank" rel="noopener">https://blog.csdn.net/qq_33924470/article/details/114668701</a></p><p><a href="https://www.biaodianfu.com/python-normal-distribution-test.html" target="_blank" rel="noopener">https://www.biaodianfu.com/python-normal-distribution-test.html</a></p><h2 id="第一部分-图示法"><a href="#第一部分-图示法" class="headerlink" title="第一部分 图示法"></a>第一部分 图示法</h2><p>1、直方图：可以直观显示数据的分布形式。</p><p>2、P-P图和Q-Q图：P-P图反映了变量的实际累积概率与理论累积概率的符合程度，Q-Q图反映了变量的实际分布与理论分布的符合程度，两者意义相似，都可以用来考察数据是否服从某种分布类型。若数据服从正态分布，则数据点应与理论直线基本重合。</p><p><strong>1.2.1 P-P图</strong></p><p>P-P图反映的是数据的实际累积概率与假定所服从分布的理论累积概率的符合程度。在此处，我们所假定的分布就是正态分布，如果数据样本是服从正态分布的话，那么实际的累积概率与理论的累积概率应该是相对一致的，放映在图形中就是数据点应该沿着图形的对角线分布。</p><p><strong>1.2.2 Q-Q图</strong></p><p>Q-Q图的原理与P-P图几乎一致。P-P图考察的是实际分布与理论分布的累积概率分布差异，而Q-Q图考察的是实际百分位数与理论百分位数的差异。同理在此处，我们所假定的分布就是正态分布，如果数据样本是服从正态分布的话，那么实际的分布应该是相对一致的，反映在图形中就是数据点应该沿着图形的对角线分布。</p><h2 id="第二部分-分布特征比较法"><a href="#第二部分-分布特征比较法" class="headerlink" title="第二部分 分布特征比较法"></a>第二部分 分布特征比较法</h2><p><a href="https://www.cnblogs.com/zwt20120701/p/10872243.html" target="_blank" rel="noopener">https://www.cnblogs.com/zwt20120701/p/10872243.html</a></p><h3 id="2-1-偏度（Skewness）和峰度（Kurtosis）"><a href="#2-1-偏度（Skewness）和峰度（Kurtosis）" class="headerlink" title="2.1 偏度（Skewness）和峰度（Kurtosis）"></a>2.1 偏度（Skewness）和峰度（Kurtosis）</h3><p>对于数据分布，通常可以计算两个分布特征：偏度（Skewness）和峰度（Kurtosis）。</p><h4 id="2-1-1-偏度（Skewness）：数据分布不对称的方向及其程度。"><a href="#2-1-1-偏度（Skewness）：数据分布不对称的方向及其程度。" class="headerlink" title="2.1.1 偏度（Skewness）：数据分布不对称的方向及其程度。"></a>2.1.1 偏度（Skewness）：数据分布不对称的方向及其程度。</h4><p>峰度反应的是图像的尖锐程度：峰度越大，表现在图像上面是中心点越尖锐。在相同方差的情况下，中间一大部分的值方差都很小，为了达到和正太分布方差相同的目的，必须有一些值离中心点越远，所以这就是所说的“厚尾”，反应的是异常点增多这一现象。</p><p>指标度量数据分布的对称性。</p><p>计算公式：</p><p>结果判断：</p><p>当偏度≈0时，可认为分布近似服从正态分布；</p><p>当偏度&gt;0时，分布为右偏，称为正偏态；</p><p>当偏度&lt;0时，分布为左偏，称为负偏态；</p><h4 id="2-1-2-峰度（Kurtosis）：描述数据分布形态的陡缓程度"><a href="#2-1-2-峰度（Kurtosis）：描述数据分布形态的陡缓程度" class="headerlink" title="2.1.2 峰度（Kurtosis）：描述数据分布形态的陡缓程度"></a>2.1.2 峰度（Kurtosis）：描述数据分布形态的陡缓程度</h4><p>数据分布顶的尖锐程度。</p><p>当峰度≈0时，可认为分布近似服从正态分布；</p><p>当峰度&gt;0时，分布的峰态陡峭；</p><p>当峰度&lt;0时，分布的峰态平缓；</p><h3 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h3><p>利用偏度和峰度进行正态性检验时，可以同时计算其相应的Z评分（Z-score），</p><p>即：</p><p>偏度：Z-score=偏度值/标准误</p><p>峰度：Z-score=峰度值/标准误</p><p>Fisher skewness coefficient = skewness/standard error of skewness</p><p>Fisher kurtosis coefficient = kurtosis/standard error of kurtosis</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">N</span> = 样本数</span><br><span class="line">偏度标准误 = <span class="built_in">sqrt</span>(<span class="number">6</span>*<span class="built_in">N</span>*(<span class="built_in">N</span>-<span class="number">1</span>)/((<span class="built_in">N</span>-<span class="number">2</span>)*(<span class="built_in">N</span>+<span class="number">1</span>)*(<span class="built_in">N</span>+<span class="number">3</span>)))</span><br><span class="line">峰度标准误 = <span class="built_in">sqrt</span>(<span class="number">4</span>*(<span class="built_in">N</span>**<span class="number">2</span> -<span class="number">1</span>)*偏度标准误 /((<span class="built_in">N</span>-<span class="number">3</span>)*(<span class="built_in">N</span>+<span class="number">5</span>)))</span><br></pre></td></tr></table></figure><p>参考spss代码链接：<a href="https://www.stat.cmu.edu/~hseltman/files/spssSkewKurtosis.R" target="_blank" rel="noopener">https://www.stat.cmu.edu/~hseltman/files/spssSkewKurtosis.R</a></p><p>在α=0.05的检验水平下，若Z-score在±1.96之间，则可认为数据近似服从正态分布。</p><p>pd.Series.skew(x)</p><h2 id="第三部分-非参数检验"><a href="#第三部分-非参数检验" class="headerlink" title="第三部分 非参数检验"></a>第三部分 非参数检验</h2><p><a href="https://www.biaodianfu.com/python-normal-distribution-test.html" target="_blank" rel="noopener">https://www.biaodianfu.com/python-normal-distribution-test.html</a></p><p>正态性检验属于非参数检验，原假设为“样本来自的总体与正态分布无显著性差异”，只有P&gt;0.05才能接受原假设，及数据符合正态分布。</p><blockquote><p>非参数检验是在总体方差未知或知道甚少的情况下，利用样本数据对总体分布形态等进行推断的方法。 由于非参数检验方法在推断过程中不涉及有关总体分布的参数，因而得名为“非参数”检验。</p></blockquote><p>常见的检验方法如下：</p><h3 id="3-1-Shapiro-Wilk检验"><a href="#3-1-Shapiro-Wilk检验" class="headerlink" title="3.1 Shapiro-Wilk检验"></a>3.1 <code>Shapiro-Wilk</code>检验</h3><p>Shapiro–Wilk test是正态性检验最为有效的方法之一，是一种在频率统计中检验正态性的方法，但其测试基础较难理解（不多加叙述）。该方法在每一个样本值都是唯一时的检验效果最好，但若样本中存在几个值重复的情况下该方法便会大打折扣。因此该方法只适用于小样本，推荐样本量为7~2000，Origion中允许样本大小为3~5000，当样本量超过5000时不再适用。该方法仅适用于正态性检验。</p><p>方法：scipy.stats.shapiro(x)</p><p>官方文档：<a href="https://link.zhihu.com/?target=https%3A//docs.scipy.org/doc/scipy/reference/generated/scipy.stats.shapiro.html" target="_blank" rel="noopener">SciPy v1.1.0 Reference Guide</a></p><p>参数：x - 待检验数据</p><p>返回：W - 统计数；p-value - <a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/P%E5%80%BC" target="_blank" rel="noopener">p值</a></p><p>注意事项：适用于小样本数据。</p><h3 id="3-2-Kolmogorov–Smirnov检验"><a href="#3-2-Kolmogorov–Smirnov检验" class="headerlink" title="3.2 Kolmogorov–Smirnov检验"></a>3.2 <code>Kolmogorov–Smirnov</code>检验</h3><p>柯尔莫戈洛夫-斯米诺夫检验（Kolmogorov-Smirnov test），一般又称K-S检验，该检验是柯尔莫戈洛夫所提出的，是一种基于累计分布函数的非参数检验，用以检验两个经验分布是否不同或一个经验分布与另一个理想分布是否不同。</p><p>方法：scipy.stats.kstest (rvs, cdf, args = ( ), N = 20, alternative =’two-sided’, mode =’approx’)</p><p>官方文档：<a href="https://link.zhihu.com/?target=https%3A//docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.stats.kstest.html" target="_blank" rel="noopener">SciPy v0.14.0 Reference Guide</a></p><p>参数：rvs - 待检验数据，可以是字符串、数组；</p><p>cdf - 需要设置的检验，这里设置为 norm，也就是正态性检验；</p><p>alternative - 设置单双尾检验，默认为 two-sided</p><p>返回：W - 统计数；p-value - <a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/P%E5%80%BC" target="_blank" rel="noopener">p值</a></p><p>特点：适合于大样本场景。</p><h3 id="3-3-Anderson-Darling-检验"><a href="#3-3-Anderson-Darling-检验" class="headerlink" title="3.3 Anderson-Darling 检验"></a>3.3 <code>Anderson-Darling</code> 检验</h3><p>方法：scipy.stats.anderson (x, dist =’norm’ )</p><p>该方法是由 scipy.stats.kstest 改进而来的，可以做正态分布、指数分布、Logistic 分布、Gumbel 分布等多种分布检验。默认参数为 norm，即正态性检验。</p><p>官方文档：<a href="https://link.zhihu.com/?target=https%3A//docs.scipy.org/doc/scipy/reference/generated/scipy.stats.anderson.html" target="_blank" rel="noopener">SciPy v1.1.0 Reference Guide</a></p><p>参数：x - 待检验数据；dist - 设置需要检验的分布类型</p><p>返回：statistic - 统计数；critical_values - 评判值；significance_level - 显著性水平</p><h3 id="3-4-scipy-stats-normal-检验"><a href="#3-4-scipy-stats-normal-检验" class="headerlink" title="3.4 scipy.stats.normal 检验"></a>3.4 <code>scipy.stats.normal</code> 检验</h3><p>方法：scipy.stats.normaltest (a, axis=0)</p><p>该方法专门用来检验数据是否为正态性分布，官方文档的描述为：</p><blockquote><p>Tests whether a sample differs from a normal distribution.<br>This function tests the null hypothesis that a sample comes from a normal distribution. It is based on D’Agostino and Pearson’s [R251], [R252] test that combines skew and kurtosis to produce an omnibus test of normality.</p></blockquote><p>官方文档：<a href="https://link.zhihu.com/?target=https%3A//docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.stats.normaltest.html" target="_blank" rel="noopener">SciPy v0.14.0 Reference Guide</a></p><p>参数：a - 待检验数据；axis - 可设置为整数或置空，如果设置为 none，则待检验数据被当作单独的数据集来进行检验。该值默认为 0，即从 0 轴开始逐行进行检验。</p><p>返回：k2 - s^2 + k^2，s 为 <a href="https://link.zhihu.com/?target=https%3A//docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.stats.skewtest.html%23scipy.stats.skewtest" target="_blank" rel="noopener">skewtest</a> 返回的 z-score，k 为 <a href="https://link.zhihu.com/?target=https%3A//docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.stats.kurtosistest.html%23scipy.stats.kurtosistest" target="_blank" rel="noopener">kurtosistest</a> 返回的 z-score，即标准化值；p-value - <a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/P%E5%80%BC" target="_blank" rel="noopener">p值</a></p><h2 id="第四部分-总结"><a href="#第四部分-总结" class="headerlink" title="第四部分 总结"></a>第四部分 总结</h2><p>实际上，从已有的文献表明，对于数据分布的正态性研究，<strong>首选方法是图形观察</strong>，即利用直方图、P-P图或Q-Q图进行观察，如果分布严重偏态和尖峰分布则建议进行进一步的假设检验。如果图形分布结果不好判断，则再进行正态性检验。</p><p>其次，对于检验方法来说，对于K-S检验及W检验结果来说，有文献采用蒙特卡罗模拟方法进行多次验证，结果表明<strong>W检验结果相比于大部分方法都有较大的检验功效</strong>，而K-S方法的检验结果相对不佳。并且部分学者认为，K-S检验的实用性远不如图形工具，因为在样本量少时，该检验不太敏感，但是在样本量大时，该检验却过于敏感。<strong>因此正常情况下，我们更常采用W检验的结果。</strong></p><p>值得注意的是，虽然说K-S检验结果相对不佳，但是不同检验方法对于样本量的敏感度是不一样的。<strong>在样本量较小的情况下（小于50个样本的情况下），请优先选择W检验；在样本量50-5000的情况下，可以酌情使用W检验及K—S检验；在样本量大于5000的情况下，请使用K-S检验结果，尤其是在SPSS中，当样本量大于5000的情况下，将只显示K-S检验结果，而不显示W检验结果。</strong></p><p><a href="https://blog.csdn.net/qq_33924470/article/details/114668701" target="_blank" rel="noopener">https://blog.csdn.net/qq_33924470/article/details/114668701</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1、偏度，链接：<a href="https://en.wikipedia.org/wiki/Skewness" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Skewness</a></p><p>2、峰度，链接：<a href="https://en.wikipedia.org/wiki/Kurtosis" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Kurtosis</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;正态分布（Normal Distribution）概念是由法国数学家棣莫弗（Abraham de Moivre）于1733年首次提出的，后由
      
    
    </summary>
    
      <category term="machine learning" scheme="https://zjrongxiang.github.io/categories/machine-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>经济系列文章-《就业、利息和货币通论》阅读</title>
    <link href="https://zjrongxiang.github.io/posts/f750abe5/"/>
    <id>https://zjrongxiang.github.io/posts/f750abe5/</id>
    <published>2022-10-18T13:30:00.000Z</published>
    <updated>2022-10-25T15:01:29.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>约翰·梅纳德·凯恩斯（John Maynard Keynes，1883年6月5日−1946年4月21日）</p><p>《就业、利息和货币通论》这本书写于1936年。而成书前，资本主义世界刚刚经历大萧条（1929年-1933年）</p><p>凯恩斯本人的两本主要著作《货币论》（上下卷）和《通论》都是被世人公认的晦涩难懂的经济学著作</p><p>资本边际效应：</p><p>流动性陷阱</p><p>挖坑理论</p><p>流动性偏好</p><p>货币乘数：</p><p>​    </p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、<a href="https://m.aisixiang.com/data/134030.html" target="_blank" rel="noopener">https://m.aisixiang.com/data/134030.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;约翰·梅纳德·凯恩斯（John Maynard Keynes，1883年6月5日−1946年4月21日）&lt;/p&gt;
&lt;p&gt;《就业、利息和货币通
      
    
    </summary>
    
      <category term="Distance Measures" scheme="https://zjrongxiang.github.io/categories/Distance-Measures/"/>
    
    
      <category term="Data Science" scheme="https://zjrongxiang.github.io/tags/Data-Science/"/>
    
  </entry>
  
  <entry>
    <title>微服务学习</title>
    <link href="https://zjrongxiang.github.io/posts/3dfd0f5c/"/>
    <id>https://zjrongxiang.github.io/posts/3dfd0f5c/</id>
    <published>2022-10-17T11:30:00.000Z</published>
    <updated>2022-10-25T15:01:29.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分   生成配置文件</p></li><li><p>第二部分  个性化配置</p></li><li><p>第三部分 设置密钥</p></li><li><p>第四部分 启动</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>微服务学习</p><p> 微服务以业务为中心；康维定理：组织架构会反映在产品上；</p><p>去中心化 vs 技术架构的统一性（技术栈收敛）</p><p>ESB 银行系统的 综合前置，SOA 能力的复用。</p><p>微服务的前提：基础设施的自动化部署和运维管理；</p><p>使用微服务解决SOA的问题；</p><h2 id="第一部分-微服务架构设计和最佳实践"><a href="#第一部分-微服务架构设计和最佳实践" class="headerlink" title="第一部分 微服务架构设计和最佳实践"></a>第一部分 微服务架构设计和最佳实践</h2><h3 id="1-1-微服务整体架构"><a href="#1-1-微服务整体架构" class="headerlink" title="1.1 微服务整体架构"></a>1.1 微服务整体架构</h3><p>API网关   服务注册 服务发现 服务配置；</p><p>服务调用容器；</p><p>服务注册：</p><p>zookeeper、ETCD、Consul（微软）、Rureka</p><p>网关：</p><p>API网关—微服务内部使用；</p><p>配置：</p><p>配置优先级管理；</p><p>配置中心；</p><p>spring config:配置读取和配置热更新；</p><p>携程 applo配置管理 产品；</p><p>服务熔断、服务降级、</p><p>Dubbo  ：rpc（服务端和客户端通讯协议变化）；</p><p>面向对象 面向资源；</p><h3 id="微服务监控"><a href="#微服务监控" class="headerlink" title="微服务监控"></a>微服务监控</h3><p>可观测；</p><p>服务进程调用栈 显示；</p><p>服务调用链；</p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>架构风格</p><p>DDD面对高度复杂的软件系统；对于服务的划分的借鉴；</p><p>服务的粒度：</p><p>信息系统—能力—领域—特征；</p><p>聚合层—–&gt;业务层——&gt;技术层</p><p>聚合层不能直接访问数据库；</p><p>服务划分—-现实存在一个实体部门；</p><p>量化的指标：两周内完成等原则；</p><h3 id="服务层设计"><a href="#服务层设计" class="headerlink" title="服务层设计"></a>服务层设计</h3><p>服务接口：幂等性、</p><p>业务层面控制；</p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分   生成配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分  个性化配
      
    
    </summary>
    
      <category term="微服务" scheme="https://zjrongxiang.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>JupyterNotebook远程服务认证访问配置</title>
    <link href="https://zjrongxiang.github.io/posts/59dfcf67/"/>
    <id>https://zjrongxiang.github.io/posts/59dfcf67/</id>
    <published>2022-10-09T11:30:00.000Z</published>
    <updated>2022-10-25T15:01:29.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分   生成配置文件</p></li><li><p>第二部分  个性化配置</p></li><li><p>第三部分 设置密钥</p></li><li><p>第四部分 启动</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>Jupyter notebook</code>是数据科学常用的代码交互式工具。</p><p>注：环境为ubuntu环境</p><h2 id="第一部分-生成配置文件"><a href="#第一部分-生成配置文件" class="headerlink" title="第一部分 生成配置文件"></a>第一部分 生成配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-5-ubuntu:~# jupyter notebook --generate-config</span><br><span class="line">Writing default config to: /root/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure><p>回显提示了配置文件路径。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/root/</span>.jupyter<span class="regexp">/jupyter_notebook_config.py</span></span><br></pre></td></tr></table></figure><h2 id="第二部分-个性化配置"><a href="#第二部分-个性化配置" class="headerlink" title="第二部分 个性化配置"></a>第二部分 个性化配置</h2><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 允许远程所有IP地址</span></span><br><span class="line">c.NotebookApp.allow_origin = '*'</span><br><span class="line">c.NotebookApp.allow_remote_access = True</span><br><span class="line">c.NotebookApp.ip = '0.0.0.0'</span><br><span class="line">c.NotebookApp.open_browser = False</span><br><span class="line">c.NotebookApp.port = 8888</span><br></pre></td></tr></table></figure><h2 id="第三部分-设置密钥"><a href="#第三部分-设置密钥" class="headerlink" title="第三部分 设置密钥"></a>第三部分 设置密钥</h2><p>建议使用方法2，比较方便。</p><p>方法1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-5-ubuntu:~# python</span><br><span class="line">Python 3.7.0 (default, Jun 28 2018, 13:15:42) </span><br><span class="line">[GCC 7.2.0] :: Anaconda, Inc. on linux</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from notebook.auth import passwd</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; passwd()</span></span><br><span class="line">Enter password: </span><br><span class="line">Verify password: </span><br><span class="line">'sha1:0dd92833333333333333333333333333333333333333'</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-5-ubuntu:~# jupyter notebook password</span><br><span class="line">Enter password: </span><br><span class="line">Verify password:</span><br></pre></td></tr></table></figure><h2 id="第四部分-启动"><a href="#第四部分-启动" class="headerlink" title="第四部分 启动"></a>第四部分 启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-5-ubuntu:~# jupyter notebook</span><br></pre></td></tr></table></figure><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、jupyter官网，链接：<a href="https://jupyter.org/" target="_blank" rel="noopener">https://jupyter.org/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分   生成配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分  个性化配
      
    
    </summary>
    
      <category term="jupyter" scheme="https://zjrongxiang.github.io/categories/jupyter/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习系列-傅里叶变换综述</title>
    <link href="https://zjrongxiang.github.io/posts/324e9859/"/>
    <id>https://zjrongxiang.github.io/posts/324e9859/</id>
    <published>2022-10-07T05:30:00.000Z</published>
    <updated>2022-10-25T15:01:29.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分  </li><li>第二部分  </li><li>第三部分 </li><li>第四部分 </li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>傅里叶变换（<code>Fourier transform</code>简称：<code>FT</code>）应用最广泛的领域应该是信息领域。<code>wiki</code>中定义为一种线性积分变换，用于函数（应用上称作“信号”）在时域和频域之间的变换。</p><p>这个思想方法最先由法国科学家<code>Jean Baptiste Joseph Fourier</code>（1768-1830）在研究热传导时首次提出。他在1807年，向法国科学学会递交了一篇论文（即《热的传播》），运用正弦曲线来描述温度分布。论文里使用了一个未严格证明的定理：任何一个函数都可以表达为一系列不同频率的简谐振动（即简单的三角函数）的叠加。</p><p>论文在审查中，拉格朗日坚决不同意论文的发表。主要理由是：坚持认为傅立叶的方法无法表示带有棱角的信号，如在方波中出现非连续变化斜率。拉格朗日当时在法国科学院可是权威，所以科学院拒绝了傅里叶的论文。</p><p>1811年，傅立叶重新呈交了修改后的论文，这次终于获得科学院于1812年颁发的奖金，但是仍然因为缺乏严密性而被拒绝刊载在科学院的《报告》中。直到1822年，他自己担任科学院终身秘书后（权职），终于将这篇论文发表了。</p><p><a href="https://www.zdaiot.com/MachineLearning/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E5%8D%B7%E7%A7%AF%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8F%8A%E7%89%A9%E7%90%86%E6%84%8F%E4%B9%89%EF%BC%88%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3%E5%8D%B7%E7%A7%AF%EF%BC%89/" target="_blank" rel="noopener">https://www.zdaiot.com/MachineLearning/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E5%8D%B7%E7%A7%AF%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8F%8A%E7%89%A9%E7%90%86%E6%84%8F%E4%B9%89%EF%BC%88%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3%E5%8D%B7%E7%A7%AF%EF%BC%89/</a></p><h2 id="第一部分-基础知识准备"><a href="#第一部分-基础知识准备" class="headerlink" title="第一部分 基础知识准备"></a>第一部分 基础知识准备</h2><h3 id="1-1-线性空间"><a href="#1-1-线性空间" class="headerlink" title="1.1 线性空间"></a>1.1 线性空间</h3><p>常见线性空间就是欧式空间，例如我们生活的3维欧式空间就是一个特殊的线性空间。那什么是线性空间呢？</p><p>首先我们有一个集合$V$，然后我们在集合上定义两个运算：加法和数乘。因为引入数乘运算，所以同时需要引入一个数域 $\mathbb{P}$。</p><ul><li><p>向量加法 $+: V \times V \rightarrow V$ ，即 $\forall \alpha, \beta \in V, \alpha+\beta \in V$ 。有时为了和一般数的加法相区别，也记作 $\oplus$ 。</p></li><li><p>数乘 ( 称标量乘法) : $V \times V \rightarrow V$ ，即 $\forall \alpha \in V, k \in \mathbb{P}, k \cdot \alpha \in V$ 。有时为了和一般数的乘法相区别， 也记作 $\odot$ 。</p></li></ul><p>集合中的任意元素在加法和数乘运算下是封闭的。另外运算还满足交换律和结合律。</p><ol><li>向量加法的交换律: $\forall \alpha, \beta \in V, \alpha+\beta=\beta+\alpha$</li><li>向量加法的结合律: $\forall \alpha, \beta, \gamma \in V,(\alpha+\beta)+\gamma=\alpha+(\beta+\gamma)$</li><li>向量加法有零元 : $\exists \theta \in V, \forall \alpha \in V, \alpha+\theta=\alpha$</li><li>向量加法有负元: $\forall \alpha \in V, \exists \alpha^{\prime} \in V, \alpha+\alpha^{\prime}=\theta$</li><li>标量乘法对向量加法有分配律 $\forall \alpha, \beta \in V, \forall k \in \mathbb{P}, k \cdot(\alpha+\beta)=k \cdot \alpha+k \cdot \beta$</li><li>标量乘法对域加法有分配律 : $\forall \alpha \in V, \forall k, l \in \mathbb{P},(k+l) \cdot \alpha=k \cdot \alpha+l \cdot \alpha$</li><li>标量乘法与标量的域乘法相容 : $\forall \alpha \in V, \forall k, l \in \mathbb{P},(k l) \cdot \alpha=k \cdot(l \cdot \alpha)$</li><li>标量乘法有单位元 : $\forall \alpha \in V, 1 \cdot \alpha=\alpha$</li></ol><p>满足以上8条性质便可称其为线性空间，在不引起混淆的情况下 $(V ;+, \cdot;\mathbb{P})$ 也可记为 $V 。 k \cdot \alpha$ 也可沿用几何空间 中向量数乘的习惯记为 $k \alpha$ 。</p><h3 id="1-2-线性变换"><a href="#1-2-线性变换" class="headerlink" title="1.2 线性变换"></a>1.2 线性变换</h3><p>有了线性空间的概念后，我们就可以定义线性空间之间的映射（集合上的概念）。如果映射 $\mathbf{T}: V \rightarrow W$ ，满足线性空间的加法和数乘封闭性 :<br>$$<br>\begin{aligned}<br>&amp;\mathbf{T}(\alpha+\beta)=\mathbf{T}(\alpha)+\mathbf{T}(\beta) \in W \<br>&amp;\mathbf{T}(a \alpha)=a \mathbf{T}(\alpha) \in W<br>\end{aligned}<br>$$<br>其中 $\alpha, \beta \in V ， a \in \mathbb{P}$，有时候也称变换为函数。</p><h3 id="1-3-线性子空间"><a href="#1-3-线性子空间" class="headerlink" title="1.3 线性子空间"></a>1.3 线性子空间</h3><p>在集合概念中有子集合的概念。那么线性空间中的元素首先是一个集合对象，那么当然也有子集合，那么对于这个子集合，如果还能保持线性运算（线性运算定义继承原线性空间）封闭，这就是一个子线性空间，当然中文语境我们通常称为线性子空间。</p><h3 id="1-4-线性空间的基"><a href="#1-4-线性空间的基" class="headerlink" title="1.4 线性空间的基"></a>1.4 线性空间的基</h3><p>根据线性空间的定义我们知道，线性空间的元素可以被空间的若干元素线性表示：<br>$$<br>v=k \cdot a+l \cdot b +n\cdot c<br>$$<br>那么就有问题：</p><ul><li><p>这种线性表示是否是唯一的？</p><p>答案是否定。例如常见的3维欧式空间中点：（1，2，3）</p></li><li><p>空间中是否存在无法被其他元素线性表示的对象（不含数乘生成对象）？</p><p>存在。例如3维欧式空间中点：（0，0, 1）。其实这种代表元就是线性空间中基。</p></li></ul><p>这样我们就抽象出线性空间基的概念：</p><h3 id="1-3-函数空间"><a href="#1-3-函数空间" class="headerlink" title="1.3 函数空间"></a>1.3 函数空间</h3><p>对于线性空间，我们只定义了元素间的线性结构，空间是没有拓扑结构，更没有度量、范数和内积。 例如欧式空间就是赋予了欧式度量后，元素之间有了距离结构。</p><h2 id="第二部分-傅里叶变换"><a href="#第二部分-傅里叶变换" class="headerlink" title="第二部分 傅里叶变换"></a>第二部分 傅里叶变换</h2><h3 id="2-1-时域、频域、空间域的基本概念"><a href="#2-1-时域、频域、空间域的基本概念" class="headerlink" title="2.1 时域、频域、空间域的基本概念"></a>2.1 时域、频域、空间域的基本概念</h3><p><a href="https://zhuanlan.zhihu.com/p/428783752" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/428783752</a></p><h2 id="第三部分-傅里叶变换的应用"><a href="#第三部分-傅里叶变换的应用" class="headerlink" title="第三部分 傅里叶变换的应用"></a>第三部分 傅里叶变换的应用</h2><p><a href="https://codeantenna.com/a/lHTPxCro41" target="_blank" rel="noopener">https://codeantenna.com/a/lHTPxCro41</a></p><h2 id="第四部分-快速傅里叶变换"><a href="#第四部分-快速傅里叶变换" class="headerlink" title="第四部分 快速傅里叶变换"></a>第四部分 快速傅里叶变换</h2><p><a href="https://www.cnblogs.com/LXP-Never/p/11558302.html" target="_blank" rel="noopener">https://www.cnblogs.com/LXP-Never/p/11558302.html</a></p><h2 id="第五部分-短时傅里叶变换"><a href="#第五部分-短时傅里叶变换" class="headerlink" title="第五部分 短时傅里叶变换"></a>第五部分 短时傅里叶变换</h2><h3 id="5-1-局限性"><a href="#5-1-局限性" class="headerlink" title="5.1 局限性"></a>5.1 局限性</h3><p>对<strong>非平稳</strong>过程，傅里叶变换有局限性</p><p>对<strong>非平稳</strong>过程，傅里叶变换有局限性</p><h3 id="5-2-短时傅里叶变换"><a href="#5-2-短时傅里叶变换" class="headerlink" title="5.2 短时傅里叶变换"></a>5.2 短时傅里叶变换</h3><h3 id="5-3-窗口大小的选择"><a href="#5-3-窗口大小的选择" class="headerlink" title="5.3 窗口大小的选择"></a>5.3 窗口大小的选择</h3><h2 id="第六部分-小波分析"><a href="#第六部分-小波分析" class="headerlink" title="第六部分 小波分析"></a>第六部分 小波分析</h2><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、<a href="https://users.rowan.edu/~polikar/WTtutorial.html" target="_blank" rel="noopener">https://users.rowan.edu/~polikar/WTtutorial.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分  &lt;/li&gt;
&lt;li&gt;第二部分  &lt;/li&gt;
&lt;li&gt;第三部分 &lt;/li&gt;
&lt;li&gt;第四部分 
      
    
    </summary>
    
      <category term="Spring" scheme="https://zjrongxiang.github.io/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Python系列文章-Prophet时间序列预测包使用</title>
    <link href="https://zjrongxiang.github.io/posts/1894f56d/"/>
    <id>https://zjrongxiang.github.io/posts/1894f56d/</id>
    <published>2022-10-03T14:42:00.000Z</published>
    <updated>2022-10-25T15:01:29.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分   第一个项目</p></li><li><p>第二部分  总结</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://blog.csdn.net/qq_20948717/article/details/89286268" target="_blank" rel="noopener">https://blog.csdn.net/qq_20948717/article/details/89286268</a></p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、变量官网介绍：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分   第一个项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分  总结&lt;/p
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python系列文章-pystan贝叶斯推断包使用</title>
    <link href="https://zjrongxiang.github.io/posts/2c7a276d/"/>
    <id>https://zjrongxiang.github.io/posts/2c7a276d/</id>
    <published>2022-10-03T14:42:00.000Z</published>
    <updated>2022-10-25T15:01:29.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分   第一个项目</p></li><li><p>第二部分  总结</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>概率编程（Probabilistic Programming）使用较多的3个软件包有 Stan、PyMc3、Edward。</p><p>Stan 本身就是一种编程语言，用来在生物、物理、工程等领域进行统计建模、数据分析、预测等。下面是官方介绍：</p><blockquote><p>Stan is a state-of-the-art platform for statistical modeling and high-performance statistical computation. Thousands of users rely on Stan for statistical modeling, data analysis, and prediction in the social, biological, and physical sciences, engineering, and business.</p><p>官网： <a href="https://www.douban.com/link2/?url=http%3A%2F%2Fmc-stan.org%2F&amp;link2key=2990a489d7" target="_blank" rel="noopener">http://mc-stan.org/</a></p><p>使用手册：<a href="https://mc-stan.org/users/documentation/" target="_blank" rel="noopener">https://mc-stan.org/users/documentation/</a></p></blockquote><p>使用stan进行贝叶斯分析，需要编写stan程序，然后再R或python等调用stan程序，编译为c++程序进行计算。例如在R当中可以使用rstan包来进行计算，非常方便。</p><h2 id="第一部分-环境准备"><a href="#第一部分-环境准备" class="headerlink" title="第一部分 环境准备"></a>第一部分 环境准备</h2><p>ubuntu环境，使用pip命令直接安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pip install pystan</span></span><br></pre></td></tr></table></figure><blockquote><p>You will also need a C++ compiler such as gcc ≥9.0 or clang ≥10.0.</p></blockquote><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p><a href="https://people.duke.edu/~ccc14/sta-663/PyStan.html" target="_blank" rel="noopener">https://people.duke.edu/~ccc14/sta-663/PyStan.html</a></p><p><a href="https://towardsdatascience.com/an-introduction-to-bayesian-inference-in-pystan-c27078e58d53" target="_blank" rel="noopener">https://towardsdatascience.com/an-introduction-to-bayesian-inference-in-pystan-c27078e58d53</a></p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、官网介绍：<a href="https://github.com/stan-dev/pystan" target="_blank" rel="noopener">https://github.com/stan-dev/pystan</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分   第一个项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分  总结&lt;/p
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python系列文章-NeuralProphet时间序列预测包使用</title>
    <link href="https://zjrongxiang.github.io/posts/e0a9b868/"/>
    <id>https://zjrongxiang.github.io/posts/e0a9b868/</id>
    <published>2022-10-03T14:42:00.000Z</published>
    <updated>2022-10-25T15:01:29.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分   第一个项目</p></li><li><p>第二部分  总结</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>NeuralProphet之一：安装与使用</p><p>论文PDF： NeuralProphet: Explainable Forecasting at Scale 文档地址：<a href="https://neuralprophet.com/html/contents.html" target="_blank" rel="noopener">https://neuralprophet.com/html/contents.html</a><br>数据地址：<a href="https://github.com/ourownstory/neuralprophet-data" target="_blank" rel="noopener">https://github.com/ourownstory/neuralprophet-data</a><br>示例地址：<a href="https://github.com/ourownstory/neural_prophet/tree/main/tutorials" target="_blank" rel="noopener">https://github.com/ourownstory/neural_prophet/tree/main/tutorials</a></p><p>1 概述<br>NeuralProphet模型集成了Prophet的所有优点，不仅具有不错的可解释性，还有优于Prophet的预测性能。</p><p>使用PyTorch作为后端进行优化的梯度下降法。<br>使用AR-Net对时间序列的自相关进行建模。<br>使用seepearate前馈神经网络对滞后回归者进行建模。<br>可配置的FFNNs非线性深层。<br>可调整到特定的预测范围（大于1）。<br>自定义损失和指标。<br>2 安装<br>pip install neuralprophet<br>1.<br>3 使用<br>导入包：</p><p>from neuralprophet import<br>1.<br>调用：</p><p>m = NeuralProphet()<br>metrics = m.fit(df)<br>forecast = m.predict(df)<br>1.<br>2.<br>3.<br>可视化结果：</p><p>fig_forecast = m.plot(forecast)<br>fig_components = m.plot_components(forecast)<br>fig_model = m.plot_parameters()<br>1.<br>2.<br>3.<br>预测：</p><p>m = NeuralProphet().fit(df, freq=”D”)<br>df_future = m.make_future_dataframe(df, periods=30)<br>forecast = m.predict(df_future)<br>fig_forecast = m.plot(forecast)</p><h2 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h2><p><a href="https://blog.51cto.com/shanglianlm/5605590" target="_blank" rel="noopener">https://blog.51cto.com/shanglianlm/5605590</a></p><p><a href="https://zhuanlan.zhihu.com/p/333210630" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/333210630</a></p><table><thead><tr><th>Parameter</th><th>Default Value</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>growth</td><td>linear</td><td></td><td></td></tr><tr><td>changepoints</td><td>None</td><td>手动设置改变点</td><td></td></tr><tr><td>n_changepoints</td><td>5</td><td>控制趋势灵活度</td><td></td></tr><tr><td>changepoints_range</td><td>0.8</td><td>默认值0.8，表示后20%的训练数据无changepoints</td><td></td></tr><tr><td>trend_reg</td><td>0</td><td>趋势正则项</td><td></td></tr><tr><td>trend_reg_threshold</td><td>False</td><td></td><td></td></tr><tr><td>yearly_seasonality</td><td>auto</td><td>默认6</td><td></td></tr><tr><td>weekly_seasonality</td><td>auto</td><td>默认 4</td><td></td></tr><tr><td>daily_seasonality</td><td>auto</td><td>默认6</td><td></td></tr><tr><td>seasonality_mode</td><td>additive</td><td></td><td>additive，multiplicative</td></tr><tr><td>seasonality_reg</td><td>0</td><td>值越大正则约束越大</td><td>0.1-1或者1-100</td></tr><tr><td>n_forecasts</td><td>1</td><td>预测范围，1意味着将来预测一步</td><td></td></tr><tr><td>n_lags</td><td>0</td><td>定义是否使用AR-Net，n_lags决定AR-Net回看步数，建议取值大于n_forecasts</td><td></td></tr><tr><td>num_hidden_layers</td><td>0</td><td>定义FFNNs的隐藏层数，0意味着只有一个隐藏层</td><td>0，1，2</td></tr><tr><td>d_hidden</td><td>None</td><td>隐藏层的单元数，如果未指定，默认为n_lags + n_forecasts</td><td>n_lags 和 n_forecasts 之间</td></tr><tr><td>ar_sparsity</td><td>None</td><td>0完全稀疏，1无正则约束</td><td>0-1</td></tr><tr><td>learning_rate</td><td>None</td><td>如果未指定，自动调整</td><td></td></tr><tr><td>epochs</td><td>None</td><td>如果未指定，根据数据大小设定</td><td></td></tr><tr><td>batch_size</td><td>None</td><td></td><td></td></tr><tr><td>loss_func</td><td>Huber</td><td>如果未指定，根据数据大小设定</td><td>Huber， MSE，torch.nn.modules.loss</td></tr><tr><td>optimizer</td><td>AdamW</td><td></td><td>AdamW，SDG</td></tr><tr><td>train_speed</td><td>None</td><td></td><td></td></tr><tr><td>normalize</td><td>auto</td><td>min-max normalization</td><td></td></tr><tr><td>impute_missing</td><td>True</td><td>惩罚缺失值</td><td></td></tr><tr><td>collect_metrics</td><td>True</td><td>默认计算mae 和 rmse</td></tr></tbody></table><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、官网介绍：<a href="https://github.com/ourownstory/neural_prophet" target="_blank" rel="noopener">https://github.com/ourownstory/neural_prophet</a></p><p><a href="https://github.com/ourownstory/neural_prophet/tree/main/tutorials" target="_blank" rel="noopener">https://github.com/ourownstory/neural_prophet/tree/main/tutorials</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分   第一个项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分  总结&lt;/p
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>翻译系列文章-NeuralProphet-可解释的大规模预测</title>
    <link href="https://zjrongxiang.github.io/posts/657c48b5/"/>
    <id>https://zjrongxiang.github.io/posts/657c48b5/</id>
    <published>2022-10-03T14:42:00.000Z</published>
    <updated>2022-10-25T15:01:29.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分   第一个项目</p></li><li><p>第二部分  总结</p></li><li><p>参考文献及资料</p></li></ul><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本位介绍了<code>Neural Prophet</code>，它是 <code>Facebook Prophet</code> 的继任者，它设定了行业标准用于可解释、可扩展和用户友好的预测框架。随着时间序列数据的增长，可解释的预测仍然是业务和运营决策指定中的一项具有挑战性的任务。需要混合解决方案来弥合可解释的经典方法之间的差距和可扩展的深度学习模型。我们将 Prophet 视为这种解决方案的先驱。然而，Prophet 缺乏当地背景，这对于预测近期未来至关重要且具有挑战性由于其 Stan 后端而扩展。</p><p>NeuralProphet 是一个基于 PyTorch 并经过标准训练的混合预测框架深度学习方法，使开发人员可以轻松扩展框架。本地环境引入了自回归和协变量模块，可以配置为经典线性回归或作为神经网络。否则NeuralProphet 保留了设计理念Prophet 并提供相同的基本模型组件。</p><p>我们的结果表明，NeuralProphet 产生可解释的预测成分在一组生成的时间序列上与 Prophet 相当或更高的质量。 NeuralProphet 表现出色Prophet 对真实世界数据集的多样化集合。对于中短期预测，NeuralProphet 将预测准确性提高了 55% 到 92%。</p><p>关键字：Explainable, Forecasting, Neural networks, Time series, Deep learning</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h3><p>时间序列数据在大多数工业领域都很重要，虽然在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间序列数据在大多数工业领域都很突出。虽然在理论上进行了广泛研究</span><br><span class="line">和经济等应用，工业应用中的实际预测尚未收到</span><br><span class="line">直到最近才受到广泛关注。</span><br></pre></td></tr></table></figure><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、官网介绍：<a href="https://github.com/ourownstory/neural_prophet" target="_blank" rel="noopener">https://github.com/ourownstory/neural_prophet</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分   第一个项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分  总结&lt;/p
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>时间序列研究系列文章-HP filter算法获取时间序列趋势</title>
    <link href="https://zjrongxiang.github.io/posts/e79245e1/"/>
    <id>https://zjrongxiang.github.io/posts/e79245e1/</id>
    <published>2022-09-28T14:42:00.000Z</published>
    <updated>2022-10-25T15:01:29.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分  Receiver接口模式</p></li><li><p>第二部分  Direct接口模式</p></li><li><p>第三部分  PySpark和Kafka交互</p></li><li><p>第四部分   任务提交</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://www.statsmodels.org/dev/examples/notebooks/generated/tsa_filters.html" target="_blank" rel="noopener">https://www.statsmodels.org/dev/examples/notebooks/generated/tsa_filters.html</a></p><p><a href="https://www.oecd-ilibrary.org/sites/361fabc3-en/index.html?itemId=/content/component/361fabc3-en" target="_blank" rel="noopener">https://www.oecd-ilibrary.org/sites/361fabc3-en/index.html?itemId=/content/component/361fabc3-en</a></p><p><a href="https://analyticsindiamag.com/a-complete-tutorial-on-time-series-filters/" target="_blank" rel="noopener">https://analyticsindiamag.com/a-complete-tutorial-on-time-series-filters/</a></p><p><a href="https://github.com/cerlymarco/MEDIUM_NoteBook" target="_blank" rel="noopener">https://github.com/cerlymarco/MEDIUM_NoteBook</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分  Receiver接口模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分 
      
    
    </summary>
    
      <category term="Time Series" scheme="https://zjrongxiang.github.io/categories/Time-Series/"/>
    
    
  </entry>
  
  <entry>
    <title>Python系列文章-Python字符串修饰符总结</title>
    <link href="https://zjrongxiang.github.io/posts/90ac3682/"/>
    <id>https://zjrongxiang.github.io/posts/90ac3682/</id>
    <published>2022-09-11T14:42:00.000Z</published>
    <updated>2022-10-25T15:01:29.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分   第一个项目</p></li><li><p>第二部分  总结</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://github.com/folospace/ChineseHoliday" target="_blank" rel="noopener">https://github.com/folospace/ChineseHoliday</a></p><p><a href="https://github.com/LKI/chinese-calendar" target="_blank" rel="noopener">https://github.com/LKI/chinese-calendar</a></p><p><a href="https://github.com/topics/chinese-holiday" target="_blank" rel="noopener">https://github.com/topics/chinese-holiday</a></p><p><a href="https://github.com/NateScarlet/holiday-cn/blob/17a8557d17a20a0dea08c7b99dfe223bd3572fc5/fetch_holidays.py#L14" target="_blank" rel="noopener">https://github.com/NateScarlet/holiday-cn/blob/17a8557d17a20a0dea08c7b99dfe223bd3572fc5/fetch_holidays.py#L14</a></p><p><a href="https://github.com/longweiqiang/get_holiday_cn" target="_blank" rel="noopener">https://github.com/longweiqiang/get_holiday_cn</a></p><p><a href="https://github.com/chariothy/Chinese-holiday" target="_blank" rel="noopener">https://github.com/chariothy/Chinese-holiday</a></p><p><a href="https://github.com/qinst64/chinaholiday" target="_blank" rel="noopener">https://github.com/qinst64/chinaholiday</a></p><p><a href="https://github.com/lanceliao/china-holiday-calender" target="_blank" rel="noopener">https://github.com/lanceliao/china-holiday-calender</a></p><p><a href="https://github.com/xbf321/iCal" target="_blank" rel="noopener">https://github.com/xbf321/iCal</a></p><p><a href="https://github.com/Diluka/chinese-holidays-ics" target="_blank" rel="noopener">https://github.com/Diluka/chinese-holidays-ics</a></p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、变量官网介绍：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分   第一个项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分  总结&lt;/p
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python系列文章-Python字符串修饰符总结</title>
    <link href="https://zjrongxiang.github.io/posts/90ac3682/"/>
    <id>https://zjrongxiang.github.io/posts/90ac3682/</id>
    <published>2022-09-11T14:42:00.000Z</published>
    <updated>2022-10-25T15:01:29.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分   第一个项目</p></li><li><p>第二部分  总结</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://new.qq.com/omn/20210223/20210223A09YTD00.html" target="_blank" rel="noopener">https://new.qq.com/omn/20210223/20210223A09YTD00.html</a></p><p><a href="https://freewechat.com/a/MzAwNDMxNDkxNQ==/2247501341/1" target="_blank" rel="noopener">https://freewechat.com/a/MzAwNDMxNDkxNQ==/2247501341/1</a></p><p><a href="https://www.sohu.com/a/294180422_260616" target="_blank" rel="noopener">https://www.sohu.com/a/294180422_260616</a></p><p><a href="https://www.thepaper.cn/newsDetail_forward_3734368" target="_blank" rel="noopener">https://www.thepaper.cn/newsDetail_forward_3734368</a></p><p><a href="https://www.thepaper.cn/newsDetail_forward_1968007" target="_blank" rel="noopener">https://www.thepaper.cn/newsDetail_forward_1968007</a></p><p>## </p><p>1、变量官网介绍：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分   第一个项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分  总结&lt;/p
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python系列文章-Python字符串修饰符总结</title>
    <link href="https://zjrongxiang.github.io/posts/90ac3682/"/>
    <id>https://zjrongxiang.github.io/posts/90ac3682/</id>
    <published>2022-09-11T14:42:00.000Z</published>
    <updated>2022-10-25T15:01:29.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分   第一个项目</p></li><li><p>第二部分  总结</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>python的字符串前面加f表示格式化字符串，加f后可以在字符串里面使用用花括号括起来的变量和表达式，如果字符串里面没有表达式，那么前面加不加f输出应该都一样.</p><p>Python3.6新增了一种f-字符串格式化</p><p>格式化的字符串文字前缀为’f’和接受的格式字符串相似str.format()。它们包含由花括号包围的替换区域。替换字段是表达式，在运行时进行评估，然后使用format()协议进行格式化。</p><p>formatted string literals, 以 f 开头，包含的{}表达式在程序运行时会被表达式的值代替。</p><p>。。。。。。。。。。</p><p>print(f’max row:{ws.max_row}’)</p><p>for row in ws[‘d1:d6’]:</p><p>   for cell in row:</p><pre><code>cell.value=f&quot;=VLOOKUP(A{cell.row},G:J,4,0)&quot;</code></pre><p>。。。。。。。。。。。。</p><p>另外：</p><p>1、字符串前加 u<br>例：u”我是含有中文字符组成的字符串。”</p><p>作用：</p><p>后面字符串以 Unicode 格式 进行编码，一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。</p><p>2、字符串前加 r<br>例：r”\n\n\n\n”　　# 表示一个普通生字符串 \n\n\n\n，而不表示换行了。</p><p>作用：</p><p>去掉反斜杠的转义机制。</p><p>（特殊字符：即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\n”表示换行，”\t”表示Tab等。 ）</p><p>应用：</p><p>常用于正则表达式，对应着re模块。</p><p>3、字符串前加 b<br>例: response = b’</p><h1>Hello World!</h1>‘     # b’ ‘ 表示这是一个 bytes 对象<p></p><p>作用：</p><p>b” “前缀表示：后面字符串是bytes 类型。</p><p>用处：</p><p>网络编程中，服务器和浏览器只认bytes 类型数据。</p><p>如：send 函数的参数和 recv 函数的返回值都是 bytes 类型</p><p>附：</p><p>在 Python3 中，bytes 和 str 的互相转换方式是</p><p>str.encode(‘utf-8’)</p><h2 id="bytes-decode-‘utf-8’"><a href="#bytes-decode-‘utf-8’" class="headerlink" title="bytes.decode(‘utf-8’)"></a>bytes.decode(‘utf-8’)</h2><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、变量官网介绍：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分   第一个项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分  总结&lt;/p
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch中数据模型总结</title>
    <link href="https://zjrongxiang.github.io/posts/d0341373/"/>
    <id>https://zjrongxiang.github.io/posts/d0341373/</id>
    <published>2022-09-09T05:30:00.000Z</published>
    <updated>2022-10-25T15:01:29.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分  <code>Search</code> 接口</li><li>第二部分  Scroll 接口</li><li>第三部分  Scan 接口</li><li>第四部分 总结</li><li>参考文献及资料</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="Lucene数据模型"><a href="#Lucene数据模型" class="headerlink" title="Lucene数据模型"></a>Lucene数据模型</h2><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分  &lt;code&gt;Search&lt;/code&gt; 接口&lt;/li&gt;
&lt;li&gt;第二部分  Scroll 接
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://zjrongxiang.github.io/categories/Elasticsearch/"/>
    
    
  </entry>
  
  <entry>
    <title>Python系列文章-SQLAlchemy库使用</title>
    <link href="https://zjrongxiang.github.io/posts/4eacc4ba/"/>
    <id>https://zjrongxiang.github.io/posts/4eacc4ba/</id>
    <published>2022-08-13T14:42:00.000Z</published>
    <updated>2022-10-25T15:01:29.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分   第一个项目</p></li><li><p>第二部分  总结</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>SQLAlchemy是Python编程语言下的一款ORM框架，该框架建立在数据库API之上，使用关系对象映射进行数据库操作，简言之便是：将对象转换成SQL，然后使用数据API执行SQL并获取执行结果。</p><ul><li>ORM 框架主要是根据<code>类和数据库表</code>之间的映射关系，帮助程序员<code>自动实现对象与数据库中数据之间的互相转化</code></li></ul><h2 id="第一部分-ORM框架"><a href="#第一部分-ORM框架" class="headerlink" title="第一部分 ORM框架"></a>第一部分 ORM框架</h2><p><a href="https://blog.51cto.com/u_3664660/3217110" target="_blank" rel="noopener">https://blog.51cto.com/u_3664660/3217110</a></p><p>ORM(Object Relational Mapping)对象关系映射，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换，简单点说就是将<a href="https://cloud.tencent.com/solution/database?from=10680" target="_blank" rel="noopener">数据库</a>里面的一条数据映射成一个对象，要对某条数据增删改查时直接操作对应的对象即可。这样带来的好处是不言而喻的，比如要insert一条记录，原始的做法是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO <span class="string">`user`</span> (<span class="string">`id`</span>, <span class="string">`account`</span>, <span class="string">`password`</span>) </span><br><span class="line">VALUES (<span class="number">1</span>, <span class="string">'it2048'</span>, <span class="string">'123456'</span>);</span><br></pre></td></tr></table></figure><p>复制</p><p>这样做会有一些问题：</p><ol><li>手写SQL很费时，遇到几十上百个字段的表，一句insert要耗费半天精力。</li><li>每次都要看着数据库客户端，不然属性名称没法写。</li><li>容易把字段的类型弄错，varchar类型的属性传入了int。</li><li>容易写出SQL注入漏洞。</li></ol><h2 id="第二部分-sqlalchemy使用"><a href="#第二部分-sqlalchemy使用" class="headerlink" title="第二部分 sqlalchemy使用"></a>第二部分 <code>sqlalchemy</code>使用</h2><p><a href="https://blog.csdn.net/aimill/article/details/81531499" target="_blank" rel="noopener">https://blog.csdn.net/aimill/article/details/81531499</a></p><p><a href="https://www.cnblogs.com/dachenzi/p/10569495.html" target="_blank" rel="noopener">https://www.cnblogs.com/dachenzi/p/10569495.html</a></p><p><a href="https://blog.csdn.net/fuchen58/article/details/81099711" target="_blank" rel="noopener">https://blog.csdn.net/fuchen58/article/details/81099711</a></p><h3 id="2-1-数据库类型"><a href="#2-1-数据库类型" class="headerlink" title="2.1 数据库类型"></a>2.1 数据库类型</h3><p>SQLAlchemy本身无法操作数据库，其必须以来pymsql等第三方插件，Dialect用于和数据API进行交流，根据配置文件的不同调用不同的数据库API，从而实现对数据库的操作.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MySQL-Python</span><br><span class="line">    mysql+mysqldb://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;</span><br><span class="line">  </span><br><span class="line">pymysql</span><br><span class="line">    mysql+pymysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;dbname&gt;[?&lt;options&gt;]</span><br><span class="line">  </span><br><span class="line">MySQL-Connector</span><br><span class="line">    mysql+mysqlconnector://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;</span><br><span class="line">  </span><br><span class="line">cx_Oracle</span><br><span class="line">    oracle+cx_oracle://user:pass@host:port/dbname[?key=value&amp;key=value...]</span><br><span class="line">  </span><br><span class="line">更多详见：http://docs.sqlalchemy.org/en/latest/dialects/index.html</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/f28304e0e3a7" target="_blank" rel="noopener">https://www.jianshu.com/p/f28304e0e3a7</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine,Table,Column,Integer,String,MetaData,ForeignKey</span><br><span class="line">engine=create_engine(<span class="string">"mysql+pymysql://root:a5230411@localhost:3306/test"</span>,echo=<span class="keyword">True</span>)</span><br><span class="line">metadata=MetaData(engine)</span><br><span class="line"></span><br><span class="line">user=Table(<span class="string">'user'</span>,metadata,</span><br><span class="line">    Column(<span class="string">'id'</span>,Integer,primary_key=<span class="keyword">True</span>),</span><br><span class="line">    Column(<span class="string">'name'</span>,String(<span class="number">20</span>)),</span><br><span class="line">    Column(<span class="string">'fullname'</span>,String(<span class="number">40</span>)),</span><br><span class="line">    )</span><br><span class="line">address_table = Table(<span class="string">'address'</span>, metadata,</span><br><span class="line">    Column(<span class="string">'id'</span>, Integer, primary_key=<span class="keyword">True</span>),</span><br><span class="line">    Column(<span class="string">'user_id'</span>, <span class="keyword">None</span>, ForeignKey(<span class="string">'user.id'</span>)),</span><br><span class="line">    Column(<span class="string">'email'</span>, String(<span class="number">128</span>), nullable=<span class="keyword">False</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">metadata.create_all()</span><br></pre></td></tr></table></figure><h2 id="第三部分-使用"><a href="#第三部分-使用" class="headerlink" title="第三部分 使用"></a>第三部分 使用</h2><p><a href="https://www.html.cn/script/python/216427.html" target="_blank" rel="noopener">https://www.html.cn/script/python/216427.html</a></p><p><a href="https://www.cnblogs.com/ccorz/p/5711955.html" target="_blank" rel="noopener">https://www.cnblogs.com/ccorz/p/5711955.html</a></p><p>案例：</p><p><a href="https://www.pythonsheets.com/notes/python-sqlalchemy.html" target="_blank" rel="noopener">https://www.pythonsheets.com/notes/python-sqlalchemy.html</a></p><p><a href="https://www.jianshu.com/p/5832c79cb9e1" target="_blank" rel="noopener">https://www.jianshu.com/p/5832c79cb9e1</a></p><h2 id="第四部分-事务管理"><a href="#第四部分-事务管理" class="headerlink" title="第四部分 事务管理"></a>第四部分 事务管理</h2><p>SQLAlchemy 的 session 是用于管理数据库操作的一个像容器一样的东西. 模型实例对象本身独立存在, 而要让其修改(创建)生效, 则需要把它们加入某个 session 。同时你也可以把模型实例对象从 session 中去除。</p><p>被 session 管理的实例对象：</p><p>session.commit() 直接将数据库内存中的数据提交到数据库，此操作会内部调用session.flush()，其余的事务可以访问最新的数据；</p><p>session.rollback() 是回滚当前事务的变更数据操作；</p><p>session.flush() 的作用是在事务管理内与数据库发生交互, 对应的实例状态被反映到数据库，比如自增 ID 被填充上值，但是数据库中当前事务的数据值并未更新上；相当于预提交，等于提交到数据库内存，还未写入数据库文件；deletions and modifications to the database as INSERTs, DELETEs, UPDATE；</p><p>session.merge(obj) 查询更新操作；就是更新之前先查询，如果没有自动插入；</p><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、官网介绍：<a href="https://www.sqlalchemy.org/；https://docs.sqlalchemy.org/en/14/dialects/index.html" target="_blank" rel="noopener">https://www.sqlalchemy.org/；https://docs.sqlalchemy.org/en/14/dialects/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分   第一个项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分  总结&lt;/p
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
</feed>
