<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RongXiang</title>
  
  <subtitle>我的烂笔头</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zjrongxiang.github.io/"/>
  <updated>2019-05-06T16:33:09.526Z</updated>
  <id>https://zjrongxiang.github.io/</id>
  
  <author>
    <name>rong xiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sqlflow初体验</title>
    <link href="https://zjrongxiang.github.io/2019/05/06/2019-05-06-Sqlflow%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://zjrongxiang.github.io/2019/05/06/2019-05-06-Sqlflow初体验/</id>
    <published>2019-05-06T14:42:00.000Z</published>
    <updated>2019-05-06T16:33:09.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>背景</p></li><li><p>第一部分   Sqlflow安装部署</p></li><li><p>第二部分   机器学习例子</p></li><li><p>第三部分   系统架构</p></li><li><p>参考文献及资料</p></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>2019年5 月 6 日，在QCon 全球软件开发大会（北京站）上，蚂蚁金服副 CTO 胡喜正式宣布开源机器学习工具 SQLFlow。实际上3个月前sqkflow项目已经在github上开源了。</p><p>本篇文件主要参考sqlflow官网的案例和说明对sqlflow进行了体验，并记录下来。</p><p>sqlflow按照官网的定义，将SQL引擎（例如MySQL，Hive，SparkSQL或SQL Server）和tensorflow和其他机器学习的桥梁。扩展了SQL语言，支持对机器学习模型训练、预测和推理。</p><blockquote><p>目前开源版本仅支持MySQL和TensorFlow</p></blockquote><p>介绍文档中也提到，在sqlflow之前也有SQL引擎提供了支持机器学习功能的扩展。</p><ul><li><a href="https://docs.microsoft.com/en-us/sql/advanced-analytics/tutorials/rtsql-create-a-predictive-model-r?view=sql-server-2017" target="_blank" rel="noopener">Microsoft SQL Server</a>：Microsoft SQL Server具有机器学习服务，可以将R或Python中的机器学习程序作为外部脚本运行。</li><li><a href="https://www.linkedin.com/pulse/sql-deep-learning-sql-dl-omri-shiv" target="_blank" rel="noopener">Teradata SQL for DL</a>：Teradata还提供RESTful服务，可以从扩展的SQL SELECT语法中调用。</li><li><a href="https://cloud.google.com/bigquery/docs/bigqueryml-intro" target="_blank" rel="noopener">Google BigQuery</a>：Google BigQuery通过引入<code>CREATE MODEL</code>语句在SQL中实现机器学习。</li></ul><h2 id="第一部分-Sqlflow安装部署"><a href="#第一部分-Sqlflow安装部署" class="headerlink" title="第一部分 Sqlflow安装部署"></a>第一部分 Sqlflow安装部署</h2><h3 id="1-1-部署mysql做为数据源"><a href="#1-1-部署mysql做为数据源" class="headerlink" title="1.1 部署mysql做为数据源"></a>1.1 部署mysql做为数据源</h3><h4 id="（1）构建镜像"><a href="#（1）构建镜像" class="headerlink" title="（1）构建镜像"></a>（1）构建镜像</h4><p>官网提供了一个dockerfile，可以git clone整个项目。</p><p><a href="https://github.com/sql-machine-learning/sqlflow/tree/7c873780bd8a3a9ea4d39ed7d0fcf154b2f8821f/example/datasets" target="_blank" rel="noopener">https://github.com/sql-machine-learning/sqlflow/tree/7c873780bd8a3a9ea4d39ed7d0fcf154b2f8821f/example/datasets</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 进入Dockerfile文件所在目录</span><br><span class="line">cd example/datasets</span><br><span class="line"><span class="meta">#</span> 使用Dockerfile构建镜像</span><br><span class="line">docker build -t sqlflow:data .</span><br></pre></td></tr></table></figure><p>可以查看创建了一个docker images：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line"><span class="meta">#</span> 创建了REPOSITORY：sqlflow镜像，TAG为：data</span><br></pre></td></tr></table></figure><h4 id="（2）启动mysql容器"><a href="#（2）启动mysql容器" class="headerlink" title="（2）启动mysql容器"></a>（2）启动mysql容器</h4><p>用镜像启mysql容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -d --name sqlflowdata \</span><br><span class="line">   -p 3306:3306 \</span><br><span class="line">   -e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">   -e MYSQL_ROOT_HOST=% \</span><br><span class="line">   sqlflow:data</span><br></pre></td></tr></table></figure><p>使用镜像：sqlflow:data，启动一个名为：sqlflowdata的容器，并且把3306端口映射到宿主机。mysql的root用户的密码为root。</p><h4 id="（3）生成测试数据"><a href="#（3）生成测试数据" class="headerlink" title="（3）生成测试数据"></a>（3）生成测试数据</h4><p>进入容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it sqlflowdata bash</span><br></pre></td></tr></table></figure><p>执行SQL语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 建库建表，注意宿主机目录：datasets</span><br><span class="line">cat /popularize_churn.sql | mysql -uroot -proot</span><br><span class="line">cat /popularize_iris.sql | mysql -uroot -proot</span><br><span class="line"><span class="meta">#</span> 建库</span><br><span class="line">echo "CREATE DATABASE IF NOT EXISTS sqlflow_models;" | mysql -uroot -proot</span><br></pre></td></tr></table></figure><p>至此完成mysql容器的启动和测试数据的生成。按Ctrl+P+Q，正常退出不关闭容器。</p><h3 id="1-2-使用docker部署slqflow"><a href="#1-2-使用docker部署slqflow" class="headerlink" title="1.2 使用docker部署slqflow"></a>1.2 使用docker部署slqflow</h3><h4 id="（1）拉取镜像并启动容器"><a href="#（1）拉取镜像并启动容器" class="headerlink" title="（1）拉取镜像并启动容器"></a>（1）拉取镜像并启动容器</h4><p>首先从docker Hub上拉取镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker pull sqlflow/sqlflow:latest</span><br></pre></td></tr></table></figure><p>启动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker run --rm -it --name sqlflowServer -p 8888:8888 sqlflow/sqlflow:latest \</span><br><span class="line">bash -c "sqlflowserver --datasource='mysql://root:root@tcp(192.168.31.3:3306)/?maxAllowedPacket=0' &amp;</span><br><span class="line">SQLFLOW_SERVER=localhost:50051 jupyter notebook --ip=0.0.0.0 --port=8888 --allow-root"</span><br></pre></td></tr></table></figure><p>命令使用镜像：sqlflow/sqlflow:lates，启动了名为：sqlflowServer的容器。将8888端口映射到宿主机上。这里需要配置datasource，指向mysql使用套接字：192.168.31.3:3306。这里使用之前构建的mysql容器的连接信息，可以根据实际情况配置。</p><blockquote><p>如果mysql套接字配置错误，报错信息：connect: connection refused</p></blockquote><p>如果没有报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2019/05/06 14:47:30 Server Started at :50051</span><br><span class="line">[I 14:47:30.261 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret</span><br><span class="line">[I 14:47:30.874 NotebookApp] Serving notebooks from local directory: /</span><br><span class="line">[I 14:47:30.874 NotebookApp] The Jupyter Notebook is running at:</span><br><span class="line">[I 14:47:30.874 NotebookApp] http://(fd2b9b3f994b or 127.0.0.1):8888/?token=265b3fc832b5b48689fa9f88483125dc9335188dd7c1d863</span><br><span class="line">[I 14:47:30.874 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</span><br><span class="line">[W 14:47:30.877 NotebookApp] No web browser found: could not locate runnable browser.</span><br></pre></td></tr></table></figure><p>这里启动了Jupyter Notebook服务，对外服务端口为8888，并且映射到宿主机。例如这里可以使用下面的url范围web界面：<a href="http://192.168.31.3:8888/?token=265b3fc832b5b48689fa9f88483125dc9335188dd7c1d863" target="_blank" rel="noopener">http://192.168.31.3:8888/?token=265b3fc832b5b48689fa9f88483125dc9335188dd7c1d863</a></p><h4 id="（2）简单测试"><a href="#（2）简单测试" class="headerlink" title="（2）简单测试"></a>（2）简单测试</h4><p>Jupyter Notebook 新建一个python3交互环境。测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span>%sqlflow</span><br><span class="line">select * from iris.train limit 5;</span><br></pre></td></tr></table></figure><p><img src="\images\picture\jupyter book.png" alt=""></p><h3 id="第二部分-机器学习例子"><a href="#第二部分-机器学习例子" class="headerlink" title="第二部分 机器学习例子"></a>第二部分 机器学习例子</h3><p>使用iris数据集体验机器学习的例子，使用Jupyter Notebook 完成：</p><h4 id="（1）训练模型："><a href="#（1）训练模型：" class="headerlink" title="（1）训练模型："></a>（1）训练模型：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%sqlflow</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> iris.train TRAIN DNNClassifier <span class="keyword">WITH</span> n_classes = <span class="number">3</span>, hidden_units = [<span class="number">10</span>, <span class="number">20</span>] <span class="keyword">COLUMN</span> sepal_length, sepal_width, petal_length, petal_width LABEL <span class="keyword">class</span> <span class="keyword">INTO</span> sqlflow_models.my_dnn_model;</span><br></pre></td></tr></table></figure><p>使用iris.train表中的数据训练神经网络。</p><p>模型训练结果输入到sqlflow_models.my_dnn_model，回显训练正确率为：0.97273</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Training set accuracy: 0.97273</span><br><span class="line">Done training</span><br></pre></td></tr></table></figure><h4 id="（2）模型应用"><a href="#（2）模型应用" class="headerlink" title="（2）模型应用"></a>（2）模型应用</h4><p>使用训练结果对数据进行预测应用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%sqlflow</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> iris.test PREDICT iris.predict.class <span class="keyword">USING</span> sqlflow_models.my_dnn_model;</span><br></pre></td></tr></table></figure><p>使用iris.test中的数据喂给训练好的模型，预测结果输出到表：iris.predict。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Done predicting. Predict table : iris.predict</span><br></pre></td></tr></table></figure><p>查看结果表中的数据案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%sqlflow</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> iris.predict <span class="keyword">limit</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------------+-------------+--------------+-------------+-------+</span><br><span class="line">| sepal_length | sepal_width | petal_length | petal_width | class |</span><br><span class="line">+--------------+-------------+--------------+-------------+-------+</span><br><span class="line">|     6.3      |     2.7     |     4.9      |     1.8     |   2   |</span><br><span class="line">|     5.7      |     2.8     |     4.1      |     1.3     |   1   |</span><br><span class="line">+--------------+-------------+--------------+-------------+-------+</span><br></pre></td></tr></table></figure><h3 id="第三部分-系统架构"><a href="#第三部分-系统架构" class="headerlink" title="第三部分 系统架构"></a>第三部分 系统架构</h3><p>系统原型使用下面的架构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL statement -&gt; our SQL parser --standard SQL-&gt; MySQL</span><br><span class="line">                                \-extended SQL-&gt; code generator -&gt; execution engine</span><br></pre></td></tr></table></figure><p>原型运行的数据流为：</p><ol><li>它通过<a href="https://dev.mysql.com/downloads/connector/python/" target="_blank" rel="noopener">MySQL Connector Python API</a>从MySQL检索数据</li><li>从MySQL检索模型</li><li>通过调用用户指定的TensorFlow估算器训练模型或使用训练模型进行预测</li><li>并将训练过的模型或预测结果写入表格</li></ol><h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、sqlflow项目官网 链接：<a href="https://github.com/sql-machine-learning/sqlflow" target="_blank" rel="noopener">https://github.com/sql-machine-learning/sqlflow</a></p><p>2、会 SQL 就能搞定 AI！蚂蚁金服重磅开源机器学习工具 SQLFlow 链接：<a href="https://www.infoq.cn/article/vlVqC68h2MT-028lh68C" target="_blank" rel="noopener">https://www.infoq.cn/article/vlVqC68h2MT-028lh68C</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一部分   Sqlflow安装部署&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二部分 
      
    
    </summary>
    
      <category term="sqlflow" scheme="https://zjrongxiang.github.io/categories/sqlflow/"/>
    
    
  </entry>
  
  <entry>
    <title>Hive介绍及部署</title>
    <link href="https://zjrongxiang.github.io/2018/08/14/2018-08-13-Hive-install/"/>
    <id>https://zjrongxiang.github.io/2018/08/14/2018-08-13-Hive-install/</id>
    <published>2018-08-14T11:30:00.000Z</published>
    <updated>2018-08-21T05:07:53.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Hive（蜂巢）是Hadoop的组件，官方介绍为：</p><blockquote><p><a href="http://hive.apache.org/" target="_blank" rel="noopener"><strong>Hive™</strong></a>: A data warehouse infrastructure that provides data summarization and ad hoc querying.</p></blockquote><p>Hive有三种部署方式（本质是Hive Metastore的三种部署方式）：</p><ol><li><p>Embedded Metastore Database (Derby) 内嵌模式</p><p>内嵌模式使用的是内嵌的Derby数据库来存储元数据，也不需要额外起Metastore服务。这个是默认的，配置简单，但是一次只能一个客户端连接（Derby只提供单进程存储），适用于用来实验，不适用于生产环境。 </p></li><li><p>Local Metastore Server 本地元存储</p><p>采用外部数据库来存储元数据 。本地元存储不需要单独起metastore服务，用的是跟hive在同一个进程里的metastore服务 。</p><p>目前支持：Derby，Mysql，微软SQLServer，Oracle和Postgres </p></li><li><p>Remote Metastore Server 远程元存储</p><p>采用外部数据库来存储元数据 。远程元存储需要单独起metastore服务，然后每个客户端都在配置文件里配置连接到该metastore服务。远程元存储的metastore服务和hive运行在不同的进程里。</p><p>远程元存储是生产环境部署方式。</p></li></ol><h2 id="本地部署过程"><a href="#本地部署过程" class="headerlink" title="本地部署过程"></a>本地部署过程</h2><blockquote><p>由于设备资源限制，没有太多机器配置类似生产环境的集群环境。所以通过docker搭建大集群环境。</p></blockquote><h4 id="搭建目标："><a href="#搭建目标：" class="headerlink" title="搭建目标："></a>搭建目标：</h4><ul><li>集群中hadoop集群由3台构成（1台master，2台slaves）</li><li>Hive的元数据库使用Mysql，并且单独包裹在一个docker环境中。</li></ul><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>准备hadoop集群环境。启docker集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   IMAGE    COMMAND      CREATED    STATUS   PORTS      NAMES</span><br><span class="line">c27312e13270  kiwenlau/hadoop:1.0  "sh -c 'service ssh …"  2 hours ago  Up 2 hours hadoop-slave2</span><br><span class="line">f8b69885f3ef  kiwenlau/hadoop:1.0  "sh -c 'service ssh …" 2 hours ago  Up 2 hours hadoop-slave1</span><br><span class="line">439b359d230e  kiwenlau/hadoop:1.0  "sh -c 'service ssh …"   2 hours ago  Up 2 hours  0.0.0.0:8088-&gt;8088/tcp, 0.0.0.0:50070-&gt;50070/tcp   hadoop-master</span><br></pre></td></tr></table></figure><h4 id="Hive部署"><a href="#Hive部署" class="headerlink" title="Hive部署"></a>Hive部署</h4><h5 id="下载安装包："><a href="#下载安装包：" class="headerlink" title="下载安装包："></a>下载安装包：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 进入hadoop-master主机，进入hadoop目录：/use/local/hadoop</span><br><span class="line">wget http://apache.claz.org/hive/hive-2.3.3/apache-hive-2.3.3-bin.tar.gz</span><br><span class="line">tar -zxvf apache-hive-2.3.3-bin.tar.gz</span><br><span class="line">mv apache-hive-2.3.3-bin hive</span><br></pre></td></tr></table></figure><h5 id="配置Hive环境变量："><a href="#配置Hive环境变量：" class="headerlink" title="配置Hive环境变量："></a>配置Hive环境变量：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"><span class="meta">#</span>hive</span><br><span class="line">export HIVE_HOME=/usr/local/hadoop/hive</span><br><span class="line">PATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$HIVE_HOME/bin:$PATH</span><br><span class="line"><span class="meta">#</span> 生效环境变量</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h5 id="调整Hive的配置文件："><a href="#调整Hive的配置文件：" class="headerlink" title="调整Hive的配置文件："></a>调整Hive的配置文件：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 进入hive 配置文件目录：</span><br><span class="line">cd conf</span><br><span class="line">cp hive-default.xml.template hive-site.xml</span><br><span class="line"># 修改配置文件</span><br><span class="line">vim hive-site.xml</span><br></pre></td></tr></table></figure><h5 id="新建HDFS分布式文件目录："><a href="#新建HDFS分布式文件目录：" class="headerlink" title="新建HDFS分布式文件目录："></a>新建HDFS分布式文件目录：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> hadoop已经设置好环境变量，新建下面目录</span><br><span class="line">hadoop fs -mkdir -p /user/hive/warehouse  </span><br><span class="line">hadoop fs -mkdir -p /user/hive/tmp  </span><br><span class="line">hadoop fs -mkdir -p /user/hive/log </span><br><span class="line"><span class="meta">#</span> 设置目录权限</span><br><span class="line">hadoop fs -chmod -R 777 /user/hive/warehouse  </span><br><span class="line">hadoop fs -chmod -R 777 /user/hive/tmp  </span><br><span class="line">hadoop fs -chmod -R 777 /user/hive/log</span><br></pre></td></tr></table></figure><p>可以用下面命令进行检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@hadoop-master:/usr/local/hadoop/hive/conf# hadoop fs -ls /user/hive</span><br><span class="line">Found 3 items</span><br><span class="line">drwxrwxrwx   - root supergroup          0 2018-08-14 07:34 /user/hive/log</span><br><span class="line">drwxrwxrwx   - root supergroup          0 2018-08-14 07:34 /user/hive/tmp</span><br><span class="line">drwxrwxrwx   - root supergroup          0 2018-08-14 07:34 /user/hive/warehouse</span><br></pre></td></tr></table></figure><h5 id="修改配置文件（hive-site-xml）："><a href="#修改配置文件（hive-site-xml）：" class="headerlink" title="修改配置文件（hive-site.xml）："></a>修改配置文件（hive-site.xml）：</h5><p>hive数据仓库数据路径：/user/hive/warehouse</p><p>需要使用hdfs新建文件目录。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/hive/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>location of default database for the warehouse<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置查询日志存放目录：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.querylog.location<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/hive/log/hadoop<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Location of Hive run time structured log file<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>数据库JDBC连接配置（172.18.0.5为mysql的ip地址，暴露3306端口）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;jdbc:mysql://172.18.0.5:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>数据库驱动：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Driver class name for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>数据库用户名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Username to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>数据库密码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>password to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置Hive临时目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/hadoop/hive/tmp</span><br></pre></td></tr></table></figure><p>并在 <code>hive-site.xml</code> 中修改:</p><p>把<code>${system:java.io.tmpdir}</code> 改成真实物理绝对路径  /usr/local/hadoop/hive/tmp</p><p>把 <code>${system:user.name}</code> 改成 <code>${user.name}</code></p><blockquote><p>可以在外面编辑好配置文件，拷贝进docke：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker cp hive-site.xml 439b359d230e:/usr/local/hadoop/hive/conf/hive-site.xml</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><h4 id="配置hive-env-sh文件："><a href="#配置hive-env-sh文件：" class="headerlink" title="配置hive-env.sh文件："></a>配置hive-env.sh文件：</h4><p>尾部加上下面的配置（或者修改注释部分的配置亦可）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HADOOP_HOME=/usr/local/hadoop</span><br><span class="line">export HIVE_CONF_DIR=/usr/local/hadoop/hive/conf</span><br><span class="line">export HIVE_AUX_JARS_PATH=/usr/local/hadoop/hive/lib</span><br></pre></td></tr></table></figure><h4 id="配置Mysql"><a href="#配置Mysql" class="headerlink" title="配置Mysql"></a>配置Mysql</h4><p>启mysql容器，容器名：first-mysql，使用和hadoop一个桥接网络hadoop，密码为123456</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name first-mysql --net=hadoop -p 3306:3306 -e MYSQL\_ROOT\_PASSWORD=123456 -d mysql:5.7</span><br></pre></td></tr></table></figure><p>回显：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                                              NAMES</span><br><span class="line">84ae224cee53        mysql:5.7             "docker-entrypoint.s…"   32 minutes ago      Up 32 minutes       0.0.0.0:3306-&gt;3306/tcp                             first-mysql</span><br></pre></td></tr></table></figure><p>在Hadoop-master中配置mysql客户端（用来访问mysql服务器）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install mysql-client-core-5.6</span><br></pre></td></tr></table></figure><p>测试远程连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h172.18.0.5 -P3306 -uroot -p123456</span><br></pre></td></tr></table></figure><p>新建数据库，数据库名为hive：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE hive;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>初始化（Hive主机上）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/hadoop/hive/bin</span><br><span class="line">./schematool -initSchema -dbType mysql</span><br></pre></td></tr></table></figure><p>回显：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@hadoop-master:/usr/local/hadoop/hive/bin# ./schematool -initSchema -dbType mysql</span><br><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">。。。（略）</span><br><span class="line">schemaTool completed</span><br><span class="line"><span class="meta">#</span> 初始化成功</span><br></pre></td></tr></table></figure><p>下载配置mysql驱动包，放在Hive的lib路径下面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/hadoop/hive/lib</span><br><span class="line">wget http://central.maven.org/maven2/mysql/mysql-connector-java/5.1.38/mysql-connector-java-5.1.38.jar</span><br></pre></td></tr></table></figure><h3 id="启动Hive"><a href="#启动Hive" class="headerlink" title="启动Hive"></a>启动Hive</h3><p>做完上面准备工作后，开始启动hive：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@hadoop-master:/usr/local/hadoop/hive/bin# ./hive</span><br><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:/usr/local/hadoop/hive/lib/log4j-slf4j-impl-2.6.2.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/usr/local/hadoop/share/hadoop/common/lib/slf4j-log4j12-1.7.10.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]</span><br><span class="line"></span><br><span class="line">Logging initialized using configuration in jar:file:/usr/local/hadoop/hive/lib/hive-common-2.3.3.jar!/hive-log4j2.properties Async: true</span><br><span class="line">Hive-on-MR is deprecated in Hive 2 and may not be available in the future versions. Consider using a different execution engine (i.e. tez, spark) or using Hive 1.X releases.</span><br><span class="line"><span class="meta">hive&gt;</span></span><br></pre></td></tr></table></figure><p>最后进入hive的命令界面。</p><h3 id="踩坑备注"><a href="#踩坑备注" class="headerlink" title="踩坑备注"></a>踩坑备注</h3><p>1、Hive提示SSL连接警告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tue Aug 14 10:53:12 UTC 2018 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.</span><br></pre></td></tr></table></figure><p>虽然Hive SQL执行成功，但是报上面的错误。产生的原因是使用JDBC连接MySQL服务器时为设置<code>useSSL</code>参数 。</p><p>解决办法：javax.jdo.option.ConnectionURL 配置的value值进行调整，设置<code>useSSL=false</code> ，注意xml中的语法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://172.18.0.5:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">    JDBC connect string for a JDBC metastore.</span><br><span class="line">    To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL.</span><br><span class="line">    For example, jdbc:postgresql://myhost/db?ssl=true for postgres database.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启Hive，不再有警告。</p><h2 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h2><p>对于远程部署需要单独启metastore服务，具体需要调整下面的配置文件（hive-site.xml）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.uris<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>thrift://hadoop-master:9083<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动metastore服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup hive --service metastore &amp;</span><br></pre></td></tr></table></figure><p>当然这属于简单方式将Hive都扎堆部署在一个容器中。可以在集群其他几点启metastore服务，提升架构的高可用性，避免单点问题。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>1、Apache Hive-2.3.0 快速搭建与使用，<a href="https://segmentfault.com/a/1190000011303459" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011303459</a></p><p>2、Hive提示警告SSL，<a href="https://blog.csdn.net/u012922838/article/details/73291524" target="_blank" rel="noopener">https://blog.csdn.net/u012922838/article/details/73291524</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Hive（蜂巢）是Hadoop的组件，官方介绍为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://hive.apa
      
    
    </summary>
    
      <category term="hadoop" scheme="https://zjrongxiang.github.io/categories/hadoop/"/>
    
    
  </entry>
  
  <entry>
    <title>在Minikube上运行Spark集群</title>
    <link href="https://zjrongxiang.github.io/2018/06/25/2018-08-06-%E5%9C%A8Minikube%E4%B8%8A%E8%BF%90%E8%A1%8CSpark%E9%9B%86%E7%BE%A4/"/>
    <id>https://zjrongxiang.github.io/2018/06/25/2018-08-06-在Minikube上运行Spark集群/</id>
    <published>2018-06-25T11:30:00.000Z</published>
    <updated>2019-04-23T13:48:55.484Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​     Spark2.3版本开始支持使用spark-submit直接提交任务给Kubernetes集群。执行机制原理：</p><ul><li>Spark创建一个在<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener">Kubernetes pod中</a>运行的Spark驱动程序。</li><li>驱动程序创建执行程序，这些执行程序也在Kubernetes pod中运行并连接到它们，并执行应用程序代码。</li><li>当应用程序完成时，执行程序窗格会终止并清理，但驱动程序窗格会保留日志并在Kubernetes API中保持“已完成”状态，直到它最终被垃圾收集或手动清理。</li></ul><p><img src="https://spark.apache.org/docs/latest/img/k8s-cluster-mode.png" alt="Spark集群组件"> </p><h3 id="第一部分-环境准备"><a href="#第一部分-环境准备" class="headerlink" title="第一部分 环境准备"></a>第一部分 环境准备</h3><h4 id="1-1-minikube虚拟机准备"><a href="#1-1-minikube虚拟机准备" class="headerlink" title="1.1 minikube虚拟机准备"></a>1.1 minikube虚拟机准备</h4><p>由于spark集群对内存和cpu资源要求较高，在minikube启动前，提前配置较多的资源给虚拟机。</p><blockquote><p>当minikube启动时，它以单节点配置开始，默认情况下占用<code>1Gb</code>内存和<code>2</code>CPU内核，但是，为了运行spark集群，这个资源配置是不够的，而且作业会失败。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> minikube config set memory 8192</span><br><span class="line">These changes will take effect upon a minikube delete and then a minikube start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> minikube config set cpus 2</span><br><span class="line">These changes will take effect upon a minikube delete and then a minikube start</span><br></pre></td></tr></table></figure><p>或者用下面的命令启集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> minikube start --cpus 2 --memory 8192</span><br></pre></td></tr></table></figure><h4 id="1-2-Spark环境准备"><a href="#1-2-Spark环境准备" class="headerlink" title="1.2 Spark环境准备"></a>1.2 Spark环境准备</h4><p>第一步   下载saprk2.3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> wget http://apache.mirrors.hoobly.com/spark/spark-2.3.0/spark-2.3.0-bin-hadoop2.7.tgz</span><br></pre></td></tr></table></figure><p>解压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar xvf spark-2.3.0-bin-hadoop2.7.tgz</span><br></pre></td></tr></table></figure><p>制作docker镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cd spark-2.3.0-bin-hadoop2.7</span><br><span class="line"><span class="meta">#</span> docker build -t rongxiang/spark:2.3.0 -f kubernetes/dockerfiles/spark/Dockerfile .</span><br></pre></td></tr></table></figure><p>查看镜像情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker images</span><br><span class="line">REPOSITORY                                                              TAG                            IMAGE ID            CREATED             SIZE</span><br><span class="line">rongxiang1986/spark                                                     2.3.0                          c5c806314f25        5 days ago          346MB</span><br></pre></td></tr></table></figure><p>登录docker 账户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker login</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">Username: </span><br><span class="line">Password: </span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><p>将之前build好的镜像pull到docker hub上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> docker push rongxiang1986/spark:2.3.0</span><br></pre></td></tr></table></figure><blockquote><p>注意这里的格式要求（我踩坑了）：docker push 注册用户名/镜像名 </p></blockquote><p>在<a href="https://hub.docker.com/上查看，镜像确实push上去了。" target="_blank" rel="noopener">https://hub.docker.com/上查看，镜像确实push上去了。</a></p><h3 id="第二部分-提交Spark作业"><a href="#第二部分-提交Spark作业" class="headerlink" title="第二部分 提交Spark作业"></a>第二部分 提交Spark作业</h3><h4 id="2-1-作业提交"><a href="#2-1-作业提交" class="headerlink" title="2.1 作业提交"></a>2.1 作业提交</h4><p>提前配置serviceaccount信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> kubectl create serviceaccount spark</span><br><span class="line">serviceaccount/spark created</span><br><span class="line"><span class="meta">#</span> kubectl create clusterrolebinding spark-role --clusterrole=edit --serviceaccount=default:spark --namespace=default</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/spark-role created</span><br></pre></td></tr></table></figure><p> 提交作业：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> ./spark-submit \</span><br><span class="line">--master k8s://https://192.168.99.100:8443 \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--name spark-pi \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--conf spark.kubernetes.authenticate.driver.serviceAccountName=spark \</span><br><span class="line">--conf spark.kubernetes.authenticate.executor.serviceAccountName=spark \</span><br><span class="line">--conf spark.executor.instances=2 \</span><br><span class="line">--conf spark.kubernetes.container.image=rongxiang1986/spark:2.3.0 \</span><br><span class="line">local:///opt/spark/examples/jars/spark-examples_2.11-2.3.0.jar</span><br></pre></td></tr></table></figure><p>提交命令的参数含义分别是：</p><ul><li><code>--class</code>：应用程序的入口点（命令中使用：org.apache.spark.examples.SparkPi）；</li><li><code>--master</code>：Kubernetes集群的URL（k8s://<a href="https://192.168.99.100:8443）；" target="_blank" rel="noopener">https://192.168.99.100:8443）；</a></li><li><code>--deploy-mode</code>：驱动程序部署位置（默认值：客户端），这里部署在集群中；</li><li><code>--conf spark.executor.instances=2</code>：运行作业启动的executor个数；</li><li><code>--conf spark.kubernetes.container.image=rongxiang1986/spark:2.3.0</code>：使用的docker镜像名称；</li><li><code>local:///opt/spark/examples/jars/spark-examples_2.11-2.3.0.jar</code>：应用程序依赖jar包路径；</li></ul><blockquote><p>注意：目前deploy-mode只支持cluster模式，不支持client模式。</p><p>Error: Client mode is currently not supported for Kubernetes.</p></blockquote><p>作业运行回显如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">2018-08-12 15:51:17 WARN  Utils:66 - Your hostname, deeplearning resolves to a loopback address: 127.0.1.1; using 192.168.31.3 instead (on interface enp0s31f6)</span><br><span class="line">2018-08-12 15:51:17 WARN  Utils:66 - Set SPARK_LOCAL_IP if you need to bind to another address</span><br><span class="line">2018-08-12 15:51:18 INFO  LoggingPodStatusWatcherImpl:54 - State changed, new state: </span><br><span class="line"> pod name: spark-pi-7314d819cd3730b4bf7d02bfedd21373-driver</span><br><span class="line"> namespace: default</span><br><span class="line"> labels: spark-app-selector -&gt; spark-8be4d909d85148bc9f1f91d511c275c6, spark-role -&gt; driver</span><br><span class="line"> pod uid: 7f6dd84d-9e04-11e8-b58f-080027b3a6c0</span><br><span class="line"> creation time: 2018-08-12T07:51:18Z</span><br><span class="line"> service account name: spark</span><br><span class="line"> volumes: spark-token-rzrgk</span><br><span class="line"> node name: N/A</span><br><span class="line"> start time: N/A</span><br><span class="line"> container images: N/A</span><br><span class="line"> phase: Pending</span><br><span class="line"> status: []</span><br><span class="line">2018-08-12 15:51:18 INFO  LoggingPodStatusWatcherImpl:54 - State changed, new state: </span><br><span class="line"> pod name: spark-pi-7314d819cd3730b4bf7d02bfedd21373-driver</span><br><span class="line"> namespace: default</span><br><span class="line"> labels: spark-app-selector -&gt; spark-8be4d909d85148bc9f1f91d511c275c6, spark-role -&gt; driver</span><br><span class="line"> pod uid: 7f6dd84d-9e04-11e8-b58f-080027b3a6c0</span><br><span class="line"> creation time: 2018-08-12T07:51:18Z</span><br><span class="line"> service account name: spark</span><br><span class="line"> volumes: spark-token-rzrgk</span><br><span class="line"> node name: minikube</span><br><span class="line"> start time: N/A</span><br><span class="line"> container images: N/A</span><br><span class="line"> phase: Pending</span><br><span class="line"> status: []</span><br><span class="line">2018-08-12 15:51:18 INFO  LoggingPodStatusWatcherImpl:54 - State changed, new state: </span><br><span class="line"> pod name: spark-pi-7314d819cd3730b4bf7d02bfedd21373-driver</span><br><span class="line"> namespace: default</span><br><span class="line"> labels: spark-app-selector -&gt; spark-8be4d909d85148bc9f1f91d511c275c6, spark-role -&gt; driver</span><br><span class="line"> pod uid: 7f6dd84d-9e04-11e8-b58f-080027b3a6c0</span><br><span class="line"> creation time: 2018-08-12T07:51:18Z</span><br><span class="line"> service account name: spark</span><br><span class="line"> volumes: spark-token-rzrgk</span><br><span class="line"> node name: minikube</span><br><span class="line"> start time: 2018-08-12T07:51:18Z</span><br><span class="line"> container images: rongxiang1986/spark:2.3.0</span><br><span class="line"> phase: Pending</span><br><span class="line"> status: [ContainerStatus(containerID=null, image=rongxiang1986/spark:2.3.0, imageID=, lastState=ContainerState(running=null, terminated=null, waiting=null, additionalProperties=&#123;&#125;), name=spark-kubernetes-driver, ready=false, restartCount=0, state=ContainerState(running=null, terminated=null, waiting=ContainerStateWaiting(message=null, reason=ContainerCreating, additionalProperties=&#123;&#125;), additionalProperties=&#123;&#125;), additionalProperties=&#123;&#125;)]</span><br><span class="line">2018-08-12 15:51:18 INFO  Client:54 - Waiting for application spark-pi to finish...</span><br><span class="line">2018-08-12 15:51:51 INFO  LoggingPodStatusWatcherImpl:54 - State changed, new state: </span><br><span class="line"> pod name: spark-pi-7314d819cd3730b4bf7d02bfedd21373-driver</span><br><span class="line"> namespace: default</span><br><span class="line"> labels: spark-app-selector -&gt; spark-8be4d909d85148bc9f1f91d511c275c6, spark-role -&gt; driver</span><br><span class="line"> pod uid: 7f6dd84d-9e04-11e8-b58f-080027b3a6c0</span><br><span class="line"> creation time: 2018-08-12T07:51:18Z</span><br><span class="line"> service account name: spark</span><br><span class="line"> volumes: spark-token-rzrgk</span><br><span class="line"> node name: minikube</span><br><span class="line"> start time: 2018-08-12T07:51:18Z</span><br><span class="line"> container images: rongxiang1986/spark:2.3.0</span><br><span class="line"> phase: Running</span><br><span class="line"> status: [ContainerStatus(containerID=docker://d43089c8340affc4534f796b94a90ae080670c36c095176575fbeebacaab648e, image=rongxiang1986/spark:2.3.0, imageID=docker-pullable://rongxiang1986/spark@sha256:3e93a2d462679015a9fb7d723f53ab1d62c5e3619e3f1564d182c3d297ddf75d, lastState=ContainerState(running=null, terminated=null, waiting=null, additionalProperties=&#123;&#125;), name=spark-kubernetes-driver, ready=true, restartCount=0, state=ContainerState(running=ContainerStateRunning(startedAt=Time(time=2018-08-12T07:51:51Z, additionalProperties=&#123;&#125;), additionalProperties=&#123;&#125;), terminated=null, waiting=null, additionalProperties=&#123;&#125;), additionalProperties=&#123;&#125;)]</span><br><span class="line">2018-08-12 15:51:57 INFO  LoggingPodStatusWatcherImpl:54 - State changed, new state: </span><br><span class="line"> pod name: spark-pi-7314d819cd3730b4bf7d02bfedd21373-driver</span><br><span class="line"> namespace: default</span><br><span class="line"> labels: spark-app-selector -&gt; spark-8be4d909d85148bc9f1f91d511c275c6, spark-role -&gt; driver</span><br><span class="line"> pod uid: 7f6dd84d-9e04-11e8-b58f-080027b3a6c0</span><br><span class="line"> creation time: 2018-08-12T07:51:18Z</span><br><span class="line"> service account name: spark</span><br><span class="line"> volumes: spark-token-rzrgk</span><br><span class="line"> node name: minikube</span><br><span class="line"> start time: 2018-08-12T07:51:18Z</span><br><span class="line"> container images: rongxiang1986/spark:2.3.0</span><br><span class="line"> phase: Succeeded</span><br><span class="line"> status: [ContainerStatus(containerID=docker://d43089c8340affc4534f796b94a90ae080670c36c095176575fbeebacaab648e, image=rongxiang1986/spark:2.3.0, imageID=docker-pullable://rongxiang1986/spark@sha256:3e93a2d462679015a9fb7d723f53ab1d62c5e3619e3f1564d182c3d297ddf75d, lastState=ContainerState(running=null, terminated=null, waiting=null, additionalProperties=&#123;&#125;), name=spark-kubernetes-driver, ready=false, restartCount=0, state=ContainerState(running=null, terminated=ContainerStateTerminated(containerID=docker://d43089c8340affc4534f796b94a90ae080670c36c095176575fbeebacaab648e, exitCode=0, finishedAt=Time(time=2018-08-12T07:51:57Z, additionalProperties=&#123;&#125;), message=null, reason=Completed, signal=null, startedAt=Time(time=2018-08-12T07:51:51Z, additionalProperties=&#123;&#125;), additionalProperties=&#123;&#125;), waiting=null, additionalProperties=&#123;&#125;), additionalProperties=&#123;&#125;)]</span><br><span class="line">2018-08-12 15:51:57 INFO  LoggingPodStatusWatcherImpl:54 - Container final statuses:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Container name: spark-kubernetes-driver</span><br><span class="line"> Container image: rongxiang1986/spark:2.3.0</span><br><span class="line"> Container state: Terminated</span><br><span class="line"> Exit code: 0</span><br><span class="line">2018-08-12 15:51:57 INFO  Client:54 - Application spark-pi finished.</span><br><span class="line">2018-08-12 15:51:57 INFO  ShutdownHookManager:54 - Shutdown hook called</span><br><span class="line">2018-08-12 15:51:57 INFO  ShutdownHookManager:54 - Deleting directory /tmp/spark-6dd1c204-4ad7-40c4-b47f-a34f18e1995d</span><br></pre></td></tr></table></figure><h4 id="2-2-日志查询"><a href="#2-2-日志查询" class="headerlink" title="2.2 日志查询"></a>2.2 日志查询</h4><p>可以通过命令查看容器执行日志，或者通过kubernetes-dashboard提供web界面查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> kubectl logs spark-pi-709e1c1b19813e7cbc1aeff45200c64e-driver</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2018-08-12 07:51:57 INFO  DAGScheduler:54 - Job 0 finished: reduce at SparkPi.scala:38, took 0.576528 s</span><br><span class="line">Pi is roughly 3.1336756683783418</span><br><span class="line">2018-08-12 07:51:57 INFO  AbstractConnector:318 - Stopped Spark@9635fa&#123;HTTP/1.1,[http/1.1]&#125;&#123;0.0.0.0:4040&#125;</span><br><span class="line">2018-08-12 07:51:57 INFO  SparkUI:54 - Stopped Spark web UI at http://spark-pi-7314d819cd3730b4bf7d02bfedd21373-driver-svc.default.svc:4040</span><br><span class="line">2018-08-12 07:51:57 INFO  KubernetesClusterSchedulerBackend:54 - Shutting down all executors</span><br><span class="line">2018-08-12 07:51:57 INFO  KubernetesClusterSchedulerBackend$KubernetesDriverEndpoint:54 - Asking each executor to shut down</span><br><span class="line">2018-08-12 07:51:57 INFO  KubernetesClusterSchedulerBackend:54 - Closing kubernetes client</span><br><span class="line">2018-08-12 07:51:57 INFO  MapOutputTrackerMasterEndpoint:54 - MapOutputTrackerMasterEndpoint stopped!</span><br><span class="line">2018-08-12 07:51:57 INFO  MemoryStore:54 - MemoryStore cleared</span><br><span class="line">2018-08-12 07:51:57 INFO  BlockManager:54 - BlockManager stopped</span><br><span class="line">2018-08-12 07:51:57 INFO  BlockManagerMaster:54 - BlockManagerMaster stopped</span><br><span class="line">2018-08-12 07:51:57 INFO  OutputCommitCoordinator$OutputCommitCoordinatorEndpoint:54 - OutputCommitCoordinator stopped!</span><br><span class="line">2018-08-12 07:51:57 INFO  SparkContext:54 - Successfully stopped SparkContext</span><br><span class="line">2018-08-12 07:51:57 INFO  ShutdownHookManager:54 - Shutdown hook called</span><br><span class="line">2018-08-12 07:51:57 INFO  ShutdownHookManager:54 - Deleting directory /tmp/spark-435d5ab2-f7b4-45d0-a00f-0bd9f162f9db</span><br></pre></td></tr></table></figure><p>执行结束后executor pod被自动清除。计算得到pi的值为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pi is roughly 3.1336756683783418</span><br></pre></td></tr></table></figure><p>如果作业通过cluster提交，driver容器会被保留，可以查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> minikube service list</span><br><span class="line">|-------------|------------------------------------------------------|-----------------------------|</span><br><span class="line">|  NAMESPACE  |                         NAME                         |             URL             |</span><br><span class="line">|-------------|------------------------------------------------------|-----------------------------|</span><br><span class="line">| default     | kubernetes                                           | No node port                |</span><br><span class="line">| default     | spark-pi-27fcc168740e372292b27185d124ad7b-driver-svc | No node port                |</span><br><span class="line">| kube-system | kube-dns                                             | No node port                |</span><br><span class="line">| kube-system | kubernetes-dashboard                                 | http://192.168.99.100:30000 |</span><br><span class="line">|-------------|------------------------------------------------------|-----------------------------|</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>1、Running Spark on Kubernetes ：<a href="https://spark.apache.org/docs/latest/running-on-kubernetes.html" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/running-on-kubernetes.html</a></p><p>2、在Minikube Kubernetes集群上运行Spark工作：<a href="https://iamninad.com/running-spark-job-on-kubernetes-minikube/" target="_blank" rel="noopener">https://iamninad.com/running-spark-job-on-kubernetes-minikube/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;​     Spark2.3版本开始支持使用spark-submit直接提交任务给Kubernetes集群。执行机
      
    
    </summary>
    
      <category term="Minikube spark Kubernetes" scheme="https://zjrongxiang.github.io/categories/Minikube-spark-Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Cloudera Quickstart Docker镜像快速部署hadoop集群</title>
    <link href="https://zjrongxiang.github.io/2018/06/25/2019-04-30-%E4%BD%BF%E7%94%A8Cloudera%20Quickstart%20Docker%E9%95%9C%E5%83%8F%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2hadoop%E9%9B%86%E7%BE%A4/"/>
    <id>https://zjrongxiang.github.io/2018/06/25/2019-04-30-使用Cloudera Quickstart Docker镜像快速部署hadoop集群/</id>
    <published>2018-06-25T11:30:00.000Z</published>
    <updated>2019-04-30T14:01:05.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h3 id="参考文献及材料"><a href="#参考文献及材料" class="headerlink" title="参考文献及材料"></a>参考文献及材料</h3><p>1、Minitube项目地址：<a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">https://github.com/kubernetes/minikube</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;h3 id=&quot;参考文献及材料&quot;&gt;&lt;a href=&quot;#参考文献及材料&quot; class=&quot;headerlink&quot; title=&quot;参考文献及材料&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Docker hadoop" scheme="https://zjrongxiang.github.io/categories/Docker-hadoop/"/>
    
    
  </entry>
  
  <entry>
    <title>在Minikube上运行Flink集群</title>
    <link href="https://zjrongxiang.github.io/2018/06/25/2019-04-23-%E5%9C%A8Minikube%E4%B8%8A%E8%BF%90%E8%A1%8CFlink%E9%9B%86%E7%BE%A4%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://zjrongxiang.github.io/2018/06/25/2019-04-23-在Minikube上运行Flink集群（一）/</id>
    <published>2018-06-25T11:30:00.000Z</published>
    <updated>2019-05-10T14:51:25.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>背景</li><li>第一部分   部署准备</li><li>第二部分  验证</li><li>总结</li><li>参考文献及资料 </li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h3 id="第一部分-部署准备"><a href="#第一部分-部署准备" class="headerlink" title="第一部分 部署准备"></a>第一部分 部署准备</h3><p>首先当然需要部署minikube集群。启动minikube集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> minikube start</span><br><span class="line">Starting local Kubernetes v1.10.0 cluster...</span><br><span class="line">Starting VM...</span><br><span class="line">Getting VM IP address...</span><br><span class="line">Moving files into cluster...</span><br><span class="line">Setting up certs...</span><br><span class="line">Connecting to cluster...</span><br><span class="line">Setting up kubeconfig...</span><br><span class="line">Starting cluster components...</span><br><span class="line">Kubectl is now configured to use the cluster.</span><br><span class="line">Loading cached images from config file.</span><br></pre></td></tr></table></figure><p> 上面的回显表明minikube已经启动成功。执行下面网络配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> minikube ssh 'sudo ip link set docker0 promisc on'</span><br></pre></td></tr></table></figure><h3 id="第二部分-部署Flink集群"><a href="#第二部分-部署Flink集群" class="headerlink" title="第二部分 部署Flink集群"></a>第二部分 部署Flink集群</h3><p>一个基本的Flink集群运行在minikube需要三个组件：</p><ul><li>Deployment/Job：运行 JobManager</li><li>Deployment for a pool of TaskManagers</li><li>Service exposing the JobManager’s REST and UI ports</li></ul><h4 id="1-1-创建命名空间"><a href="#1-1-创建命名空间" class="headerlink" title="1.1 创建命名空间"></a>1.1 创建命名空间</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> kubectl create -f namespace.yaml</span><br><span class="line">namespace/flink created</span><br></pre></td></tr></table></figure><p>其中namespace.yaml文件为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">flink</span></span><br></pre></td></tr></table></figure><p>查询minikube集群的的命名空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> kubectl get namespaces</span><br><span class="line">NAME          STATUS    AGE</span><br><span class="line">flink         Active    1m</span><br><span class="line">kube-public   Active    254d</span><br><span class="line">kube-system   Active    254d</span><br></pre></td></tr></table></figure><h4 id="1-2-集群组件资源定义"><a href="#1-2-集群组件资源定义" class="headerlink" title="1.2 集群组件资源定义"></a>1.2 集群组件资源定义</h4><h5 id="1-2-1-启动flink-jobmanager组件"><a href="#1-2-1-启动flink-jobmanager组件" class="headerlink" title="1.2.1 启动flink-jobmanager组件"></a>1.2.1 启动flink-jobmanager组件</h5><p>Job Manager 服务是Flink集群的主服务，使用jobmanager-deployment.yaml创建。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">flink-jobmanager</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">        component:</span> <span class="string">jobmanager</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">jobmanager</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">flink:latest</span></span><br><span class="line"><span class="attr">        args:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">jobmanager</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6123</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">rpc</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6124</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">blob</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6125</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">query</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">ui</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">JOB_MANAGER_RPC_ADDRESS</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">flink-jobmanager</span></span><br></pre></td></tr></table></figure><h5 id="1-2-2-启动flink-taskmanager组件"><a href="#1-2-2-启动flink-taskmanager组件" class="headerlink" title="1.2.2 启动flink-taskmanager组件"></a>1.2.2 启动flink-taskmanager组件</h5><p>使用taskmanager-deployment.yaml创建。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">flink-taskmanager</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">        component:</span> <span class="string">taskmanager</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">taskmanager</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">flink:latest</span></span><br><span class="line"><span class="attr">        args:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">taskmanager</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6121</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6122</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">rpc</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6125</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">query</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">JOB_MANAGER_RPC_ADDRESS</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">flink-jobmanager</span></span><br></pre></td></tr></table></figure><h5 id="1-2-3-启用flink服务"><a href="#1-2-3-启用flink服务" class="headerlink" title="1.2.3 启用flink服务"></a>1.2.3 启用flink服务</h5><p>使用jobmanager-service.yaml创建服务，并且将端口映射到minikube主机响应端口。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">flink-jobmanager</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">rpc</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6123</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30123</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">blob</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6124</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30124</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">query</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6125</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30125</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ui</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30081</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">    component:</span> <span class="string">jobmanager</span></span><br></pre></td></tr></table></figure><h4 id="1-3-端口映射到虚拟机主机"><a href="#1-3-端口映射到虚拟机主机" class="headerlink" title="1.3 端口映射到虚拟机主机"></a>1.3 端口映射到虚拟机主机</h4><p>minikube虚拟机停止的情况下的端口转发命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> VBoxManage modifyvm "minikube" --natpf1 "30123_6123,tcp,,6123,,30123"</span><br><span class="line"><span class="meta">#</span> VBoxManage modifyvm "minikube" --natpf1 "30124_6123,tcp,,6124,,30124"</span><br><span class="line"><span class="meta">#</span> VBoxManage modifyvm "minikube" --natpf1 "30125_6125,tcp,,6125,,30125"</span><br><span class="line"><span class="meta">#</span> VBoxManage modifyvm "minikube" --natpf1 "30081_8081,tcp,,8081,,30081"</span><br></pre></td></tr></table></figure><blockquote><p>格式说明：vboxmanage modifyvm 宿主机名称 natpf<1-n> “映射别名,tcp,,本机端口,,虚拟机端口” </1-n></p></blockquote><p>minikube虚拟机运行的情况下的端口转发命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> VBoxManage controlvm "minikube" --natpf1 "30123_6123,tcp,,6123,,30123"</span><br><span class="line"><span class="meta">#</span> VBoxManage controlvm "minikube" --natpf1 "30124_6123,tcp,,6124,,30124"</span><br><span class="line"><span class="meta">#</span> VBoxManage controlvm "minikube" --natpf1 "30125_6125,tcp,,6125,,30125"</span><br><span class="line"><span class="meta">#</span> VBoxManage controlvm "minikube" --natpf1 "30081_8081,tcp,,8081,,30081"</span><br></pre></td></tr></table></figure><blockquote><p>格式说明：vboxmanage controlvm 宿主机名称 natpf<1-n> “映射别名,tcp,,本机端口,,宿主机端口” </1-n></p></blockquote><p>另外如果要删除上面转发规则：</p><blockquote><p>vboxmanage controlvm 宿主机名称 natpf<1-n> delete 映射别名</1-n></p><p>vboxmanage modifyvm 宿主机名称 natpf<1-n> delete 映射别名</1-n></p></blockquote><h3 id="第三部分-验证"><a href="#第三部分-验证" class="headerlink" title="第三部分 验证"></a>第三部分 验证</h3><h4 id="3-1-minikube控制台界面"><a href="#3-1-minikube控制台界面" class="headerlink" title="3.1 minikube控制台界面"></a>3.1 minikube控制台界面</h4><p>为了是主机局域网类服务器都能访问minikube控制台，需要将端口映射出去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># VBoxManage modifyvm &quot;minikube&quot; --natpf1 &quot;kubedashboard,tcp,,30000,,30000&quot;</span><br></pre></td></tr></table></figure><p><img src="\images\picture\flink\minikube_dashboard.png" alt=""></p><h4 id="3-2-Flink控制台"><a href="#3-2-Flink控制台" class="headerlink" title="3.2 Flink控制台"></a>3.2 Flink控制台</h4><p><img src="\images\picture\flink\minikube_flink.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>（1）部署前提前拉取镜像到本地镜像库。</p><p>（2）需要将服务端口映射到本地机器端口，供局域网服务访问，为后续访问Flink提供方便。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>1、Kubernetes Setup ：<a href="https://ci.apache.org/projects/flink/flink-docs-stable/ops/deployment/kubernetes.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-stable/ops/deployment/kubernetes.html</a></p><p>2、How to Deploy Flink Cluster &amp; Flink-exporter in Kubernetes Cluster：<a href="https://medium.com/pharos-production/how-to-deploy-flink-cluster-flink-exporter-in-kubernetes-cluster-48e24b440446" target="_blank" rel="noopener">https://medium.com/pharos-production/how-to-deploy-flink-cluster-flink-exporter-in-kubernetes-cluster-48e24b440446</a></p><p>3、<a href="https://github.com/melentye" target="_blank" rel="noopener">melentye</a>/<strong>flink-kubernetes</strong> <a href="https://github.com/melentye/flink-kubernetes" target="_blank" rel="noopener">https://github.com/melentye/flink-kubernetes</a></p><p>4、Set up Ingress on Minikube with the NGINX Ingress Controller <a href="https://kubernetes.io/docs/tasks/access-application-cluster/ingress-minikube/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/access-application-cluster/ingress-minikube/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;第一部分   部署准备&lt;/li&gt;
&lt;li&gt;第二部分  验证&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;li&gt;参
      
    
    </summary>
    
      <category term="Minikube spark Kubernetes" scheme="https://zjrongxiang.github.io/categories/Minikube-spark-Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>在Ubuntu上部署Minikube</title>
    <link href="https://zjrongxiang.github.io/2018/06/25/2018-06-25-%E5%9C%A8Ubuntu%E4%B8%8A%E9%83%A8%E7%BD%B2Minikube/"/>
    <id>https://zjrongxiang.github.io/2018/06/25/2018-06-25-在Ubuntu上部署Minikube/</id>
    <published>2018-06-25T11:30:00.000Z</published>
    <updated>2019-04-23T13:54:53.975Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Kubernetes是Google推出的容器编排工具，这是Google保密十几年的强大武器Borg的开源版本。Kubernetes这个名字源于古希腊，意思是舵手。既然docker被比喻成大海上驮着集装箱的鲸鱼，那么Kubernetes就是舵手，掌握鲸鱼的游弋方向，寓意深刻。</p><p>Kubernetes第一个正式版本于2015年7月发布。从Kubernetes 1.3开始提供了一个叫<code>Minikube</code>的强大测试工具，可以在主流操作系统平台（win、os、linux）上运行单节点的小型集群，这个工具默认安装和配置了一个Linux VM，Docker和Kubernetes的相关组件，并且提供Dashboard。</p><p>本篇主要介绍Ubuntu平台上部署Minikube。Minikube利用本地虚拟机环境部署Kubernetes，其基本架构如下图所示。 Minitube项目地址：<a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">https://github.com/kubernetes/minikube</a> </p><p><img src="D:\blog\source\images\picture\minikube.jpeg" alt=""></p><h3 id="第一部分-准备"><a href="#第一部分-准备" class="headerlink" title="第一部分 准备"></a>第一部分 准备</h3><p>Minikube在OS X和Windows上部署需要安装虚拟机实现（用虚拟机来初始化Kubernetes环境），但是Linux例外可以使用自己的环境。参见：<a href="https://github.com/kubernetes/minikube#quickstart" target="_blank" rel="noopener">https://github.com/kubernetes/minikube#quickstart</a> </p><h4 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h4><p>检查CPU是否支持虚拟化，即BIOS中参数（<code>VT-x</code>/<code>AMD-v</code> ）设置为enable。</p><h4 id="1-2-安装虚拟机"><a href="#1-2-安装虚拟机" class="headerlink" title="1.2 安装虚拟机"></a>1.2 安装虚拟机</h4><p>Minikube在不同操作系统上支持不同的虚拟驱动：</p><ul><li><p>macOS</p><ul><li><a href="https://github.com/kubernetes/minikube/blob/master/docs/drivers.md?spm=a2c4e.11153940.blogcont221687.20.7dd57733jMa8yH#xhyve-driver" target="_blank" rel="noopener">xhyve driver</a>, <a href="https://www.virtualbox.org/wiki/Downloads?spm=a2c4e.11153940.blogcont221687.21.7dd57733jMa8yH" target="_blank" rel="noopener">VirtualBox</a> 或 <a href="https://www.vmware.com/products/fusion?spm=a2c4e.11153940.blogcont221687.22.7dd57733jMa8yH" target="_blank" rel="noopener">VMware Fusion</a></li></ul></li><li><p>Linux</p><ul><li><p><a href="https://www.virtualbox.org/wiki/Downloads?spm=a2c4e.11153940.blogcont221687.23.7dd57733jMa8yH" target="_blank" rel="noopener">VirtualBox</a> 或 <a href="https://github.com/kubernetes/minikube/blob/master/docs/drivers.md?spm=a2c4e.11153940.blogcont221687.24.7dd57733jMa8yH#kvm-driver" target="_blank" rel="noopener">KVM</a></p></li><li><blockquote><p><strong>注意:</strong> Minikube 也支持 <code>--vm-driver=none</code> 选项来在本机运行 Kubernetes 组件，这时候需要本机安装了 Docker。</p></blockquote></li></ul></li><li><p>Windows</p><ul><li><a href="https://www.virtualbox.org/wiki/Downloads?spm=a2c4e.11153940.blogcont221687.26.7dd57733jMa8yH" target="_blank" rel="noopener">VirtualBox</a> 或 <a href="https://github.com/kubernetes/minikube/blob/master/docs/drivers.md?spm=a2c4e.11153940.blogcont221687.27.7dd57733jMa8yH#hyperV-driver" target="_blank" rel="noopener">Hyper-V</a> </li></ul></li></ul><p>本篇在Ubuntu部署VirtualBox虚拟驱动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> wget https://download.virtualbox.org/virtualbox/5.1.38/virtualbox-5.1_5.1.38-122592~Ubuntu~xenial_i386.deb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>dpkg -i virtualbox-5.1_5.1.38-122592~Ubuntu~xenial_i386.deb</span><br></pre></td></tr></table></figure><h3 id="第二部分-安装minikube"><a href="#第二部分-安装minikube" class="headerlink" title="第二部分 安装minikube"></a>第二部分 安装minikube</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.28.0/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/</span><br><span class="line"><span class="meta">  %</span> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100 40.8M  100 40.8M    0     0  4671k      0  0:00:08  0:00:08 --:--:-- 7574k</span><br></pre></td></tr></table></figure><h3 id="第三部分-安装Kubectl"><a href="#第三部分-安装Kubectl" class="headerlink" title="第三部分 安装Kubectl"></a>第三部分 安装Kubectl</h3><p>kubectl即kubernetes的客户端，通过他可以进行类似docker run等容器管理操作 。</p><p>下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl</span><br><span class="line"><span class="meta">  %</span> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100 52.5M  100 52.5M    0     0  6654k      0  0:00:08  0:00:08 --:--:-- 10.3M</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> chmod +x kubectl</span><br><span class="line"><span class="meta">#</span> mv kubectl /usr/local/bin/</span><br></pre></td></tr></table></figure><h3 id="第四部分-启集群"><a href="#第四部分-启集群" class="headerlink" title="第四部分 启集群"></a>第四部分 启集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# minikube start --registry-mirror=https://registry.docker-cn.com</span><br><span class="line">Starting local Kubernetes v1.10.0 cluster...</span><br><span class="line">Starting VM...</span><br><span class="line">Downloading Minikube ISO</span><br><span class="line"> 153.08 MB / 153.08 MB [============================================] 100.00% 0s</span><br><span class="line">Getting VM IP address...</span><br><span class="line">Moving files into cluster...</span><br><span class="line">Downloading kubeadm v1.10.0</span><br><span class="line">Downloading kubelet v1.10.0</span><br><span class="line">Finished Downloading kubelet v1.10.0</span><br><span class="line">Finished Downloading kubeadm v1.10.0</span><br><span class="line">Setting up certs...</span><br><span class="line">Connecting to cluster...</span><br><span class="line">Setting up kubeconfig...</span><br><span class="line">Starting cluster components...</span><br><span class="line">Kubectl is now configured to use the cluster.</span><br><span class="line">Loading cached images from config file.</span><br></pre></td></tr></table></figure><p>进入minikube虚拟机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# minikube ssh</span><br><span class="line">                         _             _            </span><br><span class="line">            _         _ ( )           ( )           </span><br><span class="line">  ___ ___  (_)  ___  (_)| |/')  _   _ | |_      __  </span><br><span class="line">/' _ ` _ `\| |/' _ `\| || , &lt;  ( ) ( )| '_`\  /'__`\</span><br><span class="line">| ( ) ( ) || || ( ) || || |\`\ | (_) || |_) )(  ___/</span><br><span class="line">(_) (_) (_)(_)(_) (_)(_)(_) (_)`\___/'(_,__/'`\____)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> </span><br><span class="line"><span class="meta">#</span>  通过exit退出集群</span><br><span class="line"><span class="meta">$</span> exit</span><br><span class="line">logout</span><br></pre></td></tr></table></figure><p>虚拟机地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> minikube ip</span><br><span class="line">192.168.99.100</span><br></pre></td></tr></table></figure><p>启停集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> minikube start/stop</span><br></pre></td></tr></table></figure><p>获取集群信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/home/rongxiang# kubectl get node </span><br><span class="line">NAME       STATUS    ROLES     AGE       VERSION</span><br><span class="line">minikube   Ready     master    7h        v1.10.0</span><br></pre></td></tr></table></figure><p>删除集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> minikube delete  </span><br><span class="line"><span class="meta">#</span> rm -rf ~/.minikube  </span><br><span class="line"><span class="meta">#</span> kubeadm reset</span><br></pre></td></tr></table></figure><h3 id="第五部分-心酸踩坑"><a href="#第五部分-心酸踩坑" class="headerlink" title="第五部分 心酸踩坑"></a>第五部分 心酸踩坑</h3><p>如果在启集群时遇到下面类似的错误，不要慌。国内环境99%的原因是GFW的原因，集群在抓取Google站点docker镜像时候被墙咔嚓了，然后time out。</p><p>WTF！我开始不知道呀。网上的部署指引都那么轻松！！然后重复删除集群，重新装，配参数，给docker配代理。尼玛，最后代理都被咔嚓了。终于撞了南墙，去阿里云拉取镜像，几秒钟搞定。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> minikube start</span><br><span class="line">Starting local Kubernetes v1.10.0 cluster...</span><br><span class="line">Starting VM...</span><br><span class="line">Getting VM IP address...</span><br><span class="line">Moving files into cluster...</span><br><span class="line">Setting up certs...</span><br><span class="line">Connecting to cluster...</span><br><span class="line">Setting up kubeconfig...</span><br><span class="line">Starting cluster components...</span><br><span class="line">E0626 12:57:46.868961   26526 start.go:299] Error restarting cluster:  restarting kube-proxy: waiting for kube-proxy to be up for configmap update: timed out waiting for the condition</span><br><span class="line">================================================================================</span><br><span class="line">An error has occurred. Would you like to opt in to sending anonymized crash</span><br><span class="line">information to minikube to help prevent future errors?</span><br><span class="line">To opt out of these messages, run the command:</span><br><span class="line">minikube config set WantReportErrorPrompt false</span><br><span class="line">================================================================================</span><br><span class="line">Please enter your response [Y/n]:</span><br></pre></td></tr></table></figure><h3 id="第六部分-远程访问-minikube-dashboard"><a href="#第六部分-远程访问-minikube-dashboard" class="headerlink" title="第六部分 远程访问 minikube dashboard"></a>第六部分 远程访问 minikube dashboard</h3><p>在虚拟机启动前，设置端口转发。注意这里使用tcp而不是http。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> VBoxManage modifyvm "minikube" --natpf1 "kubedashboard,tcp,,30000,,30000"</span><br></pre></td></tr></table></figure><p>然后启动虚拟机，这时候局域网上的其他服务器就可以通过宿主机的IP:30000访问web UI。</p><p>或者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> kubectl proxy --address='0.0.0.0' --disable-filter=true</span><br></pre></td></tr></table></figure><h3 id="附录-补充VBoxManage管理"><a href="#附录-补充VBoxManage管理" class="headerlink" title="附录  补充VBoxManage管理"></a>附录  补充VBoxManage管理</h3><p>查询虚拟机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> VBoxManage list vms</span><br><span class="line">"&lt;inaccessible&gt;" &#123;4a3cefe1-11d1-45d2-91c5-1e39fccb6a8d&#125;</span><br><span class="line">"minikube" &#123;dfcd1bdf-afc1-49e6-a270-9d8ff14bf167&#125;</span><br></pre></td></tr></table></figure><p>删除虚拟机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> VBoxManage unregistervm --delete 4a3cefe1-11d1-45d2-91c5-1e39fccb6a8d</span><br></pre></td></tr></table></figure><h3 id="参考文献及材料"><a href="#参考文献及材料" class="headerlink" title="参考文献及材料"></a>参考文献及材料</h3><p>1、Minitube项目地址：<a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">https://github.com/kubernetes/minikube</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;Kubernetes是Google推出的容器编排工具，这是Google保密十几年的强大武器Borg的开源版本。Ku
      
    
    </summary>
    
      <category term="Minikube Ubuntu" scheme="https://zjrongxiang.github.io/categories/Minikube-Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>5分钟介绍深度学习（科普）</title>
    <link href="https://zjrongxiang.github.io/2018/04/16/2018-04-15-network_intro/"/>
    <id>https://zjrongxiang.github.io/2018/04/16/2018-04-15-network_intro/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2019-01-13T09:47:48.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h3><p>最近几年Deep Learning、AI人工智能、机器学习等名词称为新闻热点，特别是Google Deep mind的Alpha Go战胜韩国棋手李世石，让深度学习妇孺皆知。</p><p>首先从概念范畴上讲，deep learning属于机器学习的一个分支，追根溯源其实是人工神经网络。顾名思义，人工神经网络是借鉴人类神经网路的结构原型，算生物仿生学（虽然人类到现在也没弄明白大脑原理）。</p><p><img src="http://images.gitbook.cn/30cf7530-b6ce-11e7-8181-ddae1c526ae3" style="zoom:100%"></p><p>例如下面就是一个3层结构的人工神经网络（1个输入层、1个隐藏层、1个输出层）。</p><p><img src="http://images0.cnblogs.com/blog2015/680781/201508/021735264703915.png" style="zoom:70%"></p><p>1989年Yann LeCun使用反向传播算法（Back Propagation）应用于多层神经网络训练。但一旦层数较大，网络的参数和训练计算量成倍增加，通常需要几周时间才能完成参数训练，另外反向传播算法容易梯度爆炸。研究人员获得好的结果，时间成本太大。</p><p>所以当时机器学习研究方向中，支持向量机（SVM）算法比多层神经网络更为热门，神经网络研究则相当冷门。</p><p>直到2012 年的ImageNet 图像分类竞赛中，Alex Krizhevsky使用CNN（卷积）多层网络（共8层、6千万个参数）赢得当年的比赛，领先第二名10.8个百分点。并且模型使用GPU芯片训练、引入正则技术（Dropout）。</p><p>从此多层神经网络成为机器学习中的研究热点。而为了“洗白”以前暗淡历史，被赋予了新的名称：Deep Learning。</p><h3 id="深度学习背后的数学"><a href="#深度学习背后的数学" class="headerlink" title="深度学习背后的数学"></a>深度学习背后的数学</h3><p>目前的人工智能均属于弱人工智能（不具备心智和意识）。事实上，深度学习目前主要在图像识别和声音识别场景中获得较好的效果。深度学习的成为热点，依赖于两方面条件的成熟:</p><ul><li>算力的提升，训练中大量使用GPU。</li><li>大量数据的获得和沉淀。</li></ul><p>弱人工智能背后的理论基础依赖于数学和统计理论，其实更应该算数据科学的范畴。</p><p>比如输入数据具有$m$维特征，而输出特征为$k$维（例如如果是个二分类问题，$k=2$）。我们使用3层神经网络（输入层为$m$维，即含有$m$个神经元；隐藏层为$n$维，输出层为$k$维）用来训练。</p><p>通常我们将输入数据看成$R^m$（$m$维欧几里得空间），输出数据看成$R^k$（$k$维欧式空间）,如下图：</p><p><img src="\images\picture\bpnnfigure.png" alt=""></p><p>从数学上看，神经网络的结构定义了一个函数空间：${R^{n}} \xrightarrow{\text{f}} {R^{h}}  \xrightarrow{\text{g}} {R^{m}}$ 。这个函数空间中元素是非线性的（隐藏层和输出层有非线性的激活函数）。空间中每个函数由网络中的参数（w，b）唯一决定。</p><p>神经网络训练的过程可以形象的理解为寻找最佳函数的过程：输入层“吃进”大量训练数据，通过非线性函数的作用，观察输出层输出结果和实际值的差异。这是一个监督学习的过程。</p><ul><li>如果差异（误差）在容忍范围内，停止训练，认为该函数是目标函数。</li><li>如果差异较大，反向传播算法根据梯度下降的反向更新网络中的参数（w，b），即挑选新的函数。</li><li>重新喂进数据，计算新挑选函数的误差。如此循环，直到找到目标函数（也可设置提前结束训练）。</li></ul><blockquote><p>为什么神经网络的发展最后偏向的是“深度”呢？即增加层数来提高网络的认知能力。为什么没有“宽度学习”？即增加网络隐藏层的维度（宽度）。</p><p>其实从数学上可以证明深度网络和“宽度网络”的等价性。证明提示：考虑网络定义的函数空间出发。</p></blockquote><h3 id="写在最后（畅想未来）"><a href="#写在最后（畅想未来）" class="headerlink" title="写在最后（畅想未来）"></a>写在最后（畅想未来）</h3><h4 id="深度学习的局限性思考"><a href="#深度学习的局限性思考" class="headerlink" title="深度学习的局限性思考"></a>深度学习的局限性思考</h4><p>目前深度学习被各行各业应用于各种场景，而且有些特定场景取得了良好结果。但是传统的深度学习仍属于监督学习，更像一个被动的执行者，按照人类既定的规则，吃进海量数据，然后训练。</p><p>那么深度网络是否真的理解和学到了模式？还是只学会对有限数据的模式识别？甚至就是一个庞大的记忆网络？这都是值得我们深度思考的。</p><h4 id="GAN对抗网络"><a href="#GAN对抗网络" class="headerlink" title="GAN对抗网络"></a>GAN对抗网络</h4><p>那么怎么能说明模型真的学习并理解了。我们提出了一个原则：如果你理解了一个事物，那么你就可以创造它。这样就发明了GAN对抗网络。让网络自己去创造事物，然后用现实数据去监督，当网络的创造能力和现实接近时，我们认为网络学会了。</p><blockquote><p>其实思想类似传统的遗传算法。</p></blockquote><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><p>另外传统的深度学习，输入的环境（数据）是固定的。然而现实中我们学习过程其实是：环境（数据）与学习个体互相作用的交互过程。这个学习过程人类由于时间有限，是个漫长的过程。但是计算机有个天然优势，可以同时启用成千上万的学习个体完成与环境数据的交互学习过程。例如Alpha Go启用上万个体，两两互搏，配上强大算力，短时间完成学习，这是人类不可企及的。</p><h4 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h4><p>人类学习中还有个方法叫：触类旁通。其实就是不同场景训练模型的借鉴。例如A场景得到训练好的模型（网络参数），对于新的场景B，可以尝试直接用A场景的网络（或部分使用，拼接），以此来减少训练成本。</p><p>那么新的问题来了：是否具有统一的迁移标准，即什么模型是适合迁移的？如果这些问题没有理论基础支持，迁移学习也摆脱不了“炼丹术”的非议。</p><p><strong>深度学习从过去的暗淡无色到现在的光耀夺目。</strong></p><p><strong>然而任何方法都是有边际效应的。</strong></p><p><strong>人工智能的终点还很遥远，谁是下一颗耀眼的明星，需要学界和工业界共同探索。</strong></p><p>​                                                                                                                          </p><p>​                                                                                                                                  2018年4月15日 夜</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;历史背景&quot;&gt;&lt;a href=&quot;#历史背景&quot; class=&quot;headerlink&quot; title=&quot;历史背景&quot;&gt;&lt;/a&gt;历史背景&lt;/h3&gt;&lt;p&gt;最近几年Deep Learning、AI人工智能、机器学习等名词称为新闻热点，特别是Google Deep mind的Alp
      
    
    </summary>
    
      <category term="network" scheme="https://zjrongxiang.github.io/categories/network/"/>
    
    
      <category term="BP， network" scheme="https://zjrongxiang.github.io/tags/BP%EF%BC%8C-network/"/>
    
  </entry>
  
  <entry>
    <title>计算机语言中编译和解释的总结</title>
    <link href="https://zjrongxiang.github.io/2018/04/14/2018-04-14-interprete_and_compile/"/>
    <id>https://zjrongxiang.github.io/2018/04/14/2018-04-14-interprete_and_compile/</id>
    <published>2018-04-14T08:30:00.000Z</published>
    <updated>2018-04-15T03:25:43.418Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>非计算机科班，主要是总结给自己看的，如果有表达错误，请大家指正。</p></blockquote><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><h4 id="高级语言与低级语言"><a href="#高级语言与低级语言" class="headerlink" title="高级语言与低级语言"></a>高级语言与低级语言</h4><p>高级语言（High Level Programming Language）和低级语言（Low Level Programming Language）是一对相对的共生概念（没有一个严格的量化区分标准）。</p><ul><li>低级语言更接近计算机底层资源（直接与硬件资源进行交互）。例如汇编语言。</li><li>高级语言进行了封装和抽象，语言设计更容易被人类思维逻辑所理解（和低级语言比较，学习曲线较缓）。例如C、C++、java、python等。</li></ul><p>随着计算机语言的蓬勃发展（计算机语言的文艺复兴），过去一些高级语言，也有人重新定位成低级语言，例如C语言。</p><h4 id="字节码与机器码"><a href="#字节码与机器码" class="headerlink" title="字节码与机器码"></a>字节码与机器码</h4><p>字节码（Byte Code）不是一种计算机语言。属于高级语言预编译生成的中间码。高级语言源码在预编译的过程中，就完成这部分工作，生成字节码。</p><p>机器码（Machine Code）是一组可以直接被CPU执行的指令集。所有语言（低级和高级）最后都需要编译或解释成机器码（CPU指令集），才能执行。</p><h3 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h3><h4 id="编译器（Interpreter）"><a href="#编译器（Interpreter）" class="headerlink" title="编译器（Interpreter）"></a>编译器（Interpreter）</h4><blockquote><p>A compiler is a computer program (or a set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language), with the latter often having a binary form known as object code. The most common reason for converting source code is to create an executable program.</p></blockquote><ul><li>编译器是一种计算机程序。</li><li>编译器是一个计算机语言的翻译工具，直接将源代码文件预编译（形象的说：翻译）成更低级的代码语言（字节码码、机器码）。</li><li>编译器不会去执行编译的结果，只生成编译的结果文件。</li></ul><h4 id="解释器（Compiler）"><a href="#解释器（Compiler）" class="headerlink" title="解释器（Compiler）"></a>解释器（Compiler）</h4><blockquote><p>In computer science, an interpreter is a computer program that directly executes, i.e. performs, instructions written in a programming or scripting language, without previously compiling them into a machine language program. An interpreter generally uses one of the following strategies for program execution:</p><p>1、parse the source code and perform its behavior directly.</p><p>2、translate source code into some efficient intermediate representation and immediately execute this.</p><p>3、explicitly execute stored precompiled code made by a compiler which is part of the interpreter system.</p></blockquote><ul><li>解释器是一种计算机程序。</li><li>解释器读取源代码或者中间码文件，转换成机器码并与计算机硬件交互。即逐行执行源码。</li><li>解释器会将源代码转换成一种中间代码不会输出更低级的编译结果文件。输出执行结果。</li></ul><p><img src="\images\picture\compiler.jpg" alt="网上有一张很形象的图"></p><h3 id="解释型语言和编译型语言"><a href="#解释型语言和编译型语言" class="headerlink" title="解释型语言和编译型语言"></a>解释型语言和编译型语言</h3><p>两者的区别主要是源码编译时间的差异。相同点都要翻译成机器码后由计算机执行。</p><h4 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h4><ul><li>编译语言的源码文件需要提前通过编译器编译成机器码文件（比如win中的exe可执行文件）。</li><li>执行时，只需执行编译结果文件。不需要重复翻译。</li><li>这类语言有：C、C++、Fortran、Pascal等。</li></ul><h4 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h4><ul><li>解释型语言在运行时进行翻译。比如VB语言，在执行的时候，解释器将语言翻译成机器码，然后执行。</li><li>这类语言有：Ruby、Perl、JavaScript、PHP等。</li></ul><h4 id="混合型语言"><a href="#混合型语言" class="headerlink" title="混合型语言"></a>混合型语言</h4><p>但是随着计算机语言的发展，有些语言兼具两者的特点。</p><ul><li><strong>JAVA语言</strong></li></ul><p>JAVA编译过程只是将<code>.java</code>文件翻译成字节码（Byte Code）（<code>.class</code>文件）。字节码文件交由java虚拟机（JVM）解释运行。也就是说Java源码文件既要编译也要JVM虚拟机进行解释后运行。所以有种说法认为Java是半解释型语言（semi-interpreted” language）。</p><ul><li><strong>Python语言</strong></li></ul><p>python其实类似Java。例如一个python文件<code>test.py</code> ，解释器首先尝试读取该文件历史编译结果（pyc文件）即<code>test.pyc</code>文件或者<code>test.pyo</code> 。如果没有历史文件或者编译文件的日期较旧（即py文件可能有更新），解释器会重新编译生成字节码文件（pyc文件），然后Python虚拟机对字节码解释执行。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>【1】 <a href="http://huang-jerryc.com/2016/11/20/do-you-konw-the-different-between-compiler-and-interpreter/" target="_blank" rel="noopener">你知道「编译」与「解释」的区别吗？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;非计算机科班，主要是总结给自己看的，如果有表达错误，请大家指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;几个概念&quot;&gt;&lt;a href=&quot;#几个概念&quot; class=&quot;headerlink&quot; title=&quot;几个概念&quot;&gt;&lt;/a&gt;几个概念&lt;/h
      
    
    </summary>
    
      <category term="python" scheme="https://zjrongxiang.github.io/categories/python/"/>
    
    
      <category term="interpreter， compiler" scheme="https://zjrongxiang.github.io/tags/interpreter%EF%BC%8C-compiler/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Python语言中import机制</title>
    <link href="https://zjrongxiang.github.io/2018/04/14/2018-04-14-python_import/"/>
    <id>https://zjrongxiang.github.io/2018/04/14/2018-04-14-python_import/</id>
    <published>2018-04-14T02:30:00.000Z</published>
    <updated>2018-04-15T07:58:12.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="包和模块"><a href="#包和模块" class="headerlink" title="包和模块"></a>包和模块</h3><p>首先要介绍Python中两个概念：包和模块。简单的理解（从文件系统角度），包（package）是一个文件夹，而模块（module）是一个python源码文件（扩展名为<code>.py</code>）。</p><ul><li><p><strong>包（package）</strong>：文件夹（文件夹中含有文件<code>__init__.py</code>），包里面含有很多模块组成。</p><blockquote><p><code>__init__.py</code>文件，在里面自定义初始化操作，或为空。</p></blockquote></li><li><p><strong>模块（module）</strong>：即python文件，文件中定义了函数、变量、常量、类等。</p></li></ul><h3 id="Import-方法"><a href="#Import-方法" class="headerlink" title="Import 方法"></a>Import 方法</h3><h4 id="Import-模块方法"><a href="#Import-模块方法" class="headerlink" title="Import 模块方法"></a>Import 模块方法</h4><p>先看一个例子。我们经常使用的模块<code>math</code> ，背后对应其实是一个python文件：<code>math.py</code> 。该文件在<code>C:\Anaconda3\Lib\site-packages\pymc3</code>目录里面（具体环境会有差异）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">math.sqrt(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#1.4142135623730951</span></span><br></pre></td></tr></table></figure><p>如果只要import <code>math.py</code>中具体的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from math import sqrt，sin</span><br><span class="line">sqrt(2)</span><br><span class="line">sin（1）</span><br></pre></td></tr></table></figure><p>另外可以将模块中所有内容导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from math import *</span><br><span class="line">sqrt(2)</span><br></pre></td></tr></table></figure><h4 id="Import-包方法"><a href="#Import-包方法" class="headerlink" title="Import 包方法"></a>Import 包方法</h4><p>包（package）可以简单理解为文件夹。该文件夹下须存在 <code>__init__.py</code> 文件, 内容可以为空。另外该主文件夹下面可以有子文件夹，如果也有 <code>__init__.py</code> 文件，这是子包。类似依次嵌套。</p><p>例如<code>Tensorflow</code>的包（文件树）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~/anaconda3/lib/python3.6/site-packages/tensorflow# tree -L 1</span><br><span class="line">.</span><br><span class="line">├── aux-bin</span><br><span class="line">├── contrib</span><br><span class="line">├── core</span><br><span class="line">├── examples</span><br><span class="line">├── include</span><br><span class="line">├── __init__.py</span><br><span class="line">├── libtensorflow_framework.so</span><br><span class="line">├── __pycache__</span><br><span class="line">├── python</span><br><span class="line">└── tools</span><br></pre></td></tr></table></figure><blockquote><p> <code>__init__.py</code> 文件在import包时，优先导入，作为import包的初始化。</p></blockquote><p>我们以<code>Tensorflow</code>为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入包</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment">#导入子包：contrib</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.contrib <span class="keyword">as</span> contrib</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> contrib</span><br><span class="line"><span class="comment">#导入具体的模块：mnist</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">import</span> tensorflow.examples.tutorials.mnist</span><br></pre></td></tr></table></figure><h3 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h3><p>Namespace是字典数据，供编译器、解释器对源代码中函数名、变量名、模块名等信息进行关联检索。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Python语言使用namespace（命名空间）来存储变量，namespace是一个mapping（映射）。namespace可以理解是一个字典（dict）数据类型，其中键名（key）为变量名，而键值（value）为变量的值。</p><blockquote><p>A <em>namespace</em> is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries。</p></blockquote><ul><li><strong>每一个函数拥有自己的namespace。</strong>称为local namespace（局部命名空间），记录函数的变量。</li><li><strong>每一个模块（module）拥有自己的namespace</strong>。称为global namespace（全局命名空间），记录模块的变量，包括包括模块中的函数、类，其他import（导入）的模块，还有模块级别的变量和常量。</li><li><strong>每一个包（package）拥有自己的namespace。</strong> 也是global namespace ，记录包中所有子包、模块的变量信息。</li><li><strong>Python的built-in names（内置函数、内置常量、内置类型）。</strong> 即内置命名空间。在Python解释器启动时创建，任何模块都可以访问。当退出解释器后删除。</li></ul><h4 id="命名空间的检索顺序"><a href="#命名空间的检索顺序" class="headerlink" title="命名空间的检索顺序"></a>命名空间的检索顺序</h4><p>当代码中需要访问或获取变量时（还有模块名、函数名），Python解释器会对命名空间进行顺序检索，直到根据键名（变量名）找到键值（变量值）。查找的顺序为（LEGB）：</p><ol><li>local namespace，即当前函数或者当前类。如找到，停止检索。</li><li>enclosing function namespace，嵌套函数中外部函数的namespace。</li><li>global namespace，即当前模块。如找到，停止检索。</li><li>build-in namespace，即内置命名空间。如果前面两次检索均为找到，解释器才会最后检索内置命名空间。如果仍然未找到就会报NameRrror（类似：<code>NameError: name &#39;a&#39; is not defined</code>）。</li></ol><h4 id="举栗子"><a href="#举栗子" class="headerlink" title="举栗子"></a>举栗子</h4><p>讲完了理论介绍，我们来举栗子，直观感受一下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>进入python环境</span><br><span class="line">Python 3.5.3 |Anaconda custom (64-bit)| (default, May 11 2017, 13:52:01) [MSC v.</span><br><span class="line">1900 64 bit (AMD64)] on win32</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; print(globals())</span><br><span class="line">&#123;'__name__': '__main__', '__doc__': None, '__spec__': None, '__package__': None,</span><br><span class="line"> '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__builtins__': &lt;mod</span><br><span class="line">ule 'builtins' (built-in)&gt;&#125;</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; x=1</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; print(globals())</span><br><span class="line">&#123;'__name__': '__main__', '__doc__': None, '__spec__': None, '__package__': None,</span><br><span class="line"> '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__builtins__': &lt;mod</span><br><span class="line">ule 'builtins' (built-in)&gt;, 'x': 1&#125;</span><br></pre></td></tr></table></figure><p>上面的例子我们查看了global namespace的字典（dict），其中<code>&#39;__builtins__&#39;</code>就是内置命名空间。新建变量<code>x=1</code>后，全局命名空间会新增这个K-V对。</p><p>还可以通过下面的方法查看import模块、包的namespace。</p><p><strong>当我们import一个module（模块）或者package（包）时，伴随着新建一个global namespace（全局命名空间）。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">math.__dict__</span><br><span class="line">&#123;'__name__': 'math', 'tanh': &lt;built-in function tanh&gt;, 'nan': nan, 'atanh': &lt;bui</span><br><span class="line">lt-in function atanh&gt;,'acosh': &lt;built-in function acosh&gt;, </span><br><span class="line"><span class="meta">#</span>中间略</span><br><span class="line">'trunc': &lt;built-in function trunc&gt;, 'acos': &lt;built-in function acos&gt;, 'sqrt': &lt;built-in</span><br><span class="line"> function sqrt&gt;, 'floor': &lt;built-in function floor&gt;, 'gamma': &lt;built-in function</span><br><span class="line"><span class="meta"> gamma&gt;</span>, 'cosh': &lt;built-in function cosh&gt;&#125;</span><br><span class="line">import tensorflow</span><br><span class="line">tensorflow.__dict__</span><br><span class="line"><span class="meta">#</span>包的所有模块、函数等命名空间信息。大家可以试一下。</span><br></pre></td></tr></table></figure><p>大家可以动手试试其他的场景，比如函数内部查看locals() 。函数内部的变量global声明后，查看globals()字典会有怎样变化。这里就不再一一验证举栗了。</p><p>对于包，我们以tensorflow为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow</span><br><span class="line">tensorflow.__dict__</span><br><span class="line"><span class="comment">##中间略，只摘取部分信息。命名空间中包含module和function的信息。</span></span><br><span class="line"><span class="string">'angle'</span>: &lt;function tensorflow.python.ops.math_ops.angle&gt;,</span><br><span class="line"> <span class="string">'app'</span>: &lt;module <span class="string">'tensorflow.python.platform.app'</span> <span class="keyword">from</span> <span class="string">'/root/anaconda3/lib/python3.6/site-packages/tensorflow/python/platform/app.py'</span>&gt;,</span><br><span class="line"> <span class="string">'arg_max'</span>: &lt;function tensorflow.python.ops.gen_math_ops.arg_max&gt;,</span><br></pre></td></tr></table></figure><h3 id="Import的过程"><a href="#Import的过程" class="headerlink" title="Import的过程"></a>Import的过程</h3><p>当我们执行import 模块、包时，主要有三个过程：检索、加载、名字绑定。</p><h4 id="第一步：检索（Finder）"><a href="#第一步：检索（Finder）" class="headerlink" title="第一步：检索（Finder）"></a>第一步：检索（Finder）</h4><p>Python解释器会对模块所属位置进行搜索：</p><h5 id="（1）检索：内置模块（已经加载到缓存中的模块）"><a href="#（1）检索：内置模块（已经加载到缓存中的模块）" class="headerlink" title="（1）检索：内置模块（已经加载到缓存中的模块）"></a>（1）检索：内置模块（已经加载到缓存中的模块）</h5><p>内置模块（已经加载到缓存中的模块），即在 <code>sys.modules</code> 中检索。Python已经加载到内存中的模块均会在这个字典中进行登记。如果已经登记，不再重复加载。直接将模块的名字加入正在import的模块的namespace。可以通过下面方法查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt; import sys</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; print(sys.modules)</span><br><span class="line">&#123;'_signal': &lt;module '_signal' (built-in)&gt;, 'os.path': &lt;module 'ntpath' from 'C:</span><br><span class="line">\Anaconda3\\lib\\ntpath.py'&gt;,pickle': &lt;module 'pickle' from 'C:\\Anaconda3\\lib\\pickle.py'&gt;, </span><br><span class="line"><span class="meta">#</span>中间略</span><br><span class="line">'subprocess':module 'subprocess' from 'C:\\Anaconda3\\lib\\subprocess.py'&gt;, 'sys': &lt;module '</span><br><span class="line">ys' (built-in)&gt;, 'ctypes.util': &lt;module 'ctypes.util' from 'C:\\Anaconda3\\lib\</span><br><span class="line">ctypes\\util.py'&gt;, '_weakref': &lt;module '_weakref' (built-in)&gt;, '_imp': &lt;module</span><br><span class="line">_imp' (built-in)&gt;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果不是built-in，value中会有模块的绝对路径信息。</p><p>通过key查找模块位置，如果value为None，就会抛出错误信息：ModuleNotFoundError。</p><p>如果key不存在，就会进入下一步检索。</p></blockquote><p>如果我们导入过包，例如tensorflow。</p><p>注意如果要使用其中模块，需要该模块的全名（即全路径信息），例如：<code>tensorflow.examples.tutorials.mnist.input_data</code> 。因为sys.modules中只有全路径的key。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow</span><br><span class="line">print(sys.modules)</span><br><span class="line"><span class="comment">##这个字典中会有tensorflow所有子包、模块的信息和具体的路径。</span></span><br><span class="line"><span class="comment">#'tensorflow.examples.tutorials.mnist.input_data': &lt;module 'tensorflow.examples.tutorials.mnist.input_data' from '/root/anaconda3/lib/python3.6/site-packages/tensorflow/examples/tutorials/mnist/input_data.py'&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（2）检索-sys-meta-path"><a href="#（2）检索-sys-meta-path" class="headerlink" title="（2）检索 sys.meta_path"></a>（2）检索 <a href="http://docs.python.org/2/library/sys.html#sys.meta_path" target="_blank" rel="noopener">sys.meta_path</a></h5><p>逐个遍历其中的 <a href="http://docs.python.org/2/glossary.html#term-finder" target="_blank" rel="noopener">finder</a> 来查找模块。否则进入下一步检索。</p><h5 id="（3）检索模块所属包目录"><a href="#（3）检索模块所属包目录" class="headerlink" title="（3）检索模块所属包目录"></a>（3）检索模块所属包目录</h5><p>如果模块Module在包（Package）中（如<code>import Package.Module</code>），则以<code>Package.__path__</code>为搜索路径进行查找。</p><p><strong>（4）检索环境变量</strong></p><p>如果模块不在一个包中（如<code>import Module</code>），则以 <a href="http://docs.python.org/2/library/sys.html#sys.path" target="_blank" rel="noopener">sys.path</a> 为搜索路径进行查找。</p><blockquote><p>如果上面检索均为找到，抛出错误信息：ModuleNotFoundError。</p></blockquote><h4 id="第二步：加载（Loader）"><a href="#第二步：加载（Loader）" class="headerlink" title="第二步：加载（Loader）"></a>第二步：加载（Loader）</h4><p>加载完成对模块的初始化处理：</p><ul><li>设置属性。包括<code>__name__</code>、<code>__file__</code>、<code>__package__</code>和<code>__loader__</code> 。</li></ul><ul><li>编译源码。编译生成字节码文件（<code>.pyc</code>文件），如果是包，则是其对应的<code>__init__.py</code>文件编译为字节码（*.pyc）。如果字节码文件已存在且仍然是最新的（时间戳和py文件一致），则不会重新编译。</li></ul><ul><li>加载到内存。模块在第一次被加载时被编译，载入内存，并将信息加入到sys.modules中。</li></ul><blockquote><p>也可以强制用<code>reload()</code>函数重新加载模块（包）。</p></blockquote><h4 id="第三步：名字绑定"><a href="#第三步：名字绑定" class="headerlink" title="第三步：名字绑定"></a>第三步：名字绑定</h4><p>将模块和包的命名空间信息导入到当前执行Python文件的namespace（命名空间）。</p><h3 id="将模块、包的路径加入检索路径"><a href="#将模块、包的路径加入检索路径" class="headerlink" title="将模块、包的路径加入检索路径"></a>将模块、包的路径加入检索路径</h3><p>讲完了枯燥的理论背景，下面我们来介绍实际应用。当你写好一个模块文件，如何正确完成import模块？主要有下面两类方法：</p><h4 id="动态方法（sys-path中添加）"><a href="#动态方法（sys-path中添加）" class="headerlink" title="动态方法（sys.path中添加）"></a>动态方法（sys.path中添加）</h4><p>我们知道检索路径中sys.path，所以可以在import模块之前将模块的绝对路径添加到sys.path中。同样导入包需要加入包的文件夹绝对路径。具体方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">##sys.path.append(dir)</span></span><br><span class="line">sys.path.append(<span class="string">'your\module（package）\file\path'</span>)</span><br><span class="line"><span class="comment">##sys.path.insert(pos,dir)</span></span><br><span class="line">sys.path.insert(<span class="number">0</span>,<span class="string">'your\module（package）\file\path'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>1、这里pos参数是插入sys.path这个list数据的位置，pos=0，即list第一位，优先级高。</p><p>2、python程序向sys.path添加的目录只在此程序的生命周期之内有效。程序结束，失效。所以这是一种动态方法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#win7</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.path)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">[<span class="string">''</span>, <span class="string">'C:\\Python27\\lib\\site-packages\\pip-8.1.1-py2.7.egg'</span>, <span class="string">'C:\\windows\\syst</span></span><br><span class="line"><span class="string">em32\\python27.zip'</span>, <span class="string">'C:\\Python27\\DLLs'</span>, <span class="string">'C:\\Python27\\lib'</span>, <span class="string">'C:\\Python27\\l</span></span><br><span class="line"><span class="string">ib\\plat-win'</span>, <span class="string">'C:\\Python27\\lib\\lib-tk'</span>, <span class="string">'C:\\Python27'</span>, <span class="string">'C:\\Users\\rongxian</span></span><br><span class="line"><span class="string">g\\AppData\\Roaming\\Python\\Python27\\site-packages'</span>, <span class="string">'C:\\Python27\\lib\\site-</span></span><br><span class="line"><span class="string">packages'</span>]</span><br></pre></td></tr></table></figure><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>（1）另外检索路径还有系统环境变量，所以可以将模块（包）路径添加在系统环境变量中。</p><p>（2）粗暴一点直接将模块（包）拷贝到sys.path的其中一个路径下面。但是这种管理比较乱。</p><p>（3）Python在遍历sys.path的目录过程中，会解析 <code>.pth</code> 文件，将文件中所记录的路径加入到 sys.path ，这样 .pth 文件中的路径也可以找到了。例如我们在<code>C:\Python27\lib\site-packages</code> 中新建一个<code>.pth</code>文件。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .pth file for the your module or package</span></span><br><span class="line"><span class="string">'your\module（package）\file\path'</span></span><br></pre></td></tr></table></figure><p>这样在模块（包）上线时，我们只需要将模块（包）的目录或者文件绝对路径放在新建的.path文件中即可。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>【1】<a href="http://www.cnblogs.com/russellluo/p/3328683.html#_3" target="_blank" rel="noopener">http://www.cnblogs.com/russellluo/p/3328683.html#_3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;包和模块&quot;&gt;&lt;a href=&quot;#包和模块&quot; class=&quot;headerlink&quot; title=&quot;包和模块&quot;&gt;&lt;/a&gt;包和模块&lt;/h3&gt;&lt;p&gt;首先要介绍Python中两个概念：包和模块。简单的理解（从文件系统角度），包（package）是一个文件夹，而模块（modu
      
    
    </summary>
    
      <category term="python" scheme="https://zjrongxiang.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://zjrongxiang.github.io/tags/python/"/>
    
      <category term="import" scheme="https://zjrongxiang.github.io/tags/import/"/>
    
  </entry>
  
  <entry>
    <title>数据科学实践中常用开放数据集介绍</title>
    <link href="https://zjrongxiang.github.io/2018/04/05/2018-04-01-datasets_example/"/>
    <id>https://zjrongxiang.github.io/2018/04/05/2018-04-01-datasets_example/</id>
    <published>2018-04-05T11:30:00.000Z</published>
    <updated>2018-04-05T15:07:58.609Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>数据科学研究的对象是数据，学习过程中需要相关数据集辅助大家练习、做实验。从而体会数据科学中算法方法论。中国古语云：巧妇难有无米之炊，说的就是数据对于数据科学学习的重要性。</p><p>这篇文章收集介绍了各种常用的开放数据集，供大家学习参考。会持续更新。</p><h3 id="开放数据集"><a href="#开放数据集" class="headerlink" title="开放数据集"></a>开放数据集</h3><p>这里主要将开放数据分为三类：图像类、自然语言（NLP）类、音频类。</p><h4 id="图像类"><a href="#图像类" class="headerlink" title="图像类"></a>图像类</h4><h5 id="MNIST手写数据集"><a href="#MNIST手写数据集" class="headerlink" title="MNIST手写数据集"></a>MNIST手写数据集</h5><ul><li><p>介绍：</p><p>MNIST（全称：Modified National Institute of Standards and Technology database）数据集是常见的深度学习开放数据集（基本属于深度学习的hello world数据集）。这是一个手写阿拉伯数据集（0-9数字），数据主要采集于美国高中学生。数据集总量为7W个手写数字图像（训练集6w个、测试机1w个）。</p><p><img src="\images\picture\digits.jpeg" alt=""></p></li></ul><table><thead><tr><th style="text-align:center">文件</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td style="text-align:center"><a href="http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz" target="_blank" rel="noopener">train-images-idx3-ubyte.gz</a></td><td style="text-align:center">训练集图片 - 60000张训练图片</td></tr><tr><td style="text-align:center"><a href="http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz" target="_blank" rel="noopener">train-labels-idx1-ubyte.gz</a></td><td style="text-align:center">训练集图片对应的数字标签（0-9）</td></tr><tr><td style="text-align:center"><a href="http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz" target="_blank" rel="noopener">t10k-images-idx3-ubyte.gz</a></td><td style="text-align:center">测试集图片 - 10000 张 图片</td></tr><tr><td style="text-align:center"><a href="http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz" target="_blank" rel="noopener">t10k-labels-idx1-ubyte.gz</a></td><td style="text-align:center">测试集图片对应的数字标签</td></tr></tbody></table><ul><li><p>数据存储大小：二进制文件，50M，压缩形式约10M。每张图像被归一化成28*28的像素矩阵。</p></li><li><p>图像数据格式：像素值为0到255. 0表示背景（白色），255表示前景（黑色）。例如下面手写数字1的数据矩阵表示：</p><p><img src="\images\picture\MNIST-Matrix.png" alt="图像数据矩阵"></p></li><li><p>官方网页连接：<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/</a></p></li><li><p>读取数据案例（Python）：</p><p>Tensorflow中已经有对MNIST数据集解析的脚本，我们可以直接调用：</p></li></ul><table><thead><tr><th style="text-align:center">文件</th><th style="text-align:center">目的</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://github.com/tensorflow/tensorflow/blob/r1.1/tensorflow/examples/tutorials/mnist/input_data.py" target="_blank" rel="noopener">input_data.py</a>、<a href="https://github.com/tensorflow/tensorflow/blob/r1.1/tensorflow/contrib/learn/python/learn/datasets/mnist.py" target="_blank" rel="noopener">mnist.py</a></td><td style="text-align:center">用于读取MNIST数据集</td></tr></tbody></table>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment">#tf为1.7版本</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line">data_dir = <span class="string">'/root/tftest/mnistdata/'</span></span><br><span class="line"><span class="comment">#data_dir为数据集文件存放目录</span></span><br><span class="line">mnist = input_data.read_data_sets(data_dir, one_hot=<span class="keyword">True</span>，validation_size=<span class="number">5000</span>)</span><br><span class="line"><span class="comment">#mnist = input_data.read_data_sets(data_dir, one_hot=False)</span></span><br><span class="line"><span class="comment">#one_hot参数True，表示标签进行one-hot编码处理。</span></span><br><span class="line"><span class="comment">#validation_size参数可以从训练集中划出一部分数据作为验证集。默认是5w个，可以自己调节。</span></span><br><span class="line"></span><br><span class="line">x_train,y_train,x_test,y_test,x_vali,y_vali = \</span><br><span class="line">mnist.train.images,mnist.train.labels,mnist.test.images,mnist.test.labels,\</span><br><span class="line">mnist.validation.images,mnist.validation.labels</span><br><span class="line"><span class="comment">#x_train的数据类型为：&lt;class 'numpy.ndarray'&gt;</span></span><br></pre></td></tr></table></figure><p>​       上面的例子划分好数据就可以喂给各种算法模型进行训练。</p><ul><li><p>扩展：EMNIST数据集：<a href="https://arxiv.org/abs/1702.05373。" target="_blank" rel="noopener">https://arxiv.org/abs/1702.05373。</a></p><p>按照MNIST规范，数据集更大：包含240,000个训练图像和40,000个手写数字测试图像。</p></li></ul><h5 id="MS-COCO图像分割数据集"><a href="#MS-COCO图像分割数据集" class="headerlink" title="MS-COCO图像分割数据集"></a>MS-COCO图像分割数据集</h5><ul><li><p>介绍：</p><p>MS-COCO（全称是Common Objects in Context）是微软团队提供的一个可以用来进行图像识别的数据集。数据集中的图像分为训练、验证和测试集。COCO数据集现在有3种标注类型：<strong>object instances（目标实例）, object keypoints（目标上的关键点）, 和image captions（看图说话）</strong>，使用JSON文件存储。</p><p>一共有33w张图像，80个对象类别，每幅图5个字母、25w个关键点。</p></li><li><p>数据存储大小：约25G（压缩形式）</p></li><li><p>数据格式：中文介绍可以参考知乎这篇文章：<a href="https://zhuanlan.zhihu.com/p/29393415" target="_blank" rel="noopener">COCO数据集的标注格式</a> 。</p></li><li><p>官方网站：<a href="http://mscoco.org/" target="_blank" rel="noopener">http://mscoco.org/</a></p></li></ul><h5 id="ImageNet图像数据集"><a href="#ImageNet图像数据集" class="headerlink" title="ImageNet图像数据集"></a>ImageNet图像数据集</h5><ul><li><p>介绍：</p><p>Imagenet是深度学习中大名鼎鼎的数据集。数据集有1400多万幅图片，涵盖2万多个类别；其中有超过百万的图片有明确的类别标注和图像中物体位置的标注。深度学习中关于图像分类、定位、检测等研究工作大多基于此数据集展开。Imagenet数据集文档详细，有专门的团队维护，使用非常方便，在计算机视觉领域研究论文中应用非常广，几乎成为了目前深度学习图像领域算法性能检验的“标准”数据集。</p></li><li><p>数据存储大小：约150G</p></li><li><p>官方网站：<a href="http://www.image-net.org/" target="_blank" rel="noopener">http://www.image-net.org/</a></p></li></ul><p>Open Image图像数据集</p><ul><li><p>介绍：</p><p>Open Image为Google提供。数据集包含近900万个图像URL。这些图像已经用数千个类的图像级标签边框进行了注释。该数据集包含9,011,219张图像的训练集，41,260张图像的验证集以及125,436张图像的测试集。</p></li><li><p>数据大小：500G</p></li><li><p>官方网站：<a href="https://github.com/openimages/dataset" target="_blank" rel="noopener">https://github.com/openimages/dataset</a></p></li></ul><h5 id="VisualQA图像数据库"><a href="#VisualQA图像数据库" class="headerlink" title="VisualQA图像数据库"></a>VisualQA图像数据库</h5><ul><li><p>介绍：</p><p>VQA是一个包含有关图像的开放式问题的数据集。这些问题需要理解视野和语言。数据集有265,016张图片。</p></li><li><p>数据大小：25G</p></li><li><p>官方网站：<a href="http://www.visualqa.org/" target="_blank" rel="noopener">http://www.visualqa.org/</a></p></li></ul><h5 id="The-Street-View-House-Numbers-SVHN-Dataset街边号码牌数据集"><a href="#The-Street-View-House-Numbers-SVHN-Dataset街边号码牌数据集" class="headerlink" title="The Street View House Numbers (SVHN) Dataset街边号码牌数据集"></a>The Street View House Numbers (SVHN) Dataset街边号码牌数据集</h5><ul><li><p>介绍：</p><p>SVHN图像数据集用于开发机器学习和对象识别算法，对数据预处理和格式化的要求最低。它可以被看作与<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST</a>相似，但是将更多标记数据（超过600,000个数字图像）并入一个数量级并且来自显着更难以解决的真实世界问题（识别自然场景图像中的数字和数字）。SVHN数据从谷歌街景图片中的房屋号码中获得的。书记含有用于训练的73257个数字，用于测试的26032个数字以及用作额外训练数据的531131个附加数字。</p></li><li><p>数据集大小： [train.tar.gz]， [test.tar.gz]， [extra.tar.gz ] 共三个文件。</p></li><li><p>官方网站：<a href="http://ufldl.stanford.edu/housenumbers/" target="_blank" rel="noopener">http://ufldl.stanford.edu/housenumbers/</a></p></li></ul><h5 id="CIFAR-10图像数据集"><a href="#CIFAR-10图像数据集" class="headerlink" title="CIFAR-10图像数据集"></a>CIFAR-10图像数据集</h5><ul><li><p>介绍：</p><p>CIFAR-10数据集由10个类的60,000个图像组成（每个类在上图中表示为一行）。总共有50,000个训练图像和10,000个测试图像。数据集分为6个部分 - 5个培训批次和1个测试批次。每批有10,000个图像。</p></li><li><p>数据大小：170M</p></li><li><p>官方网站：<a href="http://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">http://www.cs.toronto.edu/~kriz/cifar.html</a></p></li></ul><h5 id="Fashion-MNIST"><a href="#Fashion-MNIST" class="headerlink" title="Fashion-MNIST"></a>Fashion-MNIST</h5><ul><li><p>介绍</p><p>Fashion-MNIST包含60,000个训练图像和10,000个测试图像。它是一个类似MNIST的时尚产品数据库。开发人员认为MNIST已被过度使用，因此他们将其作为该数据集的直接替代品。每张图片都以灰度显示，并与10个类别的标签相关联。</p></li><li><p>数据集大小：30M</p></li><li><p>官方网站：<a href="https://github.com/zalandoresearch/fashion-mnist" target="_blank" rel="noopener">https://github.com/zalandoresearch/fashion-mnist</a></p></li></ul><h4 id="自然语言类数据库"><a href="#自然语言类数据库" class="headerlink" title="自然语言类数据库"></a>自然语言类数据库</h4><h5 id="IMDB电影评论数据集"><a href="#IMDB电影评论数据集" class="headerlink" title="IMDB电影评论数据集"></a>IMDB电影评论数据集</h5><ul><li><p>介绍：</p><p>这是电影爱好者的梦幻数据集。它具有比此领域以前的任何数据集更多的数据。除了训练和测试评估示例之外，还有更多未标记的数据供您使用。原始文本和预处理的单词格式包也包括在内。</p></li><li><p>数据集大小：80 M</p></li><li><p>官方网站：<a href="http://ai.stanford.edu/~amaas/data/sentiment/" target="_blank" rel="noopener">http://ai.stanford.edu/~amaas/data/sentiment/</a></p></li><li><p>模型案例：<a href="https://arxiv.org/abs/1705.09207" target="_blank" rel="noopener">https://arxiv.org/abs/1705.09207</a></p></li></ul><h5 id="Twenty-Newsgroups-Data-Set"><a href="#Twenty-Newsgroups-Data-Set" class="headerlink" title="Twenty Newsgroups Data Set"></a>Twenty Newsgroups Data Set</h5><ul><li><p>介绍：</p><p>该数据集包含有关新闻组的信息。为了管理这个数据集，从20个不同的新闻组中获取了1000篇Usenet文章。这些文章具有典型特征，如主题行，签名和引号。</p></li><li><p>数据集大小：20 M</p></li><li><p>官方网站：<a href="https://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups" target="_blank" rel="noopener">https://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups</a></p></li><li><p>模型案例：<a href="https://arxiv.org/abs/1606.01781" target="_blank" rel="noopener">https://arxiv.org/abs/1606.01781</a></p></li></ul><h5 id="Sentiment140情感分析数据集"><a href="#Sentiment140情感分析数据集" class="headerlink" title="Sentiment140情感分析数据集"></a>Sentiment140情感分析数据集</h5><ul><li><p>介绍：</p><p>Sentiment140是一个可用于情感分析的数据集。</p></li><li><p>数据集大小：80 M</p></li><li><p>官方网站：<a href="http://help.sentiment140.com/for-students/" target="_blank" rel="noopener">http://help.sentiment140.com/for-students/</a></p></li><li><p>模型案例：<a href="http://www.aclweb.org/anthology/W17-5202" target="_blank" rel="noopener">http://www.aclweb.org/anthology/W17-5202</a></p></li></ul><h5 id="WordNet"><a href="#WordNet" class="headerlink" title="WordNet"></a>WordNet</h5><ul><li><p>介绍：</p><p>WordNet是英语synsets的大型数据库。Synsets是同义词组，每个描述不同的概念。WordNet的结构使其成为NLP非常有用的工具。</p></li><li><p>数据集大小：10 M</p></li><li><p>官方网站：<a href="https://wordnet.princeton.edu/" target="_blank" rel="noopener">https://wordnet.princeton.edu/</a></p></li><li><p>模型案例：<a href="https://aclanthology.info/pdf/R/R11/R11-1097.pdf" target="_blank" rel="noopener">https://aclanthology.info/pdf/R/R11/R11-1097.pdf</a></p></li></ul><h5 id="Yelp评论"><a href="#Yelp评论" class="headerlink" title="Yelp评论"></a>Yelp评论</h5><ul><li><p>介绍：</p><p>这是Yelp为了学习目的而发布的一个开放数据集。它由数百万用户评论，商业属性和来自多个大都市地区的超过20万张照片组成。这是一个非常常用的全球NLP挑战数据集。</p></li><li><p>数据集大小：2.66 GB JSON，2.9 GB SQL和7.5 GB照片（全部压缩）</p></li><li><p>官方网站：<a href="https://www.yelp.com/dataset" target="_blank" rel="noopener">https://www.yelp.com/dataset</a></p></li><li><p>模型案例：<a href="https://arxiv.org/pdf/1710.00519.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1710.00519.pdf</a></p></li></ul><h5 id="维基百科语料库"><a href="#维基百科语料库" class="headerlink" title="维基百科语料库"></a>维基百科语料库</h5><ul><li><p>介绍：</p><p>该数据集是维基百科全文的集合。它包含来自400多万篇文章的将近19亿字。什么使得这个强大的NLP数据集是你可以通过单词，短语或段落本身的一部分进行搜索。</p></li><li><p>数据集大小： 20 MB</p></li><li><p>官方网站：<a href="https://corpus.byu.edu/wiki/" target="_blank" rel="noopener">https://corpus.byu.edu/wiki/</a></p></li><li><p>模型案例：<a href="https://arxiv.org/pdf/1711.03953.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1711.03953.pdf</a></p></li></ul><h5 id="博客作者身份语料库"><a href="#博客作者身份语料库" class="headerlink" title="博客作者身份语料库"></a>博客作者身份语料库</h5><ul><li><p>介绍：</p><p>此数据集包含从数千名博主收集的博客帖子，从blogger.com收集。每个博客都作为一个单独的文件提供。每个博客至少包含200次常用英语单词。</p></li><li><p>数据集大小： 300 MB</p></li><li><p>官方网站：<a href="http://u.cs.biu.ac.il/~koppel/BlogCorpus.htm" target="_blank" rel="noopener">http://u.cs.biu.ac.il/~koppel/BlogCorpus.htm</a></p></li><li><p>模型案例：<a href="https://arxiv.org/pdf/1609.06686.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1609.06686.pdf</a></p></li></ul><h5 id="欧洲语言的机器翻译"><a href="#欧洲语言的机器翻译" class="headerlink" title="欧洲语言的机器翻译"></a>欧洲语言的机器翻译</h5><ul><li><p>介绍：</p><p>数据集包含四种欧洲语言。</p></li><li><p>数据集大小： 约15 G</p></li><li><p>官方网站：<a href="http://statmt.org/wmt11/translation-task.html" target="_blank" rel="noopener">http://statmt.org/wmt11/translation-task.html</a></p></li><li><p>模型案例：<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">https://arxiv.org/abs/1706.03762</a></p></li></ul><h4 id="音频-语音数据集"><a href="#音频-语音数据集" class="headerlink" title="音频/语音数据集"></a>音频/语音数据集</h4><h5 id="口语数字数据集"><a href="#口语数字数据集" class="headerlink" title="口语数字数据集"></a>口语数字数据集</h5><ul><li><p>介绍：</p><p>为了解决识别音频样本中的口头数字的任务而创建。这是一个开放的数据集，所以希望随着人们继续贡献更多样本，它会不断增长。</p></li><li><p>数据集大小： 约10 G=M</p></li><li><p>记录数量：1500个音频样本</p></li><li><p>官方网站：<a href="https://github.com/Jakobovski/free-spoken-digit-dataset" target="_blank" rel="noopener">https://github.com/Jakobovski/free-spoken-digit-dataset</a></p></li><li><p>模型案例：<a href="https://arxiv.org/pdf/1712.00866" target="_blank" rel="noopener">https://arxiv.org/pdf/1712.00866</a></p></li></ul><h5 id="免费音乐档案（FMA）"><a href="#免费音乐档案（FMA）" class="headerlink" title="免费音乐档案（FMA）"></a>免费音乐档案（FMA）</h5><ul><li><p>介绍：</p><p>FMA是音乐分析的数据集。数据集由全长和HQ音频，预先计算的特征以及音轨和用户级元数据组成。它是一个开放数据集，用于评估MIR中的几个任务。以下是数据集连同其包含的csv文件列表：</p><ul><li><code>tracks.csv</code>：所有106,574首曲目的每首曲目元数据，如ID，标题，艺术家，流派，标签和播放次数。</li><li><code>genres.csv</code>：所有163种风格的ID与他们的名字和父母（用于推断流派层次和顶级流派）。</li><li><code>features.csv</code>：用<a href="https://librosa.github.io/librosa/" target="_blank" rel="noopener">librosa</a>提取的共同特征  。</li><li><code>echonest.csv</code>：由<a href="http://the.echonest.com/" target="_blank" rel="noopener">Echonest</a>  （现在的  <a href="https://www.spotify.com/" target="_blank" rel="noopener">Spotify</a>）为13,129首音轨的子集提供的音频功能  。</li></ul></li><li><p>数据集大小： 约1T</p></li><li><p>记录数量：1500个音频样本</p></li><li><p>官方网站：<a href="https://github.com/mdeff/fma" target="_blank" rel="noopener">https://github.com/mdeff/fma</a></p></li><li><p>模型案例：<a href="https://arxiv.org/pdf/1803.05337.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1803.05337.pdf</a></p></li></ul><h5 id="舞厅"><a href="#舞厅" class="headerlink" title="舞厅"></a>舞厅</h5><ul><li><p>介绍：</p><p>该数据集包含舞厅跳舞音频文件。以真实音频格式提供了许多舞蹈风格的一些特征摘录。 以下是数据集的一些特征：</p></li><li><p>数据集大小： 约14 G</p></li><li><p>记录数量：约700个音频样本</p></li><li><p>官方网站：<a href="http://mtg.upf.edu/ismir2004/contest/tempoContest/node5.html" target="_blank" rel="noopener">http://mtg.upf.edu/ismir2004/contest/tempoContest/node5.html</a></p></li><li><p>模型案例：<a href="https://pdfs.semanticscholar.org/0cc2/952bf70c84e0199fcf8e58a8680a7903521e.pdf" target="_blank" rel="noopener">https://pdfs.semanticscholar.org/0cc2/952bf70c84e0199fcf8e58a8680a7903521e.pdf</a></p></li></ul><h5 id="百万歌曲数据集"><a href="#百万歌曲数据集" class="headerlink" title="百万歌曲数据集"></a>百万歌曲数据集</h5><ul><li><p>介绍：</p><p>百万歌曲数据集是音频功能和元数据的一百万当代流行音乐曲目可自由可用的集合。 其目的是：</p><ul><li>鼓励对扩大到商业规模的算法进行研究</li><li>为评估研究提供参考数据集</li><li>作为使用API创建大型数据集的捷径（例如Echo Nest的）</li><li>帮助新研究人员在MIR领域开始工作</li></ul><p>数据集的核心是一百万首歌曲的特征分析和元数据。该数据集不包含任何音频，只包含派生的功能。示例音频可以通过使用哥伦比亚大学提供的<a href="https://github.com/tb2332/MSongsDB/tree/master/Tasks_Demos/Preview7digital" target="_blank" rel="noopener">代码</a>从<a href="http://www.7digital.com/" target="_blank" rel="noopener">7digital等</a>服务中获取。</p></li><li><p>数据集大小： 约280 G</p></li><li><p>记录数量：它的一百万首歌曲！</p></li><li><p>官方网站：<a href="https://labrosa.ee.columbia.edu/millionsong/" target="_blank" rel="noopener">https://labrosa.ee.columbia.edu/millionsong/</a></p></li><li><p>模型案例：<a href="http://www.ke.tu-darmstadt.de/events/PL-12/papers/08-aiolli.pdf" target="_blank" rel="noopener">http://www.ke.tu-darmstadt.de/events/PL-12/papers/08-aiolli.pdf</a></p></li></ul><h5 id="LibriSpeech"><a href="#LibriSpeech" class="headerlink" title="LibriSpeech"></a>LibriSpeech</h5><ul><li><p>介绍：</p><p>该数据集是大约1000小时的英语语音的大型语料库。这些数据来自LibriVox项目的有声读物。它已被分割并正确对齐。如果您正在寻找一个起点，请查看已准备好的声学模型，这些模型在<a href="http://www.kaldi-asr.org/downloads/build/6/trunk/egs/" target="_blank" rel="noopener">kaldi-asr.org</a>和语言模型上进行了训练，适合评估，<a href="http://www.openslr.org/11/" target="_blank" rel="noopener">网址</a>为<a href="http://www.openslr.org/11/" target="_blank" rel="noopener">http://www.openslr.org/11/</a>。</p></li><li><p>数据集大小： 约60 G</p></li><li><p>记录数量：1000小时的演讲</p></li><li><p>官方网站：<a href="http://www.openslr.org/12/" target="_blank" rel="noopener">http://www.openslr.org/12/</a></p></li><li><p>模型案例：<a href="https://arxiv.org/abs/1712.09444" target="_blank" rel="noopener">https://arxiv.org/abs/1712.09444</a></p></li></ul><h5 id="VoxCeleb"><a href="#VoxCeleb" class="headerlink" title="VoxCeleb"></a>VoxCeleb</h5><ul><li><p>介绍：</p><p>VoxCeleb是一个大型的说话人识别数据集。它包含约1,200名来自YouTube视频的约10万个话语。数据大部分是性别平衡的（男性占55％）。名人跨越不同的口音，职业和年龄。开发和测试集之间没有重叠。对于隔离和识别哪个超级巨星来说，这是一个有趣的用例。</p></li><li><p>数据集大小： 约150 M</p></li><li><p>记录数量： 1,251位名人的100,000条话语</p></li><li><p>官方网站：<a href="http://www.robots.ox.ac.uk/~vgg/data/voxceleb/" target="_blank" rel="noopener">http://www.robots.ox.ac.uk/~vgg/data/voxceleb/</a></p></li><li><p>模型案例：<a href="https://www.robots.ox.ac.uk/~vgg/publications/2017/Nagrani17/nagrani17.pdf" target="_blank" rel="noopener">https://www.robots.ox.ac.uk/~vgg/publications/2017/Nagrani17/nagrani17.pdf</a></p></li></ul><h4 id="比赛数据"><a href="#比赛数据" class="headerlink" title="比赛数据"></a>比赛数据</h4><h5 id="Twitter情绪分析数据"><a href="#Twitter情绪分析数据" class="headerlink" title="Twitter情绪分析数据"></a>Twitter情绪分析数据</h5><ul><li><p>介绍：</p><p>仇恨以种族主义和性别歧视为形式的言论已成为叽叽喳喳的麻烦，重要的是将这类推文与其他人分开。在这个实践问题中，我们提供既有正常又有仇恨推文的Twitter数据。您作为数据科学家的任务是确定推文是仇恨推文，哪些不是。</p></li><li><p>数据集大小： 约3 M</p></li><li><p>记录数量： 31,962条推文</p></li><li><p>官方网站：<a href="https://datahack.analyticsvidhya.com/contest/practice-problem-twitter-sentiment-analysis/" target="_blank" rel="noopener">https://datahack.analyticsvidhya.com/contest/practice-problem-twitter-sentiment-analysis/</a></p></li></ul><h5 id="印度演员的年龄检测"><a href="#印度演员的年龄检测" class="headerlink" title="印度演员的年龄检测"></a>印度演员的年龄检测</h5><ul><li><p>介绍：</p><p>对于任何深度学习爱好者来说，这是一个令人着迷的挑战。该数据集包含数千个印度演员的图像，你的任务是确定他们的年龄。所有图像都是手动选择的，并从视频帧中剪切，导致尺度，姿势，表情，照度，年龄，分辨率，遮挡和化妆的高度可变性。</p></li><li><p>数据集大小： 约48 M</p></li><li><p>记录数量： 训练集中的19,906幅图像和测试集中的6636幅图像</p></li><li><p>官方网站：<a href="https://datahack.analyticsvidhya.com/contest/practice-problem-age-detection/" target="_blank" rel="noopener">https://datahack.analyticsvidhya.com/contest/practice-problem-age-detection/</a></p></li></ul><h5 id="城市声音分类"><a href="#城市声音分类" class="headerlink" title="城市声音分类"></a>城市声音分类</h5><ul><li><p>介绍：</p><p>这个数据集包含超过8000个来自10个班级的城市声音摘录。这个实践问题旨在向您介绍常见分类方案中的音频处理。</p></li><li><p>数据集大小： 训练集 - 3 GB（压缩），测试集 - 2 GB（压缩）</p></li><li><p>记录数量： 来自10个班级的8732个城市声音标注的声音片段（&lt;= 4s）</p></li><li><p>官方网站：<a href="https://datahack.analyticsvidhya.com/contest/practice-problem-urban-sound-classification/" target="_blank" rel="noopener">https://datahack.analyticsvidhya.com/contest/practice-problem-urban-sound-classification/</a></p></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>【1】   <a href="https://www.tensorflow.org/versions/r1.1/get_started/mnist/beginners" target="_blank" rel="noopener">https://www.tensorflow.org/versions/r1.1/get_started/mnist/beginners</a></p><p>【2】  <a href="https://www.analyticsvidhya.com/blog/2018/03/comprehensive-collection-deep-learning-datasets/" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2018/03/comprehensive-collection-deep-learning-datasets/</a></p><p>【3】  <a href="https://deeplearning4j.org/cn/opendata" target="_blank" rel="noopener">https://deeplearning4j.org/cn/opendata</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;数据科学研究的对象是数据，学习过程中需要相关数据集辅助大家练习、做实验。从而体会数据科学中算法方法论。中国古语云：巧妇难有无米之炊，说的就是
      
    
    </summary>
    
      <category term="datasets" scheme="https://zjrongxiang.github.io/categories/datasets/"/>
    
    
      <category term="datasets" scheme="https://zjrongxiang.github.io/tags/datasets/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu挂载新的硬盘（2T以上）</title>
    <link href="https://zjrongxiang.github.io/2018/04/01/2018-04-01-ubuntu_add_disk/"/>
    <id>https://zjrongxiang.github.io/2018/04/01/2018-04-01-ubuntu_add_disk/</id>
    <published>2018-04-01T15:30:00.000Z</published>
    <updated>2018-04-04T14:21:39.551Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统环境："><a href="#系统环境：" class="headerlink" title="系统环境："></a>系统环境：</h3><p>Linux version 4.13.0-37-generic (Ubuntu 5.4.0-6ubuntu1~16.04.9)</p><p>root用户登入操作</p><h3 id="查看硬盘信息"><a href="#查看硬盘信息" class="headerlink" title="查看硬盘信息"></a>查看硬盘信息</h3><p>机器断电时，接入硬盘。开机后用下面的命令查看硬盘状况（<font color="red">非root用户需sudo</font>）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# fdisk -l</span><br><span class="line">Disk /dev/sda: 465.8 GiB, 500107862016 bytes, 976773168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: CC8004FC-D422-48FA-8ACF-54C3F48E860B</span><br><span class="line"></span><br><span class="line">Device         Start       End   Sectors   Size Type</span><br><span class="line">/dev/sda1       2048   1050623   1048576   512M EFI System</span><br><span class="line">/dev/sda2    1050624 909946879 908896256 433.4G Linux filesystem</span><br><span class="line">/dev/sda3  909946880 976771071  66824192  31.9G Linux swap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3.7 TiB, 4000787030016 bytes, 7814037168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br></pre></td></tr></table></figure><p>查看到系统由两块硬盘：/dev/sda和/dev/sdb，如果还有其他硬盘会继续sdc、sdd编号。</p><p>正在使用的系统盘sda已经有三个分区（sda1、sda2、sda3），新挂载的硬盘sdb位分区。</p><h3 id="新挂载硬盘分区"><a href="#新挂载硬盘分区" class="headerlink" title="新挂载硬盘分区"></a>新挂载硬盘分区</h3><p>新硬盘存储空间一共4T，我们对硬盘进行分区。划分为两个分区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.27.1).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">/dev/sdb: device contains a valid 'ext4' signature; it is strongly recommended to wipe the device with wipefs(8) if this is sible collisions</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table.</span><br><span class="line">The size of this disk is 3.7 TiB (4000787030016 bytes). DOS partition table format can not be used on drives for volumes lar512-byte sectors. Use GUID partition table format (GPT).</span><br><span class="line"></span><br><span class="line">Created a new DOS disklabel with disk identifier 0x6b028a17.</span><br><span class="line"></span><br><span class="line">Command (m for help):</span><br></pre></td></tr></table></figure><p>注意这里已经有警告：<em>The size of this disk is 3.7 TiB (4000787030016 bytes). DOS partition table format can not be used on drives for volumes lar512-byte sectors. Use GUID partition table format (GPT)</em></p><p>这里情况特殊，新加入的磁盘为4T。fdisk命令对于大于2T的分区无法划分。如果继续使用fdisk工具，最多只能分出2T的分区，剩下的空间无法利用。这不坑爹嘛。提示我们使用parted命令。</p><h3 id="使用parted分区"><a href="#使用parted分区" class="headerlink" title="使用parted分区"></a>使用parted分区</h3><p>parted命令可以划分单个分区大于2T的GPT格式的分区。</p><p>更改分区表类型：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# parted -s /dev/sdb mklabel gpt</span><br></pre></td></tr></table></figure><p>使用parted进行分区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# parted /dev/sdb</span><br><span class="line">GNU Parted 3.2</span><br><span class="line">Using /dev/sdb</span><br><span class="line">Welcome to GNU Parted! Type 'help' to view a list of commands.</span><br><span class="line">(parted) print                                                            </span><br><span class="line">Model: ATA WDC WD40EFRX-68N (scsi)</span><br><span class="line">Disk /dev/sdb: 4001GB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start  End  Size  File system  Name  Flags</span><br><span class="line"></span><br><span class="line">(parted) mklabel gpt                                                      </span><br><span class="line">Warning: The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost. Do you want to continue?</span><br><span class="line">Yes/No? yes                                                               </span><br><span class="line">(parted) mkpart                                                           </span><br><span class="line">Partition name?  []?                                                      </span><br><span class="line">File system type?  [ext2]? ext4                                           </span><br><span class="line">Start? 0%                                                                 </span><br><span class="line">End? 100%                                                                 </span><br><span class="line">(parted) print                                                            </span><br><span class="line">Model: ATA WDC WD40EFRX-68N (scsi)</span><br><span class="line">Disk /dev/sdb: 4001GB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  4001GB  4001GB  ext4</span><br><span class="line"></span><br><span class="line">(parted) quit                                                             </span><br><span class="line">Information: You may need to update /etc/fstab.</span><br></pre></td></tr></table></figure><p>最后我们验证一下，sdb1分区成功，提示我们要更新系统文件：/etc/fstab。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# ls /dev/sd*                                          </span><br><span class="line">/dev/sda  /dev/sda1  /dev/sda2  /dev/sda3  /dev/sdb  /dev/sdb1</span><br><span class="line">root@deeplearning:~# fdisk -l</span><br><span class="line">Disk /dev/sda: 465.8 GiB, 500107862016 bytes, 976773168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: CC8004FC-D422-48FA-8ACF-54C3F48E860B</span><br><span class="line"></span><br><span class="line">Device         Start       End   Sectors   Size Type</span><br><span class="line">/dev/sda1       2048   1050623   1048576   512M EFI System</span><br><span class="line">/dev/sda2    1050624 909946879 908896256 433.4G Linux filesystem</span><br><span class="line">/dev/sda3  909946880 976771071  66824192  31.9G Linux swap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3.7 TiB, 4000787030016 bytes, 7814037168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 0D8B0FBC-83F6-4D77-ABDB-98875EC511E4</span><br><span class="line"></span><br><span class="line">Device     Start        End    Sectors  Size Type</span><br><span class="line">/dev/sdb1   2048 7814035455 7814033408  3.7T Linux filesystem</span><br></pre></td></tr></table></figure><h3 id="格式化新建分区"><a href="#格式化新建分区" class="headerlink" title="格式化新建分区"></a>格式化新建分区</h3><p>将分区格式化为ext4格式的文件系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# mkfs.ext4 /dev/sdb1</span><br><span class="line">mke2fs 1.42.13 (17-May-2015)</span><br><span class="line">Creating filesystem with 976754176 4k blocks and 244195328 inodes</span><br><span class="line">Filesystem UUID: dfcd419f-38a5-4a5c-9b93-9f236d2c2444</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, </span><br><span class="line">4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968, </span><br><span class="line">102400000, 214990848, 512000000, 550731776, 644972544</span><br><span class="line"></span><br><span class="line">Allocating group tables: done                            </span><br><span class="line">Writing inode tables: done                            </span><br><span class="line">Creating journal (32768 blocks): done</span><br><span class="line">Writing superblocks and filesystem accounting information:            </span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>如果有多个分区需要依次执行格式化。</p><h3 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h3><p>新建硬盘即将挂载的目录，然后将硬盘挂载到该目录下。并验证挂载成功，检查硬盘空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# mkdir /data</span><br><span class="line">root@deeplearning:/# mount /dev/sdb1 /data</span><br><span class="line">root@deeplearning:/# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev             16G     0   16G   0% /dev</span><br><span class="line">tmpfs           3.2G  9.3M  3.2G   1% /run</span><br><span class="line">/dev/sda2       427G   21G  385G   5% /</span><br><span class="line">tmpfs            16G     0   16G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M   1% /run/lock</span><br><span class="line">tmpfs            16G     0   16G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1       511M  3.5M  508M   1% /boot/efi</span><br><span class="line">tmpfs           3.2G   12K  3.2G   1% /run/user/1000</span><br><span class="line">/dev/sdb1       3.6T   68M  3.4T   1% /data</span><br></pre></td></tr></table></figure><p>上面我们把新的硬盘挂载到了/data目录，硬盘空间大小正常。</p><h3 id="配置开机自动挂载分区"><a href="#配置开机自动挂载分区" class="headerlink" title="配置开机自动挂载分区"></a>配置开机自动挂载分区</h3><h4 id="查看分区的UUID"><a href="#查看分区的UUID" class="headerlink" title="查看分区的UUID"></a>查看分区的UUID</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# blkid</span><br><span class="line"><span class="meta">#</span>（略）...</span><br><span class="line">/dev/sdb1: UUID="dfcd419f-38a5-4a5c-9b93-9f236d2c2444" TYPE="ext4" PARTUUID="fe373bd5-5b19-4ed0-8713-716455a8ebb4"</span><br></pre></td></tr></table></figure><h4 id="配置-etc-fstab"><a href="#配置-etc-fstab" class="headerlink" title="配置/etc/fstab"></a>配置/etc/fstab</h4><p>将分区信息写到/etc/fstab文件中让它永久挂载:</p><p>将下面的配置信息加入配置文件尾部：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=dfcd419f-38a5-4a5c-9b93-9f236d2c2444 /data ext4 defaults 0 1</span><br></pre></td></tr></table></figure><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="etc-fstab配置说明"><a href="#etc-fstab配置说明" class="headerlink" title="/etc/fstab配置说明"></a>/etc/fstab配置说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Use &apos;blkid&apos; to print the universally unique identifier for a</span><br><span class="line"># device; this may be used with UUID= as a more robust way to name devices</span><br><span class="line"># that works even if disks are added and removed. See fstab(5).</span><br><span class="line"></span><br><span class="line">&lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;      &lt;pass&gt;</span><br><span class="line">    1               2            3         4             5            6</span><br><span class="line">对应参数说明：</span><br><span class="line">1、指代文件系统的设备名。最初，该字段只包含待挂载分区的设备名（如/dev/sda1）。现在，除设备名外，还可以包含LABEL或UUID</span><br><span class="line">2、文件系统挂载点。文件系统包含挂载点下整个目录树结构里的所有数据，除非其中某个目录又挂载了另一个文件系统</span><br><span class="line">3、文件系统类型。下面是多数常见文件系统类型（ext3,tmpfs,devpts,sysfs,proc,swap,vfat）</span><br><span class="line">4、mount命令选项。mount选项包括noauto（启动时不挂载该文件系统）和ro（只读方式挂载文件系统）等。在该字段里添加用户或属主选项，即可允许该用户挂载文件系统。多个选项之间必须用逗号隔开。其他选项的相关信息可参看mount命令手册页（-o选项处）</span><br><span class="line">5、转储文件系统？该字段只在用dump备份时才有意义。数字1表示该文件系统需要转储，0表示不需要转储</span><br><span class="line">6、文件系统检查？该字段里的数字表示文件系统是否需要用fsck检查。0表示不必检查该文件系统，数字1示意该文件系统需要先行检查（用于根文件系统）。数字2则表示完成根文件系统检查后，再检查该文件系统。</span><br></pre></td></tr></table></figure><h4 id="Parted命令说明（本文使用交互模式完成配置）"><a href="#Parted命令说明（本文使用交互模式完成配置）" class="headerlink" title="Parted命令说明（本文使用交互模式完成配置）"></a>Parted命令说明（本文使用交互模式完成配置）</h4><p>Parted 命令分为两种模式：命令行模式和交互模式。</p><ul><li>命令行模式： parted [option] device [command] ,该模式可以直接在命令行下对磁盘进行分区操作，比较适合编程应用。</li><li>交互模式：parted [option] device 类似于使用fdisk /dev/xxx</li><li>MBR：MBR分区表(即主引导记录)大家都很熟悉。所支持的最大卷：2T，而且对分区有限制：最多4个主分区或3个主分区加一个扩展分区</li><li>GPT： GPT（即GUID分区表）。是源自EFI标准的一种较新的磁盘分区表结构的标准，是未来磁盘分区的主要形式。与MBR分区方式相比，具有如下优点。突破MBR 4个主分区限制，每个磁盘最多支持128个分区。支持大于2T的分区，最大卷可达18EB。</li></ul><p>parted是一个可以分区并进行分区调整的工具，他可以创建，破坏，移动，复制，调整ext2 linux-swap fat fat32 reiserfs类型的分区，可以创建，调整，移动Macintosh的HFS分区，检测jfs，ntfs，ufs，xfs分区。</p><p>使用方法：<code>parted [options] [device [command [options...]...]]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">options</span><br><span class="line">-h  显示帮助信息</span><br><span class="line">-l  显示所有块设备上的分区</span><br><span class="line">device 对哪个块设备进行操作，如果没有指定则使用第一个块设备</span><br><span class="line">command [options...]</span><br><span class="line"></span><br><span class="line">check partition  对分区做一个简单的检测</span><br><span class="line"></span><br><span class="line">cp [source-device] source dest  复制source-device设备上的source分区到当前设备的dest分区</span><br><span class="line"></span><br><span class="line">mklabel label-type 创建新分区表类型，label-type可以是："bsd", "dvh", "gpt",  "loop","mac", "msdos", "pc98", or "sun" 一般的pc机都是msdos格式，如果分区大于2T则需要选用gpt格式的分区表。</span><br><span class="line"></span><br><span class="line">mkfs partition fs-type   在partition分区上创建一个fs-type文件系统，fs-type可以是："fat16", "fat32", "ext2", "linux-swap","reiserfs" 注意不支持ext3格式的文件系统，只能先分区然后用专有命令进行格式化。</span><br><span class="line"></span><br><span class="line">mkpart part-type [fs-type] start end  创建一个part-type类型的分区，part-type可以是："primary", "logical", or "extended" 如果指定fs-type则在创建分区的同时进行格式化。start和end指的是分区的起始位置，单位默认是M。</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">mkpart  primary  0  -1   0表示分区的开始  -1表示分区的结尾  意思是划分整个硬盘空间为主分区</span><br><span class="line">mkpartfs part-type fs-type start end 创建一个fs-type类型的part-type分区，不推荐使用，最好是使用mkpart分区完成后使用mke2fs进行格式化。</span><br><span class="line">name partition name 给分区设置一个名字，这种设置只能用在Mac, PC98, and GPT类型的分区表，设置时名字用引号括起来</span><br><span class="line">select device 在机器上有多个硬盘时，选择操作那个硬盘</span><br><span class="line">resize partition start end  调整分区大小</span><br><span class="line">rm partition  删除一个分区</span><br><span class="line">rescue start end  拯救一个位于stat和end之间的分区</span><br><span class="line">unit unit 在前面分区时，默认分区时数值的单位是M，这个参数卡伊改变默认单位，"kB", "MB",  "GB",  "TB"</span><br><span class="line">move partition start end 移动partition分区</span><br><span class="line">print  显示分区表信息  </span><br><span class="line">quit 退出parted</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>【1】  <a href="http://magicmonster.com/kb/os/linux/large_hdd.html" target="_blank" rel="noopener">Setting up a large (2TB+) hard disk drive on Linux</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;系统环境：&quot;&gt;&lt;a href=&quot;#系统环境：&quot; class=&quot;headerlink&quot; title=&quot;系统环境：&quot;&gt;&lt;/a&gt;系统环境：&lt;/h3&gt;&lt;p&gt;Linux version 4.13.0-37-generic (Ubuntu 5.4.0-6ubuntu1~16.
      
    
    </summary>
    
      <category term="ubuntu" scheme="https://zjrongxiang.github.io/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="https://zjrongxiang.github.io/tags/ubuntu/"/>
    
      <category term="disk" scheme="https://zjrongxiang.github.io/tags/disk/"/>
    
      <category term="parted" scheme="https://zjrongxiang.github.io/tags/parted/"/>
    
  </entry>
  
  <entry>
    <title>Hexo:解决Typora编辑table无法被解析问题</title>
    <link href="https://zjrongxiang.github.io/2018/04/01/2018-04-05-Hexo_table/"/>
    <id>https://zjrongxiang.github.io/2018/04/01/2018-04-05-Hexo_table/</id>
    <published>2018-04-01T15:30:00.000Z</published>
    <updated>2018-04-05T15:07:08.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="掉坑背景"><a href="#掉坑背景" class="headerlink" title="掉坑背景"></a>掉坑背景</h3><p>使用Typora编辑Makedown文件，添加表格，但是提交给Hexo渲染网页，无法正常解析显示，而是显示源码。例如：<br>| Table Header 1 | Table Header 2 |<br>| ————– | ————– |<br>| Division 1     | Division 2     |<br>| Division 1     | Division 2     |</p><h3 id="爬坑过程和解决办法"><a href="#爬坑过程和解决办法" class="headerlink" title="爬坑过程和解决办法"></a>爬坑过程和解决办法</h3><p>一开始认为是Hexo的bug，Google也没人遇到类似情况，都准备在github上建问题单了。最后本着严谨的态度，以文本的格式打开文档，发现表格源码和正文之间没有空行！！！！！</p><p>这尼玛坑爹呀，所以Hexo无法解析，但是Typora能正常解析。空出一行后正常解析：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;正文&gt;</span><br><span class="line">(空一行)</span><br><span class="line">| Table Header 1 | Table Header 2 |</span><br><span class="line">| - | - | </span><br><span class="line">| Division 1 | Division 2 | </span><br><span class="line">| Division 1 | Division 2 |</span><br></pre></td></tr></table></figure><table><thead><tr><th>Table Header 1</th><th>Table Header 2</th></tr></thead><tbody><tr><td>Division 1</td><td>Division 2</td></tr><tr><td>Division 1</td><td>Division 2</td></tr></tbody></table><p>这一点Typora做的不够兼容（只怪他太过于强大的解析能力。。。。）。Tyopra不服了，我强大也有错？？哈哈哈</p><p>记录该坑供掉坑小伙伴参考。</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>如果掉坑小伙伴，上面办法没解决。用文本方式打开文件，逐个排查原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;掉坑背景&quot;&gt;&lt;a href=&quot;#掉坑背景&quot; class=&quot;headerlink&quot; title=&quot;掉坑背景&quot;&gt;&lt;/a&gt;掉坑背景&lt;/h3&gt;&lt;p&gt;使用Typora编辑Makedown文件，添加表格，但是提交给Hexo渲染网页，无法正常解析显示，而是显示源码。例如：&lt;br
      
    
    </summary>
    
      <category term="hexo" scheme="https://zjrongxiang.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://zjrongxiang.github.io/tags/hexo/"/>
    
      <category term="Typora" scheme="https://zjrongxiang.github.io/tags/Typora/"/>
    
      <category term="table" scheme="https://zjrongxiang.github.io/tags/table/"/>
    
  </entry>
  
  <entry>
    <title>jupyter notebook:主题和字体的美化</title>
    <link href="https://zjrongxiang.github.io/2018/03/19/2018-03-26-jupyter-notebook/"/>
    <id>https://zjrongxiang.github.io/2018/03/19/2018-03-26-jupyter-notebook/</id>
    <published>2018-03-19T11:30:00.000Z</published>
    <updated>2018-04-06T04:06:41.421Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Jupyter notebook是数据科学常用的代码交互式工具。通常在server端启jupyter进程（web服务），client端打开浏览器，jupyter提供代码编写和调试交互环境。非常方便。</p><p>但是jupyter提供的默认界面不够美观，特别是windows操作系统默认字体为浏览器默认字体–宋体（下图），另外默认主题太难看了，没有通常IDE提供的主题美观。</p><p><img src="\images\picture\jupyter01.jpg" alt=""></p><p>发现一个Jupyter的美化工具：<strong><a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="noopener">jupyterthemes</a></strong> ，和大家分享一下。简单介绍一下安装和配置。细节介绍参考项目的介绍文档。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用pip安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# pip install jupyterthemes</span><br></pre></td></tr></table></figure><p>或者使用<a href="https://anaconda.org/conda-forge/jupyterthemes" target="_blank" rel="noopener">Anaconda的conda安装</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# conda install -c conda-forge jupyterthemes</span><br></pre></td></tr></table></figure><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>使用<code>jt -h</code>显示命令帮助说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# jt -h</span><br><span class="line">usage: jt [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT]</span><br><span class="line">          [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-dfs DFFONTSIZE]</span><br><span class="line">          [-ofs OUTFONTSIZE] [-mathfs MATHFONTSIZE] [-m MARGINS]</span><br><span class="line">          [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-cellw CELLWIDTH]</span><br><span class="line">          [-lineh LINEHEIGHT] [-altp] [-altmd] [-altout] [-P] [-T] [-N] [-vim]</span><br><span class="line">          [-r] [-dfonts]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line"><span class="meta">  #</span>-h，--help显示此帮助信息并退出</span><br><span class="line">  -l, --list            list available themes</span><br><span class="line"><span class="meta">  #</span>-l， 列出可用主题</span><br><span class="line">  -t THEME, --theme THEME</span><br><span class="line">                        theme name to install（配置需要安装的主题）</span><br><span class="line">  -f MONOFONT, --monofont MONOFONT</span><br><span class="line">                        monospace code font（代码的字体）</span><br><span class="line">  -fs MONOSIZE, --monosize MONOSIZE</span><br><span class="line">                        code font-size（代码字体大小）</span><br><span class="line">  -nf NBFONT, --nbfont NBFONT</span><br><span class="line">                        notebook font（notebook 字体）</span><br><span class="line">  -nfs NBFONTSIZE, --nbfontsize NBFONTSIZE</span><br><span class="line">                        notebook fontsize（notebook 字体大小）</span><br><span class="line">  -tf TCFONT, --tcfont TCFONT</span><br><span class="line">                        txtcell font（文本的字体）</span><br><span class="line">  -tfs TCFONTSIZE, --tcfontsize TCFONTSIZE</span><br><span class="line">                        txtcell fontsize（文本的字体大小）</span><br><span class="line">  -dfs DFFONTSIZE, --dffontsize DFFONTSIZE</span><br><span class="line">                        pandas dataframe fontsize（pandas类型的字体大小）</span><br><span class="line">  -ofs OUTFONTSIZE, --outfontsize OUTFONTSIZE</span><br><span class="line">                        output area fontsize（输出区域字体大小）</span><br><span class="line">  -mathfs MATHFONTSIZE, --mathfontsize MATHFONTSIZE</span><br><span class="line">                        mathjax fontsize (in %)（数学公式字体大小）</span><br><span class="line">  -m MARGINS, --margins MARGINS</span><br><span class="line">                        fix margins of main intro page</span><br><span class="line">  -cursw CURSORWIDTH, --cursorwidth CURSORWIDTH</span><br><span class="line">                        set cursorwidth (px)（设置光标宽度）</span><br><span class="line">  -cursc CURSORCOLOR, --cursorcolor CURSORCOLOR</span><br><span class="line">                        cursor color (r, b, g, p)（设置光标颜色）</span><br><span class="line">  -cellw CELLWIDTH, --cellwidth CELLWIDTH</span><br><span class="line">                        set cell width (px or %)（单元的宽度）</span><br><span class="line">  -lineh LINEHEIGHT, --lineheight LINEHEIGHT</span><br><span class="line">                        code/text line-height (%)（行高）</span><br><span class="line">  -altp, --altprompt    alt input prompt style</span><br><span class="line">  -altmd, --altmarkdown</span><br><span class="line">                        alt markdown cell style</span><br><span class="line">  -altout, --altoutput  set output bg color to notebook bg</span><br><span class="line">  -P, --hideprompt      hide cell input prompt</span><br><span class="line">  -T, --toolbar         make toolbar visible（工具栏可见）</span><br><span class="line">  -N, --nbname          nb name/logo visible</span><br><span class="line">  -vim, --vimext        toggle styles for vim</span><br><span class="line">  -r, --reset           reset to default theme（设置成默认主题）</span><br><span class="line">  -dfonts, --defaultfonts</span><br><span class="line">                        force fonts to browser default（设置成浏览器默认字体）</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>例如下面的命令完成效果：</p><p>使用的主题是：monokai，工具栏可见，命名笔记本的选项，代码的字体为13，代码的字体为consolamono。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# jt -t monokai -T -N -fs 13 -f consolamono</span><br></pre></td></tr></table></figure><p>如果jupyter进程已启，需要重新启进程后生效。</p><p>实现的效果截图：</p><p><img src="\images\picture\jupyter2.jpg" alt=""></p><p>其他主题效果大家可以自己尝试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;Jupyter notebook是数据科学常用的代码交互式工具。通常在server端启jupyter进程（web服务），client端打开浏
      
    
    </summary>
    
      <category term="jupyter_notebook" scheme="https://zjrongxiang.github.io/categories/jupyter-notebook/"/>
    
    
      <category term="jupyter notebook" scheme="https://zjrongxiang.github.io/tags/jupyter-notebook/"/>
    
  </entry>
  
  <entry>
    <title>树莓派：使用USB摄像头自制家庭监控</title>
    <link href="https://zjrongxiang.github.io/2018/03/18/2018-03-18-raspberry_usb_camera/"/>
    <id>https://zjrongxiang.github.io/2018/03/18/2018-03-18-raspberry_usb_camera/</id>
    <published>2018-03-18T11:30:00.000Z</published>
    <updated>2018-04-04T14:31:39.756Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树莓派摄像头和USB摄像头"><a href="#树莓派摄像头和USB摄像头" class="headerlink" title="树莓派摄像头和USB摄像头"></a>树莓派摄像头和USB摄像头</h3><blockquote><p>树莓派有配套的摄像头模块（Raspberry Pi camera board），如下图。</p><p>另外树莓派也支持USB摄像头。关于树莓派支持的USB摄像头有个<a href="https://elinux.org/RPi_USB_Webcams" target="_blank" rel="noopener">清单参考</a>（需要梯子）。大家购买前最好确认一下是否在兼容清单中。</p></blockquote><p><img src="\images\picture\camera_pi.png" alt="camera_pi"></p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><h4 id="第一步：检查USB摄像头和树莓派的兼容性"><a href="#第一步：检查USB摄像头和树莓派的兼容性" class="headerlink" title="第一步：检查USB摄像头和树莓派的兼容性"></a>第一步：检查USB摄像头和树莓派的兼容性</h4><p>将USB摄像头和树莓派连接，查看USB接口连接情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/# lsusb</span><br><span class="line">Bus 001 Device 004: ID 046d:0825 Logitech, Inc. Webcam C270</span><br><span class="line">Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet Adapter</span><br><span class="line">Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp.</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure><p>发现004口上面连接并识别了摄像头（我的是Logitech 270摄像头）。</p><blockquote><p>如果没有识别出来，需要查看USB兼容清单是否有该型号。另外由于树莓派供电功率较小，也有可能是USB供电功率不足，需要有外置电源的USB摄像头。</p></blockquote><p>另外还可以查看设备驱动情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/# ls /dev/vid*</span><br><span class="line">/dev/video0</span><br></pre></td></tr></table></figure><p>发现video0设备，说明识别了USB摄像头（罗技的c270i）</p><h4 id="第二步：MOTION软件实现"><a href="#第二步：MOTION软件实现" class="headerlink" title="第二步：MOTION软件实现"></a>第二步：MOTION软件实现</h4><p>对于USB摄像头，有多种软件包可以实现拍照和摄像等功能，这里使用<a href="https://github.com/Motion-Project/motion" target="_blank" rel="noopener">motion</a>。</p><h5 id="安装motion"><a href="#安装motion" class="headerlink" title="安装motion"></a>安装motion</h5>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/# sudo apt-get install motion</span><br></pre></td></tr></table></figure><h5 id="编辑配置配置文件"><a href="#编辑配置配置文件" class="headerlink" title="编辑配置配置文件"></a>编辑配置配置文件</h5>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# vi /etc/motion/motion.conf</span><br></pre></td></tr></table></figure><h5 id="调整相关参数"><a href="#调整相关参数" class="headerlink" title="调整相关参数"></a>调整相关参数</h5>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> The mini-http server listens to this port for requests (default: 0 = disabled)</span><br><span class="line">stream_port 8082</span><br><span class="line"><span class="meta">#</span> web界面访问端口</span><br><span class="line"><span class="meta">#</span> TCP/IP port for the http server to listen on (default: 0 = disabled)</span><br><span class="line">webcontrol_port 8080</span><br><span class="line"><span class="meta">#</span>控制端口</span><br><span class="line"><span class="meta">#</span> Restrict control connections to localhost only (default: on)</span><br><span class="line">webcontrol_localhost off</span><br><span class="line"><span class="meta">#</span> Target base directory for pictures and films</span><br><span class="line"><span class="meta">#</span> Recommended to use absolute path. (Default: current working directory)</span><br><span class="line">target_dir /var/lib/motion</span><br><span class="line"><span class="meta">#</span>照片及视频存放路径</span><br></pre></td></tr></table></figure><p>其他参数调整如下：</p><p>​          <em>ffmpeg_output_movies</em>=off</p><p>​           <em>stream_localhost</em>=off</p><p>​           <em>webcontrol_localhost</em>=off</p><p>  ​         <em>locate_motion_mode</em>=peview</p><p>  ​         <em>locate_motion_style</em>=redbox</p><p>​           <em>text_changes</em>=on</p><h5 id="开启motion进程"><a href="#开启motion进程" class="headerlink" title="开启motion进程"></a>开启motion进程</h5><p>修改motion文件，设置为守护进程运行（即参数配置为：yes）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> vi /etc/default/motion</span><br><span class="line"><span class="meta">#</span> set to 'yes' to enable the motion daemon</span><br><span class="line">start_motion_daemon=yes</span><br></pre></td></tr></table></figure><p>启进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/etc/init.d# motion start</span><br><span class="line">[0] [NTC] [ALL] conf_load: Processing thread 0 - config file /etc/motion/motion.conf</span><br><span class="line">[0] [ALR] [ALL] conf_cmdparse: Unknown config option "sdl_threadnr"</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Motion 3.2.12+git20140228 Started</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Logging to syslog</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Using log type (ALL) log level (NTC)</span><br><span class="line">[0] [NTC] [ALL] become_daemon: Motion going to daemon mode</span><br></pre></td></tr></table></figure><h5 id="查看监控画面"><a href="#查看监控画面" class="headerlink" title="查看监控画面"></a>查看监控画面</h5><p>地址栏中输入地址和端口号（IP：8082），上面配置的web界面访问端口为8082：</p><p><img src="\images\picture\example.png" alt=""></p><h5 id="查看监控数据存放目录"><a href="#查看监控数据存放目录" class="headerlink" title="查看监控数据存放目录"></a>查看监控数据存放目录</h5><p>另外目录/var/lib/motion中存放历史数据。</p><h4 id="第三步：内网穿透（外网访问web监控界面）"><a href="#第三步：内网穿透（外网访问web监控界面）" class="headerlink" title="第三步：内网穿透（外网访问web监控界面）"></a>第三步：内网穿透（外网访问web监控界面）</h4><p>实现上面的步骤，你只能在家里本地局域网访问监控界面，意义不大。</p><p>由于目前中国宽带服务公司都不会给家庭网络外网地址。所以需要内网穿透，实现外网访问家庭内网。</p><p>具体可以使用frp软件实现内网穿透。具体做法参考的博客中另一篇介绍frp的分享文章。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>【1】 <a href="https://www.bouvet.no/bouvet-deler/utbrudd/building-a-motion-activated-security-camera-with-the-raspberry-pi-zero" target="_blank" rel="noopener">https://www.bouvet.no/bouvet-deler/utbrudd/building-a-motion-activated-security-camera-with-the-raspberry-pi-zero</a></p><p>【2】 <a href="https://medium.com/@Cvrsor/how-to-make-a-diy-home-alarm-system-with-a-raspberry-pi-and-a-webcam-2d5a2d61da3d" target="_blank" rel="noopener">https://medium.com/@Cvrsor/how-to-make-a-diy-home-alarm-system-with-a-raspberry-pi-and-a-webcam-2d5a2d61da3d</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;树莓派摄像头和USB摄像头&quot;&gt;&lt;a href=&quot;#树莓派摄像头和USB摄像头&quot; class=&quot;headerlink&quot; title=&quot;树莓派摄像头和USB摄像头&quot;&gt;&lt;/a&gt;树莓派摄像头和USB摄像头&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;树莓派有配套的摄像头模块（
      
    
    </summary>
    
      <category term="raspberry" scheme="https://zjrongxiang.github.io/categories/raspberry/"/>
    
    
      <category term="raspberry" scheme="https://zjrongxiang.github.io/tags/raspberry/"/>
    
  </entry>
  
  <entry>
    <title>动手实现深度学习相机</title>
    <link href="https://zjrongxiang.github.io/2018/03/14/2018-03-14-deeplearning_camera/"/>
    <id>https://zjrongxiang.github.io/2018/03/14/2018-03-14-deeplearning_camera/</id>
    <published>2018-03-14T11:30:00.000Z</published>
    <updated>2018-03-14T12:13:33.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017年年底，亚马逊（AWS）宣布将推出深度学习相机——<a href="https://www.amazon.com/AWS-DeepLens-learning-enabled-developers/dp/B075Y3CK37" target="_blank" rel="noopener">DeepLens </a> ，亚马逊官网已经开始预售，预计6月14日发货。但是售价为249刀（约1600人民币）。偏贵了。</p><p>具体介绍可以参考这篇文章：<a href="http://blog.csdn.net/R1uNW1W/article/details/78699883" target="_blank" rel="noopener">AWS深度学习摄像头，将对机器学习产业有何影响？</a></p></blockquote><p>看到有人利用树莓派和简易摄像头实现了一个深度学习相机，用来检测院子里面小鸟吃食。正好自己有一个树莓派，可以参考玩一下。进一步优化甚至可以放在家门口，对访客人脸识别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;2017年年底，亚马逊（AWS）宣布将推出深度学习相机——&lt;a href=&quot;https://www.amazon.com/AWS-DeepLens-learning-enabled-developers/dp/B075Y3CK37&quot; target=
      
    
    </summary>
    
      <category term="deep learning" scheme="https://zjrongxiang.github.io/categories/deep-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu系统版本信息查询</title>
    <link href="https://zjrongxiang.github.io/2018/03/14/2018-03-15-ubuntu_ssh_ip_OK/"/>
    <id>https://zjrongxiang.github.io/2018/03/14/2018-03-15-ubuntu_ssh_ip_OK/</id>
    <published>2018-03-14T11:30:00.000Z</published>
    <updated>2018-04-06T03:38:28.720Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要汇总查询Ubuntu系统的信息的相关命令及展示案例。</p><p>会持续更新。</p><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><h4 id="查看：CPU信息"><a href="#查看：CPU信息" class="headerlink" title="查看：CPU信息"></a>查看：CPU信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# cat /proc/version</span><br><span class="line">Linux version 4.13.0-37-generic (buildd@lcy01-amd64-012) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9)) #42~16.04.1-Ubuntu SMP Wed Mar 7 16:03:28 UTC 2018</span><br></pre></td></tr></table></figure><h4 id="查看：内核、操作系统、CPU信息"><a href="#查看：内核、操作系统、CPU信息" class="headerlink" title="查看：内核、操作系统、CPU信息"></a>查看：内核、操作系统、CPU信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# uname -a</span><br><span class="line">Linux deeplearning 4.13.0-37-generic #42~16.04.1-Ubuntu SMP Wed Mar 7 16:03:28 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><h4 id="查看：操作系统版本信息"><a href="#查看：操作系统版本信息" class="headerlink" title="查看：操作系统版本信息"></a>查看：操作系统版本信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 16.04.4 LTS</span><br><span class="line">Release:        16.04</span><br><span class="line">Codename:       xenial</span><br></pre></td></tr></table></figure><h4 id="查看：计算机名"><a href="#查看：计算机名" class="headerlink" title="查看：计算机名"></a>查看：计算机名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# hostname</span><br><span class="line">vultr.guest</span><br></pre></td></tr></table></figure><h3 id="资源信息"><a href="#资源信息" class="headerlink" title="资源信息"></a>资源信息</h3><h4 id="查看：存储分区的使用信息"><a href="#查看：存储分区的使用信息" class="headerlink" title="查看：存储分区的使用信息"></a>查看：存储分区的使用信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            469M     0  469M   0% /dev</span><br><span class="line">tmpfs            99M   11M   89M  11% /run</span><br><span class="line">/dev/vda1        25G   12G   12G  49% /</span><br><span class="line">tmpfs           495M     0  495M   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           495M     0  495M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs            99M     0   99M   0% /run/user/0</span><br></pre></td></tr></table></figure><h4 id="查看：系统运行时间、用户数量"><a href="#查看：系统运行时间、用户数量" class="headerlink" title="查看：系统运行时间、用户数量"></a>查看：系统运行时间、用户数量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# uptime</span><br><span class="line"> 23:04:54 up 10 days, 17:21,  1 user,  load average: 0.21, 0.06, 0.02</span><br></pre></td></tr></table></figure><h3 id="磁盘信息"><a href="#磁盘信息" class="headerlink" title="磁盘信息"></a>磁盘信息</h3><h4 id="查看-所有分区信息"><a href="#查看-所有分区信息" class="headerlink" title="查看:所有分区信息"></a>查看:所有分区信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# fdisk -l</span><br><span class="line">Disk /dev/vda: 25 GiB, 26843545600 bytes, 52428800 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0xcb855d49</span><br><span class="line"></span><br><span class="line">Device     Boot Start      End  Sectors Size Id Type</span><br><span class="line">/dev/vda1  *     2048 52428257 52426210  25G 83 Linux</span><br></pre></td></tr></table></figure><h3 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h3><h4 id="查看：网络接口信息"><a href="#查看：网络接口信息" class="headerlink" title="查看：网络接口信息"></a>查看：网络接口信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# ifconfig</span><br><span class="line"><span class="meta">#</span>（略）</span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 198660  bytes 27478459 (27.4 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 198660  bytes 27478459 (27.4 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><h4 id="查看：防火墙信息"><a href="#查看：防火墙信息" class="headerlink" title="查看：防火墙信息"></a>查看：防火墙信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# iptables -L</span><br><span class="line">Chain DOCKER-USER (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">RETURN     all  --  anywhere             anywhere</span><br></pre></td></tr></table></figure><h4 id="查看：路由表"><a href="#查看：路由表" class="headerlink" title="查看：路由表"></a>查看：路由表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">#（略）</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br></pre></td></tr></table></figure><h4 id="查看：监听端口、已经建立的连接"><a href="#查看：监听端口、已经建立的连接" class="headerlink" title="查看：监听端口、已经建立的连接"></a>查看：监听端口、已经建立的连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# netstat -lntp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      749/sshd</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# netstat -antp</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      749/sshd</span><br></pre></td></tr></table></figure><h4 id="查看：网络统计信息"><a href="#查看：网络统计信息" class="headerlink" title="查看：网络统计信息"></a>查看：网络统计信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# netstat -s</span><br><span class="line">Ip:</span><br><span class="line">    Forwarding: 1</span><br><span class="line">    5729182 total packets received</span><br><span class="line">    9 with invalid addresses</span><br><span class="line">#略信息</span><br></pre></td></tr></table></figure><h3 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h3><h4 id="查看：所有进程信息"><a href="#查看：所有进程信息" class="headerlink" title="查看：所有进程信息"></a>查看：所有进程信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# ps -ef </span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 Mar25 ?        00:00:44 /sbin/init</span><br></pre></td></tr></table></figure><h4 id="查看：实时显示进程状态"><a href="#查看：实时显示进程状态" class="headerlink" title="查看：实时显示进程状态"></a>查看：实时显示进程状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# top</span><br><span class="line">top - 23:24:19 up 10 days, 17:41,  1 user,  load average: 0.02, 0.02, 0.00</span><br><span class="line">Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.7 us,  0.3 sy,  0.0 ni, 99.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1012392 total,    74384 free,   270236 used,   667772 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   556896 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                 </span><br><span class="line">25691 root      20   0  554760  13348   3448 S  0.3  1.3  35:21.42 docker-containe </span><br><span class="line">#（略信息）</span><br></pre></td></tr></table></figure><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><h4 id="查看：活动用户"><a href="#查看：活动用户" class="headerlink" title="查看：活动用户"></a>查看：活动用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# w</span><br><span class="line"> 23:25:22 up 10 days, 17:42,  1 user,  load average: 0.33, 0.08, 0.02</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/0    140.31.74.0      22:59    2.00s  0.06s  0.00s w</span><br></pre></td></tr></table></figure><h4 id="查看：用户登录日志信息"><a href="#查看：用户登录日志信息" class="headerlink" title="查看：用户登录日志信息"></a>查看：用户登录日志信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# last</span><br><span class="line">root     pts/0        113.41.56.0      Wed Apr  4 22:59   still logged in</span><br><span class="line">root     pts/0        113.41.56.0      Wed Apr  4 08:37 - 13:38  (05:00)</span><br><span class="line"></span><br><span class="line">wtmp begins Sun Apr  1 19:59:32 2018</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客主要汇总查询Ubuntu系统的信息的相关命令及展示案例。&lt;/p&gt;
&lt;p&gt;会持续更新。&lt;/p&gt;
&lt;h3 id=&quot;系统信息&quot;&gt;&lt;a href=&quot;#系统信息&quot; class=&quot;headerlink&quot; title=&quot;系统信息&quot;&gt;&lt;/a&gt;系统信息&lt;/h3&gt;&lt;h4 id=&quot;查看：
      
    
    </summary>
    
      <category term="ubuntu" scheme="https://zjrongxiang.github.io/categories/ubuntu/"/>
    
    
      <category term="Ubuntu" scheme="https://zjrongxiang.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu添加国内apt更新源</title>
    <link href="https://zjrongxiang.github.io/2018/03/14/2018-03-15-ubuntu_apt_change/"/>
    <id>https://zjrongxiang.github.io/2018/03/14/2018-03-15-ubuntu_apt_change/</id>
    <published>2018-03-14T11:30:00.000Z</published>
    <updated>2018-04-06T03:43:41.473Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要介绍如何更改Ubuntu系统的apt源。</p><h3 id="关于源"><a href="#关于源" class="headerlink" title="关于源"></a>关于源</h3><p>我们使用apt安装软件时，会到国外源下载软件包。但是由于各种原因（你懂的）国外站点到国内的下载速度非常缓慢，甚至1k/s。对于大的包，这是无法忍受的等待，经常会超时中断。所以我们换成国内的源站点。其中口碑比较好的源站点有：阿里源、清华源、中科大源等。</p><p>Ubuntu系统的源地址文件位置：/etc/apt/sources.list</p><h3 id="更换步骤"><a href="#更换步骤" class="headerlink" title="更换步骤"></a>更换步骤</h3><h4 id="第一步：备份"><a href="#第一步：备份" class="headerlink" title="第一步：备份"></a>第一步：备份</h4><blockquote><p>对于系统文件的修改建议实施备份。养成良好的变更习惯。关键时候能救命。</p><p>关于备份文件命名有两个建议：（1）含有backup字段提示为备份文件；（2）含有备份日期，便于区分多个备份。当然如果是多用户话应该含有用户名，便于区分。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# cp /etc/apt/sources.list /etc/apt/sources.list.backup.20180315</span><br></pre></td></tr></table></figure><h4 id="第二步：添加源地址"><a href="#第二步：添加源地址" class="headerlink" title="第二步：添加源地址"></a>第二步：添加源地址</h4><blockquote><p>我们添加<a href="https://opsx.alibaba.com/" target="_blank" rel="noopener">阿里源</a>， 进入阿里云开源镜像站，找到ubuntu的帮助信息：</p><p>我们版本号Ubuntu 16.04.4 LTS，并且Codename: xenial。需要根据自己的版本对应相应的源。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure><p>直接将source.list中内容用上面的源地址内容替换，保存后退出。更新源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# apt-get update</span><br></pre></td></tr></table></figure><h3 id="附录：apt的常用操作命令清单"><a href="#附录：apt的常用操作命令清单" class="headerlink" title="附录：apt的常用操作命令清单"></a>附录：apt的常用操作命令清单</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  更新源</span><br><span class="line">sudo apt-get install package 安装包</span><br><span class="line">sudo apt-get remove package 删除包</span><br><span class="line">sudo apt-cache search package 搜索软件包</span><br><span class="line">sudo apt-cache show package  获取包的相关信息，如说明、大小、版本等</span><br><span class="line">sudo apt-get install package --reinstall  重新安装包</span><br><span class="line">sudo apt-get -f install  修复安装</span><br><span class="line">sudo apt-get remove package --purge 删除包，包括配置文件等</span><br><span class="line">sudo apt-get build-dep package 安装相关的编译环境</span><br><span class="line">sudo apt-get upgrade 更新已安装的包</span><br><span class="line">sudo apt-get dist-upgrade 升级系统</span><br><span class="line">sudo apt-cache depends package 了解使用该包依赖那些包</span><br><span class="line">sudo apt-cache rdepends package 查看该包被哪些包依赖</span><br><span class="line">sudo apt-get source package  下载该包的源代码</span><br><span class="line">sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包</span><br><span class="line">sudo apt-get check 检查是否有损坏的依赖</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客主要介绍如何更改Ubuntu系统的apt源。&lt;/p&gt;
&lt;h3 id=&quot;关于源&quot;&gt;&lt;a href=&quot;#关于源&quot; class=&quot;headerlink&quot; title=&quot;关于源&quot;&gt;&lt;/a&gt;关于源&lt;/h3&gt;&lt;p&gt;我们使用apt安装软件时，会到国外源下载软件包。但是由于各种原因
      
    
    </summary>
    
      <category term="ubuntu" scheme="https://zjrongxiang.github.io/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="https://zjrongxiang.github.io/tags/ubuntu/"/>
    
      <category term="apt" scheme="https://zjrongxiang.github.io/tags/apt/"/>
    
      <category term="mirrors" scheme="https://zjrongxiang.github.io/tags/mirrors/"/>
    
  </entry>
  
  <entry>
    <title>动手实现Ubuntu系统WOL远程唤醒</title>
    <link href="https://zjrongxiang.github.io/2018/03/14/2018-03-14-%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0Ubuntu%E7%B3%BB%E7%BB%9FWOL%E8%BF%9C%E7%A8%8B%E5%94%A4%E9%86%92/"/>
    <id>https://zjrongxiang.github.io/2018/03/14/2018-03-14-动手实现Ubuntu系统WOL远程唤醒/</id>
    <published>2018-03-14T11:30:00.000Z</published>
    <updated>2019-04-25T14:33:00.197Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本篇博客主要介绍通过局域网唤醒服务器（远程启动计算机）。具体在Ubuntu操作系统上实现。具体数据流为：通过互联网远程登录长期开机的树莓派，然后通过树莓派唤醒同一个局域网的高性能服务器。</p><blockquote><p>目前中国家庭宽带网络都是没有外网IP的，如果外网访问家庭网络，需要做端口映射，实现远程访问。</p></blockquote><h4 id="什么是WoL（Wake-on-LAN）"><a href="#什么是WoL（Wake-on-LAN）" class="headerlink" title="什么是WoL（Wake on LAN）"></a>什么是WoL（Wake on LAN）</h4><p>电脑处在关机（或休眠）状态时，只要主机保持连接电源、网线连接网卡，其实网卡和主板仍然有微弱供电。这部分供电能让网卡监听和解读来自外部网络的广播信息。其中会对一种特殊的广播信息Magic Packet（魔法数据包）进行侦测。Magic Packet网络包以广播的形式发送，发送的范围可以是整个局域网或者指定的子网。另外Magic Packet中唤醒服务器IP可以是多个，侦测主机一旦发现包中的唤醒IP集中包含自己的IP，会通知主板、电源供电器，开始执行唤醒，打开机器。</p><h3 id="第一部分-检查主机板块和网卡是否支持Wol"><a href="#第一部分-检查主机板块和网卡是否支持Wol" class="headerlink" title="第一部分 检查主机板块和网卡是否支持Wol"></a>第一部分 检查主机板块和网卡是否支持Wol</h3><ul><li><p>主板是否支持：进入BIOS，将“Power Management Setup”中的“Wake Up On LAN”或“Resume by LAN”项设置为“Enable”或“On”</p></li><li><p>网卡是否支持：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> ethtool enp0s31f6</span><br></pre></td></tr></table></figure><p>其中有下面的字段信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supports Wake-on: pumbg</span><br><span class="line">Wake-on: g</span><br></pre></td></tr></table></figure><h3 id="第二部分-部署步骤"><a href="#第二部分-部署步骤" class="headerlink" title="第二部分 部署步骤"></a>第二部分 部署步骤</h3><h4 id="2-1-方法1"><a href="#2-1-方法1" class="headerlink" title="2.1 方法1"></a>2.1 方法1</h4><p>需要安装wakeonlan包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# sudo apt-get install wakeonlan</span><br></pre></td></tr></table></figure><p>下面的命令通过树莓派发送魔术包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# wakeonlan -i 192.168.1.3 b0:6f:bf:b0:9f:2f</span><br><span class="line">Sending magic packet to 192.168.1.3:9 with b0:6f:b0:bf:9f:2f</span><br></pre></td></tr></table></figure><h4 id="2-2-方法2"><a href="#2-2-方法2" class="headerlink" title="2.2 方法2"></a>2.2 方法2</h4><p>在网关配置ARP信息（IP与物理地址进行绑定），发送网段的广播：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# wakeonlan -i 192.168.1.0 b0:6f:bf:b0:9f:2f</span><br><span class="line">Sending magic packet to 192.168.1.0:9 with b0:6f:b0:bf:9f:2f</span><br></pre></td></tr></table></figure><h3 id="参考文献及链接"><a href="#参考文献及链接" class="headerlink" title="参考文献及链接"></a>参考文献及链接</h3><p>1、WakeOnLan 链接：<a href="https://help.ubuntu.com/community/WakeOnLan" target="_blank" rel="noopener">https://help.ubuntu.com/community/WakeOnLan</a></p><p>2、wiki 链接：<a href="https://en.wikipedia.org/wiki/Wake-on-LAN" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Wake-on-LAN</a></p><p>3、Ubuntu 與 Wake on LAN 链接：<a href="http://softsmith.blogspot.com/2014/05/ubuntu-wake-on-lan.html" target="_blank" rel="noopener">http://softsmith.blogspot.com/2014/05/ubuntu-wake-on-lan.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;本篇博客主要介绍通过局域网唤醒服务器（远程启动计算机）。具体在Ubuntu操作系统上实现。具体数据流为：通过互联网远程登录长期开机的树莓派，
      
    
    </summary>
    
      <category term="ubuntu" scheme="https://zjrongxiang.github.io/categories/ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>树莓派：搭建家庭内网穿透服务器（frp实现）</title>
    <link href="https://zjrongxiang.github.io/2018/03/01/2018-03-12-raspberry_frp/"/>
    <id>https://zjrongxiang.github.io/2018/03/01/2018-03-12-raspberry_frp/</id>
    <published>2018-03-01T11:30:00.000Z</published>
    <updated>2019-01-13T08:05:48.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h3><p>对于目前家庭网络，有下面两个迫切需求：</p><ul><li>需要远程（比如在单位、路途等）SSH访问家里PC服务器、后续实现远程唤醒服务器。</li></ul><ul><li>后续部署自制家庭监控，需要远程访问监控web界面。</li></ul><p>鉴于上面的需求，技术上需要实现外网访问内网（即内网穿透）。下面详细介绍具体实现步骤。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a><strong>环境准备</strong></h3><ul><li><p><strong>一台树莓派主机</strong>。由于耗电较少，适合长期开机，作为中转服务器。</p></li><li><p><strong>一个公网IP</strong>。由于电信宽带不提供公网IP，只能自己想办法。正好有一台外网VPS服务器（独有公网IP）</p></li></ul><blockquote><p>另外顺便打个不收钱的广告：VPS可以使用<a href="https://www.vultr.com/?ref=7252538" target="_blank" rel="noopener">vultr</a>的虚机，支持支付宝，非常方便。</p></blockquote><h3 id="FRP介绍"><a href="#FRP介绍" class="headerlink" title="FRP介绍"></a><strong>FRP介绍</strong></h3><p>实现内网穿透有很多方法：frp软件、ngrok软件、还有花生壳。关于frp有详细的<a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">官方介绍文档</a> ，不再赘述。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a><strong>实现步骤</strong></h3><h4 id="第一步：配置VPS服务器"><a href="#第一步：配置VPS服务器" class="headerlink" title="第一步：配置VPS服务器"></a><strong>第一步：配置VPS服务器</strong></h4><p>VPS操作系统为Ubuntu，下载linux_amd64版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# wget https://github.com/fatedier/frp/releases/download/v0.16.1/frp_0.16.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# tar -zxvf frp_0.16.1_linux_amd64.tar.gz</span><br><span class="line">frp_0.16.1_linux_amd64/</span><br><span class="line">frp_0.16.1_linux_amd64/frpc_full.ini</span><br><span class="line">frp_0.16.1_linux_amd64/LICENSE</span><br><span class="line">frp_0.16.1_linux_amd64/frpc.ini</span><br><span class="line">frp_0.16.1_linux_amd64/frps.ini</span><br><span class="line">frp_0.16.1_linux_amd64/frpc</span><br><span class="line">frp_0.16.1_linux_amd64/frps_full.ini</span><br><span class="line">frp_0.16.1_linux_amd64/frps</span><br><span class="line">root@vultr:~# cd frp_0.16.1_linux_amd64/</span><br><span class="line">root@vultr:~/frp_0.16.1_linux_amd64# ls</span><br><span class="line">frpc  frpc_full.ini  frpc.ini  frps  frps_full.ini  frps.ini  LICENSE</span><br></pre></td></tr></table></figure><p>对于VPS服务端只有两个文件是需要的：<code>frps</code> （服务）和<code>frps.ini</code> （配置文件）是需要的，我们拷贝到<code>/bin</code>目录下面（这一步主要是集中放在bin目录便于管理）。</p><blockquote><p><code>frpc</code> 和<code>frpc.ini</code>是客户端服务和配置文件，后面介绍。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~/frp_0.16.1_linux_amd64# cp frps /bin/frps</span><br><span class="line">root@vultr:~/frp_0.16.1_linux_amd64# cp frps.ini /bin/frps.ini</span><br></pre></td></tr></table></figure><p>然后对配置文件进行修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:/bin# vi frps.ini</span><br><span class="line"><span class="meta">#</span>修改配置文件</span><br><span class="line">[common]</span><br><span class="line">bind_addr = 10.66.2.137</span><br><span class="line"><span class="meta">#</span>VPS公网IP地址（为了保护隐私，上面地址是虚构的）</span><br><span class="line">bind_port = 7000</span><br><span class="line"><span class="meta">#</span>frp服务端口，用户自己定于一个空闲端口（不要和其他应用服务端口冲突）。需要注意的是必须与frpc.ini相同</span><br><span class="line">vhost_http_port = 80</span><br><span class="line"><span class="meta">#</span>http服务端口</span><br><span class="line">vhost_https_port = 443</span><br><span class="line"><span class="meta">#</span>https服务端口</span><br><span class="line">dashboard_port = 7500</span><br><span class="line"><span class="meta">#</span>web控制台端口，10.66.2.137：7500可以访问控制界面</span><br><span class="line"><span class="meta">#</span>下面两个参数是控制界面的用户名和密码</span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = Password123！</span><br><span class="line"></span><br><span class="line">privilege_token = Password123！</span><br><span class="line"><span class="meta">#</span>特权模式密钥，需与frpc.ini相同</span><br><span class="line"></span><br><span class="line">log_file = /bin/frps_log/frps.log</span><br><span class="line"><span class="meta">#</span>日志文件存储路径</span><br><span class="line">log_level = info</span><br><span class="line"><span class="meta">#</span>日志记录级别</span><br><span class="line">log_max_days = 7</span><br><span class="line"><span class="meta">#</span>日志最大存储天数</span><br><span class="line">max_pool_count = 5</span><br><span class="line"><span class="meta">#</span>后端连接池最大连接数量</span><br><span class="line"><span class="meta">#</span>口令超时时间</span><br><span class="line">authentication_timeout = 900</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>subdomain_host = frp.com    #服务端绑定域名</span><br><span class="line">tcp_mux = true</span><br></pre></td></tr></table></figure><p>保存修改后的配置文件，后台启服务端进程，下面是命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:/bin# nohup ./frps -c ./frps.ini &amp;</span><br><span class="line"><span class="meta">#</span>查看服务进程：</span><br><span class="line">root@vultr:/bin# ps -ef|grep frp</span><br><span class="line">root      1339     1  0 Mar25 ?        00:03:54 ./frps -c ./frps.ini</span><br><span class="line">root      5320  4958  0 11:42 pts/1    00:00:00 grep --color=auto frp</span><br></pre></td></tr></table></figure><p>以上完成服务端配置。</p><h4 id="第二步：配置树莓派客户端"><a href="#第二步：配置树莓派客户端" class="headerlink" title="第二步：配置树莓派客户端"></a><strong>第二步：配置树莓派客户端</strong></h4><blockquote><p>注意：树莓派的CPU处理器是ARM的，所以注意下载的版本包。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# wget https://github.com/fatedier/frp/releases/download/v0.16.1/frp_0.16.1_linux_arm.tar.gz</span><br></pre></td></tr></table></figure><p>解压缩下载的包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# tar -zxvf frp_0.16.1_linux_arm.tar.gz </span><br><span class="line">frp_0.16.1_linux_arm/</span><br><span class="line">frp_0.16.1_linux_arm/frpc_full.ini</span><br><span class="line">frp_0.16.1_linux_arm/LICENSE</span><br><span class="line">frp_0.16.1_linux_arm/frpc.ini</span><br><span class="line">frp_0.16.1_linux_arm/frps.ini</span><br><span class="line">frp_0.16.1_linux_arm/frpc</span><br><span class="line">frp_0.16.1_linux_arm/frps_full.ini</span><br><span class="line">frp_0.16.1_linux_arm/frps</span><br><span class="line">root@raspberrypi:~# cd frp_0.16.1_linux_arm</span><br><span class="line">root@raspberrypi:~/frp_0.16.1_linux_arm# ls</span><br><span class="line">frpc  frpc_full.ini  frpc.ini  frps  frps_full.ini  frps.ini  LICENSE</span><br></pre></td></tr></table></figure><p>类似服务端操作将<code>frpc</code>和<code>frpc.ini</code>拷贝到<code>/bin</code>目录下面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~/frp_0.16.1_linux_arm# cp frpc /bin/frpc</span><br><span class="line">root@raspberrypi:~/frp_0.16.1_linux_arm# cp frpc.ini /bin/frpc.ini</span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/bin# vi frpc.ini</span><br><span class="line"><span class="meta">#</span>修改客户端配置文件</span><br><span class="line">[common]</span><br><span class="line">server_addr = 10.66.2.137</span><br><span class="line"><span class="meta">#</span>VPS公网IP地址（为了保护隐私，上面地址是虚构的）</span><br><span class="line">server_port = 7000</span><br><span class="line">privilege_token = Password123！</span><br><span class="line"></span><br><span class="line">log_file = /bin/frpc.log</span><br><span class="line"><span class="meta">#</span>日志目录</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 7</span><br><span class="line">pool_count = 5</span><br><span class="line">tcp_mux = true</span><br><span class="line"><span class="meta">#</span>配置SSH端口映射</span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line"><span class="meta">#</span>本地端口</span><br><span class="line">local_port = 22</span><br><span class="line"><span class="meta">#</span>映射端口</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 80</span><br><span class="line">use_encryption = false</span><br><span class="line">use_compression = true</span><br><span class="line">subdomain = web</span><br><span class="line"><span class="meta">#</span>所绑定的公网服务器域名，一级、二级域名都可以。这里没有就不用配置了</span><br><span class="line">custom_domains = web.frp.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>远程监控端口映射</span><br><span class="line">[motion]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 8082</span><br><span class="line">remote_port = 8000</span><br></pre></td></tr></table></figure><p>保存修改，后台启客户端进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/bin# nohup ./frpc -c ./frpc.ini &amp;</span><br><span class="line">root@raspberrypi:/bin# ps -ef|grep frp</span><br><span class="line">root      4627     1  0 4月02 ?       00:05:19 ./frpc -c ./frpc.ini</span><br><span class="line">root     13731 13669  0 19:56 pts/0    00:00:00 grep frp</span><br></pre></td></tr></table></figure><h4 id="第三步：验证"><a href="#第三步：验证" class="headerlink" title="第三步：验证"></a><strong>第三步：验证</strong></h4><h5 id="FRP管理界面（http-公网IP-7500）"><a href="#FRP管理界面（http-公网IP-7500）" class="headerlink" title="FRP管理界面（http://公网IP:7500）"></a><strong>FRP管理界面（http://公网IP:7500）</strong></h5><p>显示两个端口映射都是online可用的：</p><p><img src="\images\picture\frp1.png" alt=""></p><p>下面是整体视图：</p><p><img src="\images\picture\frp2.png" alt=""></p><h5 id="SSH服务"><a href="#SSH服务" class="headerlink" title="SSH服务"></a><strong>SSH服务</strong></h5><p>我们已经将本地访问ssh的服务端口（192.168.1.2：22）映射到外网端口（10.66.2.137：6000）。</p><p>例如使用putty工具，IP地址填写：10.66.2.137，端口：6000。</p><p>连接后使用树莓派本地ssh用户和密码即可登录。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h3><p>[1]  FRP官方网站 <a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;对于目前家庭网络，有下面两个迫切需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要远程（比如在单位、路途等）SSH访问
      
    
    </summary>
    
      <category term="raspberry" scheme="https://zjrongxiang.github.io/categories/raspberry/"/>
    
    
      <category term="raspberry" scheme="https://zjrongxiang.github.io/tags/raspberry/"/>
    
      <category term="frp" scheme="https://zjrongxiang.github.io/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>树莓派：更改APT为国内源</title>
    <link href="https://zjrongxiang.github.io/2018/03/01/2018-03-12-raspberry_apt-get/"/>
    <id>https://zjrongxiang.github.io/2018/03/01/2018-03-12-raspberry_apt-get/</id>
    <published>2018-03-01T11:30:00.000Z</published>
    <updated>2018-04-05T13:47:23.086Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>发现树莓派wget国外源异常慢。其实可以更改为国内的apt源，不用走海下光缆啦。</p><h3 id="更改步骤"><a href="#更改步骤" class="headerlink" title="更改步骤"></a>更改步骤</h3><h4 id="编辑sources-list文件"><a href="#编辑sources-list文件" class="headerlink" title="编辑sources.list文件"></a>编辑sources.list文件</h4><p>还没安装我喜爱的vim，只能先用nano编辑文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# nano /etc/apt/sources.list</span><br></pre></td></tr></table></figure><h4 id="修改源"><a href="#修改源" class="headerlink" title="修改源"></a>修改源</h4><p>将原始的源注释掉，添加阿里云的源地址（在这里感谢阿里爸爸）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contrib rpi</span><br><span class="line">deb-src http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contrib rpi</span><br></pre></td></tr></table></figure><h4 id="更软件索引清单"><a href="#更软件索引清单" class="headerlink" title="更软件索引清单"></a>更软件索引清单</h4><p>最后更新一下，以后就可以快速apt-get啦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;发现树莓派wget国外源异常慢。其实可以更改为国内的apt源，不用走海下光缆啦。&lt;/p&gt;
&lt;h3 id=&quot;更改步骤&quot;&gt;&lt;a href=&quot;#更
      
    
    </summary>
    
      <category term="raspberry" scheme="https://zjrongxiang.github.io/categories/raspberry/"/>
    
    
      <category term="raspberry" scheme="https://zjrongxiang.github.io/tags/raspberry/"/>
    
      <category term="apt-get" scheme="https://zjrongxiang.github.io/tags/apt-get/"/>
    
  </entry>
  
</feed>
