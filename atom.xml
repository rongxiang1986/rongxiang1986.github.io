<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RongXiang</title>
  
  <subtitle>我的烂笔头</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zjrongxiang.github.io/"/>
  <updated>2019-01-13T09:47:48.188Z</updated>
  <id>https://zjrongxiang.github.io/</id>
  
  <author>
    <name>rong xiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>5分钟介绍深度学习（科普）</title>
    <link href="https://zjrongxiang.github.io/2018/04/16/2018-04-15-network_intro/"/>
    <id>https://zjrongxiang.github.io/2018/04/16/2018-04-15-network_intro/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2019-01-13T09:47:48.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h3><p>最近几年Deep Learning、AI人工智能、机器学习等名词称为新闻热点，特别是Google Deep mind的Alpha Go战胜韩国棋手李世石，让深度学习妇孺皆知。</p><p>首先从概念范畴上讲，deep learning属于机器学习的一个分支，追根溯源其实是人工神经网络。顾名思义，人工神经网络是借鉴人类神经网路的结构原型，算生物仿生学（虽然人类到现在也没弄明白大脑原理）。</p><p><img src="http://images.gitbook.cn/30cf7530-b6ce-11e7-8181-ddae1c526ae3" style="zoom:100%"></p><p>例如下面就是一个3层结构的人工神经网络（1个输入层、1个隐藏层、1个输出层）。</p><p><img src="http://images0.cnblogs.com/blog2015/680781/201508/021735264703915.png" style="zoom:70%"></p><p>1989年Yann LeCun使用反向传播算法（Back Propagation）应用于多层神经网络训练。但一旦层数较大，网络的参数和训练计算量成倍增加，通常需要几周时间才能完成参数训练，另外反向传播算法容易梯度爆炸。研究人员获得好的结果，时间成本太大。</p><p>所以当时机器学习研究方向中，支持向量机（SVM）算法比多层神经网络更为热门，神经网络研究则相当冷门。</p><p>直到2012 年的ImageNet 图像分类竞赛中，Alex Krizhevsky使用CNN（卷积）多层网络（共8层、6千万个参数）赢得当年的比赛，领先第二名10.8个百分点。并且模型使用GPU芯片训练、引入正则技术（Dropout）。</p><p>从此多层神经网络成为机器学习中的研究热点。而为了“洗白”以前暗淡历史，被赋予了新的名称：Deep Learning。</p><h3 id="深度学习背后的数学"><a href="#深度学习背后的数学" class="headerlink" title="深度学习背后的数学"></a>深度学习背后的数学</h3><p>目前的人工智能均属于弱人工智能（不具备心智和意识）。事实上，深度学习目前主要在图像识别和声音识别场景中获得较好的效果。深度学习的成为热点，依赖于两方面条件的成熟:</p><ul><li>算力的提升，训练中大量使用GPU。</li><li>大量数据的获得和沉淀。</li></ul><p>弱人工智能背后的理论基础依赖于数学和统计理论，其实更应该算数据科学的范畴。</p><p>比如输入数据具有$m$维特征，而输出特征为$k$维（例如如果是个二分类问题，$k=2$）。我们使用3层神经网络（输入层为$m$维，即含有$m$个神经元；隐藏层为$n$维，输出层为$k$维）用来训练。</p><p>通常我们将输入数据看成$R^m$（$m$维欧几里得空间），输出数据看成$R^k$（$k$维欧式空间）,如下图：</p><p><img src="\images\picture\bpnnfigure.png" alt=""></p><p>从数学上看，神经网络的结构定义了一个函数空间：${R^{n}} \xrightarrow{\text{f}} {R^{h}}  \xrightarrow{\text{g}} {R^{m}}$ 。这个函数空间中元素是非线性的（隐藏层和输出层有非线性的激活函数）。空间中每个函数由网络中的参数（w，b）唯一决定。</p><p>神经网络训练的过程可以形象的理解为寻找最佳函数的过程：输入层“吃进”大量训练数据，通过非线性函数的作用，观察输出层输出结果和实际值的差异。这是一个监督学习的过程。</p><ul><li>如果差异（误差）在容忍范围内，停止训练，认为该函数是目标函数。</li><li>如果差异较大，反向传播算法根据梯度下降的反向更新网络中的参数（w，b），即挑选新的函数。</li><li>重新喂进数据，计算新挑选函数的误差。如此循环，直到找到目标函数（也可设置提前结束训练）。</li></ul><blockquote><p>为什么神经网络的发展最后偏向的是“深度”呢？即增加层数来提高网络的认知能力。为什么没有“宽度学习”？即增加网络隐藏层的维度（宽度）。</p><p>其实从数学上可以证明深度网络和“宽度网络”的等价性。证明提示：考虑网络定义的函数空间出发。</p></blockquote><h3 id="写在最后（畅想未来）"><a href="#写在最后（畅想未来）" class="headerlink" title="写在最后（畅想未来）"></a>写在最后（畅想未来）</h3><h4 id="深度学习的局限性思考"><a href="#深度学习的局限性思考" class="headerlink" title="深度学习的局限性思考"></a>深度学习的局限性思考</h4><p>目前深度学习被各行各业应用于各种场景，而且有些特定场景取得了良好结果。但是传统的深度学习仍属于监督学习，更像一个被动的执行者，按照人类既定的规则，吃进海量数据，然后训练。</p><p>那么深度网络是否真的理解和学到了模式？还是只学会对有限数据的模式识别？甚至就是一个庞大的记忆网络？这都是值得我们深度思考的。</p><h4 id="GAN对抗网络"><a href="#GAN对抗网络" class="headerlink" title="GAN对抗网络"></a>GAN对抗网络</h4><p>那么怎么能说明模型真的学习并理解了。我们提出了一个原则：如果你理解了一个事物，那么你就可以创造它。这样就发明了GAN对抗网络。让网络自己去创造事物，然后用现实数据去监督，当网络的创造能力和现实接近时，我们认为网络学会了。</p><blockquote><p>其实思想类似传统的遗传算法。</p></blockquote><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><p>另外传统的深度学习，输入的环境（数据）是固定的。然而现实中我们学习过程其实是：环境（数据）与学习个体互相作用的交互过程。这个学习过程人类由于时间有限，是个漫长的过程。但是计算机有个天然优势，可以同时启用成千上万的学习个体完成与环境数据的交互学习过程。例如Alpha Go启用上万个体，两两互搏，配上强大算力，短时间完成学习，这是人类不可企及的。</p><h4 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h4><p>人类学习中还有个方法叫：触类旁通。其实就是不同场景训练模型的借鉴。例如A场景得到训练好的模型（网络参数），对于新的场景B，可以尝试直接用A场景的网络（或部分使用，拼接），以此来减少训练成本。</p><p>那么新的问题来了：是否具有统一的迁移标准，即什么模型是适合迁移的？如果这些问题没有理论基础支持，迁移学习也摆脱不了“炼丹术”的非议。</p><p><strong>深度学习从过去的暗淡无色到现在的光耀夺目。</strong></p><p><strong>然而任何方法都是有边际效应的。</strong></p><p><strong>人工智能的终点还很遥远，谁是下一颗耀眼的明星，需要学界和工业界共同探索。</strong></p><p>​                                                                                                                          </p><p>​                                                                                                                                  2018年4月15日 夜</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;历史背景&quot;&gt;&lt;a href=&quot;#历史背景&quot; class=&quot;headerlink&quot; title=&quot;历史背景&quot;&gt;&lt;/a&gt;历史背景&lt;/h3&gt;&lt;p&gt;最近几年Deep Learning、AI人工智能、机器学习等名词称为新闻热点，特别是Google Deep mind的Alp
      
    
    </summary>
    
      <category term="network" scheme="https://zjrongxiang.github.io/categories/network/"/>
    
    
      <category term="BP， network" scheme="https://zjrongxiang.github.io/tags/BP%EF%BC%8C-network/"/>
    
  </entry>
  
  <entry>
    <title>计算机语言中编译和解释的总结</title>
    <link href="https://zjrongxiang.github.io/2018/04/14/2018-04-14-interprete_and_compile/"/>
    <id>https://zjrongxiang.github.io/2018/04/14/2018-04-14-interprete_and_compile/</id>
    <published>2018-04-14T08:30:00.000Z</published>
    <updated>2018-04-15T03:25:43.418Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>非计算机科班，主要是总结给自己看的，如果有表达错误，请大家指正。</p></blockquote><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><h4 id="高级语言与低级语言"><a href="#高级语言与低级语言" class="headerlink" title="高级语言与低级语言"></a>高级语言与低级语言</h4><p>高级语言（High Level Programming Language）和低级语言（Low Level Programming Language）是一对相对的共生概念（没有一个严格的量化区分标准）。</p><ul><li>低级语言更接近计算机底层资源（直接与硬件资源进行交互）。例如汇编语言。</li><li>高级语言进行了封装和抽象，语言设计更容易被人类思维逻辑所理解（和低级语言比较，学习曲线较缓）。例如C、C++、java、python等。</li></ul><p>随着计算机语言的蓬勃发展（计算机语言的文艺复兴），过去一些高级语言，也有人重新定位成低级语言，例如C语言。</p><h4 id="字节码与机器码"><a href="#字节码与机器码" class="headerlink" title="字节码与机器码"></a>字节码与机器码</h4><p>字节码（Byte Code）不是一种计算机语言。属于高级语言预编译生成的中间码。高级语言源码在预编译的过程中，就完成这部分工作，生成字节码。</p><p>机器码（Machine Code）是一组可以直接被CPU执行的指令集。所有语言（低级和高级）最后都需要编译或解释成机器码（CPU指令集），才能执行。</p><h3 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h3><h4 id="编译器（Interpreter）"><a href="#编译器（Interpreter）" class="headerlink" title="编译器（Interpreter）"></a>编译器（Interpreter）</h4><blockquote><p>A compiler is a computer program (or a set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language), with the latter often having a binary form known as object code. The most common reason for converting source code is to create an executable program.</p></blockquote><ul><li>编译器是一种计算机程序。</li><li>编译器是一个计算机语言的翻译工具，直接将源代码文件预编译（形象的说：翻译）成更低级的代码语言（字节码码、机器码）。</li><li>编译器不会去执行编译的结果，只生成编译的结果文件。</li></ul><h4 id="解释器（Compiler）"><a href="#解释器（Compiler）" class="headerlink" title="解释器（Compiler）"></a>解释器（Compiler）</h4><blockquote><p>In computer science, an interpreter is a computer program that directly executes, i.e. performs, instructions written in a programming or scripting language, without previously compiling them into a machine language program. An interpreter generally uses one of the following strategies for program execution:</p><p>1、parse the source code and perform its behavior directly.</p><p>2、translate source code into some efficient intermediate representation and immediately execute this.</p><p>3、explicitly execute stored precompiled code made by a compiler which is part of the interpreter system.</p></blockquote><ul><li>解释器是一种计算机程序。</li><li>解释器读取源代码或者中间码文件，转换成机器码并与计算机硬件交互。即逐行执行源码。</li><li>解释器会将源代码转换成一种中间代码不会输出更低级的编译结果文件。输出执行结果。</li></ul><p><img src="\images\picture\compiler.jpg" alt="网上有一张很形象的图"></p><h3 id="解释型语言和编译型语言"><a href="#解释型语言和编译型语言" class="headerlink" title="解释型语言和编译型语言"></a>解释型语言和编译型语言</h3><p>两者的区别主要是源码编译时间的差异。相同点都要翻译成机器码后由计算机执行。</p><h4 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h4><ul><li>编译语言的源码文件需要提前通过编译器编译成机器码文件（比如win中的exe可执行文件）。</li><li>执行时，只需执行编译结果文件。不需要重复翻译。</li><li>这类语言有：C、C++、Fortran、Pascal等。</li></ul><h4 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h4><ul><li>解释型语言在运行时进行翻译。比如VB语言，在执行的时候，解释器将语言翻译成机器码，然后执行。</li><li>这类语言有：Ruby、Perl、JavaScript、PHP等。</li></ul><h4 id="混合型语言"><a href="#混合型语言" class="headerlink" title="混合型语言"></a>混合型语言</h4><p>但是随着计算机语言的发展，有些语言兼具两者的特点。</p><ul><li><strong>JAVA语言</strong></li></ul><p>JAVA编译过程只是将<code>.java</code>文件翻译成字节码（Byte Code）（<code>.class</code>文件）。字节码文件交由java虚拟机（JVM）解释运行。也就是说Java源码文件既要编译也要JVM虚拟机进行解释后运行。所以有种说法认为Java是半解释型语言（semi-interpreted” language）。</p><ul><li><strong>Python语言</strong></li></ul><p>python其实类似Java。例如一个python文件<code>test.py</code> ，解释器首先尝试读取该文件历史编译结果（pyc文件）即<code>test.pyc</code>文件或者<code>test.pyo</code> 。如果没有历史文件或者编译文件的日期较旧（即py文件可能有更新），解释器会重新编译生成字节码文件（pyc文件），然后Python虚拟机对字节码解释执行。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>【1】 <a href="http://huang-jerryc.com/2016/11/20/do-you-konw-the-different-between-compiler-and-interpreter/" target="_blank" rel="noopener">你知道「编译」与「解释」的区别吗？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;非计算机科班，主要是总结给自己看的，如果有表达错误，请大家指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;几个概念&quot;&gt;&lt;a href=&quot;#几个概念&quot; class=&quot;headerlink&quot; title=&quot;几个概念&quot;&gt;&lt;/a&gt;几个概念&lt;/h
      
    
    </summary>
    
      <category term="python" scheme="https://zjrongxiang.github.io/categories/python/"/>
    
    
      <category term="interpreter， compiler" scheme="https://zjrongxiang.github.io/tags/interpreter%EF%BC%8C-compiler/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Python语言中import机制</title>
    <link href="https://zjrongxiang.github.io/2018/04/14/2018-04-14-python_import/"/>
    <id>https://zjrongxiang.github.io/2018/04/14/2018-04-14-python_import/</id>
    <published>2018-04-14T02:30:00.000Z</published>
    <updated>2018-04-15T07:58:12.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="包和模块"><a href="#包和模块" class="headerlink" title="包和模块"></a>包和模块</h3><p>首先要介绍Python中两个概念：包和模块。简单的理解（从文件系统角度），包（package）是一个文件夹，而模块（module）是一个python源码文件（扩展名为<code>.py</code>）。</p><ul><li><p><strong>包（package）</strong>：文件夹（文件夹中含有文件<code>__init__.py</code>），包里面含有很多模块组成。</p><blockquote><p><code>__init__.py</code>文件，在里面自定义初始化操作，或为空。</p></blockquote></li><li><p><strong>模块（module）</strong>：即python文件，文件中定义了函数、变量、常量、类等。</p></li></ul><h3 id="Import-方法"><a href="#Import-方法" class="headerlink" title="Import 方法"></a>Import 方法</h3><h4 id="Import-模块方法"><a href="#Import-模块方法" class="headerlink" title="Import 模块方法"></a>Import 模块方法</h4><p>先看一个例子。我们经常使用的模块<code>math</code> ，背后对应其实是一个python文件：<code>math.py</code> 。该文件在<code>C:\Anaconda3\Lib\site-packages\pymc3</code>目录里面（具体环境会有差异）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">math.sqrt(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#1.4142135623730951</span></span><br></pre></td></tr></table></figure><p>如果只要import <code>math.py</code>中具体的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from math import sqrt，sin</span><br><span class="line">sqrt(2)</span><br><span class="line">sin（1）</span><br></pre></td></tr></table></figure><p>另外可以将模块中所有内容导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from math import *</span><br><span class="line">sqrt(2)</span><br></pre></td></tr></table></figure><h4 id="Import-包方法"><a href="#Import-包方法" class="headerlink" title="Import 包方法"></a>Import 包方法</h4><p>包（package）可以简单理解为文件夹。该文件夹下须存在 <code>__init__.py</code> 文件, 内容可以为空。另外该主文件夹下面可以有子文件夹，如果也有 <code>__init__.py</code> 文件，这是子包。类似依次嵌套。</p><p>例如<code>Tensorflow</code>的包（文件树）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~/anaconda3/lib/python3.6/site-packages/tensorflow# tree -L 1</span><br><span class="line">.</span><br><span class="line">├── aux-bin</span><br><span class="line">├── contrib</span><br><span class="line">├── core</span><br><span class="line">├── examples</span><br><span class="line">├── include</span><br><span class="line">├── __init__.py</span><br><span class="line">├── libtensorflow_framework.so</span><br><span class="line">├── __pycache__</span><br><span class="line">├── python</span><br><span class="line">└── tools</span><br></pre></td></tr></table></figure><blockquote><p> <code>__init__.py</code> 文件在import包时，优先导入，作为import包的初始化。</p></blockquote><p>我们以<code>Tensorflow</code>为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入包</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment">#导入子包：contrib</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.contrib <span class="keyword">as</span> contrib</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> contrib</span><br><span class="line"><span class="comment">#导入具体的模块：mnist</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">import</span> tensorflow.examples.tutorials.mnist</span><br></pre></td></tr></table></figure><h3 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h3><p>Namespace是字典数据，供编译器、解释器对源代码中函数名、变量名、模块名等信息进行关联检索。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Python语言使用namespace（命名空间）来存储变量，namespace是一个mapping（映射）。namespace可以理解是一个字典（dict）数据类型，其中键名（key）为变量名，而键值（value）为变量的值。</p><blockquote><p>A <em>namespace</em> is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries。</p></blockquote><ul><li><strong>每一个函数拥有自己的namespace。</strong>称为local namespace（局部命名空间），记录函数的变量。</li><li><strong>每一个模块（module）拥有自己的namespace</strong>。称为global namespace（全局命名空间），记录模块的变量，包括包括模块中的函数、类，其他import（导入）的模块，还有模块级别的变量和常量。</li><li><strong>每一个包（package）拥有自己的namespace。</strong> 也是global namespace ，记录包中所有子包、模块的变量信息。</li><li><strong>Python的built-in names（内置函数、内置常量、内置类型）。</strong> 即内置命名空间。在Python解释器启动时创建，任何模块都可以访问。当退出解释器后删除。</li></ul><h4 id="命名空间的检索顺序"><a href="#命名空间的检索顺序" class="headerlink" title="命名空间的检索顺序"></a>命名空间的检索顺序</h4><p>当代码中需要访问或获取变量时（还有模块名、函数名），Python解释器会对命名空间进行顺序检索，直到根据键名（变量名）找到键值（变量值）。查找的顺序为（LEGB）：</p><ol><li>local namespace，即当前函数或者当前类。如找到，停止检索。</li><li>enclosing function namespace，嵌套函数中外部函数的namespace。</li><li>global namespace，即当前模块。如找到，停止检索。</li><li>build-in namespace，即内置命名空间。如果前面两次检索均为找到，解释器才会最后检索内置命名空间。如果仍然未找到就会报NameRrror（类似：<code>NameError: name &#39;a&#39; is not defined</code>）。</li></ol><h4 id="举栗子"><a href="#举栗子" class="headerlink" title="举栗子"></a>举栗子</h4><p>讲完了理论介绍，我们来举栗子，直观感受一下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>进入python环境</span><br><span class="line">Python 3.5.3 |Anaconda custom (64-bit)| (default, May 11 2017, 13:52:01) [MSC v.</span><br><span class="line">1900 64 bit (AMD64)] on win32</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; print(globals())</span><br><span class="line">&#123;'__name__': '__main__', '__doc__': None, '__spec__': None, '__package__': None,</span><br><span class="line"> '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__builtins__': &lt;mod</span><br><span class="line">ule 'builtins' (built-in)&gt;&#125;</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; x=1</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; print(globals())</span><br><span class="line">&#123;'__name__': '__main__', '__doc__': None, '__spec__': None, '__package__': None,</span><br><span class="line"> '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__builtins__': &lt;mod</span><br><span class="line">ule 'builtins' (built-in)&gt;, 'x': 1&#125;</span><br></pre></td></tr></table></figure><p>上面的例子我们查看了global namespace的字典（dict），其中<code>&#39;__builtins__&#39;</code>就是内置命名空间。新建变量<code>x=1</code>后，全局命名空间会新增这个K-V对。</p><p>还可以通过下面的方法查看import模块、包的namespace。</p><p><strong>当我们import一个module（模块）或者package（包）时，伴随着新建一个global namespace（全局命名空间）。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">math.__dict__</span><br><span class="line">&#123;'__name__': 'math', 'tanh': &lt;built-in function tanh&gt;, 'nan': nan, 'atanh': &lt;bui</span><br><span class="line">lt-in function atanh&gt;,'acosh': &lt;built-in function acosh&gt;, </span><br><span class="line"><span class="meta">#</span>中间略</span><br><span class="line">'trunc': &lt;built-in function trunc&gt;, 'acos': &lt;built-in function acos&gt;, 'sqrt': &lt;built-in</span><br><span class="line"> function sqrt&gt;, 'floor': &lt;built-in function floor&gt;, 'gamma': &lt;built-in function</span><br><span class="line"><span class="meta"> gamma&gt;</span>, 'cosh': &lt;built-in function cosh&gt;&#125;</span><br><span class="line">import tensorflow</span><br><span class="line">tensorflow.__dict__</span><br><span class="line"><span class="meta">#</span>包的所有模块、函数等命名空间信息。大家可以试一下。</span><br></pre></td></tr></table></figure><p>大家可以动手试试其他的场景，比如函数内部查看locals() 。函数内部的变量global声明后，查看globals()字典会有怎样变化。这里就不再一一验证举栗了。</p><p>对于包，我们以tensorflow为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow</span><br><span class="line">tensorflow.__dict__</span><br><span class="line"><span class="comment">##中间略，只摘取部分信息。命名空间中包含module和function的信息。</span></span><br><span class="line"><span class="string">'angle'</span>: &lt;function tensorflow.python.ops.math_ops.angle&gt;,</span><br><span class="line"> <span class="string">'app'</span>: &lt;module <span class="string">'tensorflow.python.platform.app'</span> <span class="keyword">from</span> <span class="string">'/root/anaconda3/lib/python3.6/site-packages/tensorflow/python/platform/app.py'</span>&gt;,</span><br><span class="line"> <span class="string">'arg_max'</span>: &lt;function tensorflow.python.ops.gen_math_ops.arg_max&gt;,</span><br></pre></td></tr></table></figure><h3 id="Import的过程"><a href="#Import的过程" class="headerlink" title="Import的过程"></a>Import的过程</h3><p>当我们执行import 模块、包时，主要有三个过程：检索、加载、名字绑定。</p><h4 id="第一步：检索（Finder）"><a href="#第一步：检索（Finder）" class="headerlink" title="第一步：检索（Finder）"></a>第一步：检索（Finder）</h4><p>Python解释器会对模块所属位置进行搜索：</p><h5 id="（1）检索：内置模块（已经加载到缓存中的模块）"><a href="#（1）检索：内置模块（已经加载到缓存中的模块）" class="headerlink" title="（1）检索：内置模块（已经加载到缓存中的模块）"></a>（1）检索：内置模块（已经加载到缓存中的模块）</h5><p>内置模块（已经加载到缓存中的模块），即在 <code>sys.modules</code> 中检索。Python已经加载到内存中的模块均会在这个字典中进行登记。如果已经登记，不再重复加载。直接将模块的名字加入正在import的模块的namespace。可以通过下面方法查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt; import sys</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; print(sys.modules)</span><br><span class="line">&#123;'_signal': &lt;module '_signal' (built-in)&gt;, 'os.path': &lt;module 'ntpath' from 'C:</span><br><span class="line">\Anaconda3\\lib\\ntpath.py'&gt;,pickle': &lt;module 'pickle' from 'C:\\Anaconda3\\lib\\pickle.py'&gt;, </span><br><span class="line"><span class="meta">#</span>中间略</span><br><span class="line">'subprocess':module 'subprocess' from 'C:\\Anaconda3\\lib\\subprocess.py'&gt;, 'sys': &lt;module '</span><br><span class="line">ys' (built-in)&gt;, 'ctypes.util': &lt;module 'ctypes.util' from 'C:\\Anaconda3\\lib\</span><br><span class="line">ctypes\\util.py'&gt;, '_weakref': &lt;module '_weakref' (built-in)&gt;, '_imp': &lt;module</span><br><span class="line">_imp' (built-in)&gt;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果不是built-in，value中会有模块的绝对路径信息。</p><p>通过key查找模块位置，如果value为None，就会抛出错误信息：ModuleNotFoundError。</p><p>如果key不存在，就会进入下一步检索。</p></blockquote><p>如果我们导入过包，例如tensorflow。</p><p>注意如果要使用其中模块，需要该模块的全名（即全路径信息），例如：<code>tensorflow.examples.tutorials.mnist.input_data</code> 。因为sys.modules中只有全路径的key。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow</span><br><span class="line">print(sys.modules)</span><br><span class="line"><span class="comment">##这个字典中会有tensorflow所有子包、模块的信息和具体的路径。</span></span><br><span class="line"><span class="comment">#'tensorflow.examples.tutorials.mnist.input_data': &lt;module 'tensorflow.examples.tutorials.mnist.input_data' from '/root/anaconda3/lib/python3.6/site-packages/tensorflow/examples/tutorials/mnist/input_data.py'&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（2）检索-sys-meta-path"><a href="#（2）检索-sys-meta-path" class="headerlink" title="（2）检索 sys.meta_path"></a>（2）检索 <a href="http://docs.python.org/2/library/sys.html#sys.meta_path" target="_blank" rel="noopener">sys.meta_path</a></h5><p>逐个遍历其中的 <a href="http://docs.python.org/2/glossary.html#term-finder" target="_blank" rel="noopener">finder</a> 来查找模块。否则进入下一步检索。</p><h5 id="（3）检索模块所属包目录"><a href="#（3）检索模块所属包目录" class="headerlink" title="（3）检索模块所属包目录"></a>（3）检索模块所属包目录</h5><p>如果模块Module在包（Package）中（如<code>import Package.Module</code>），则以<code>Package.__path__</code>为搜索路径进行查找。</p><p><strong>（4）检索环境变量</strong></p><p>如果模块不在一个包中（如<code>import Module</code>），则以 <a href="http://docs.python.org/2/library/sys.html#sys.path" target="_blank" rel="noopener">sys.path</a> 为搜索路径进行查找。</p><blockquote><p>如果上面检索均为找到，抛出错误信息：ModuleNotFoundError。</p></blockquote><h4 id="第二步：加载（Loader）"><a href="#第二步：加载（Loader）" class="headerlink" title="第二步：加载（Loader）"></a>第二步：加载（Loader）</h4><p>加载完成对模块的初始化处理：</p><ul><li>设置属性。包括<code>__name__</code>、<code>__file__</code>、<code>__package__</code>和<code>__loader__</code> 。</li></ul><ul><li>编译源码。编译生成字节码文件（<code>.pyc</code>文件），如果是包，则是其对应的<code>__init__.py</code>文件编译为字节码（*.pyc）。如果字节码文件已存在且仍然是最新的（时间戳和py文件一致），则不会重新编译。</li></ul><ul><li>加载到内存。模块在第一次被加载时被编译，载入内存，并将信息加入到sys.modules中。</li></ul><blockquote><p>也可以强制用<code>reload()</code>函数重新加载模块（包）。</p></blockquote><h4 id="第三步：名字绑定"><a href="#第三步：名字绑定" class="headerlink" title="第三步：名字绑定"></a>第三步：名字绑定</h4><p>将模块和包的命名空间信息导入到当前执行Python文件的namespace（命名空间）。</p><h3 id="将模块、包的路径加入检索路径"><a href="#将模块、包的路径加入检索路径" class="headerlink" title="将模块、包的路径加入检索路径"></a>将模块、包的路径加入检索路径</h3><p>讲完了枯燥的理论背景，下面我们来介绍实际应用。当你写好一个模块文件，如何正确完成import模块？主要有下面两类方法：</p><h4 id="动态方法（sys-path中添加）"><a href="#动态方法（sys-path中添加）" class="headerlink" title="动态方法（sys.path中添加）"></a>动态方法（sys.path中添加）</h4><p>我们知道检索路径中sys.path，所以可以在import模块之前将模块的绝对路径添加到sys.path中。同样导入包需要加入包的文件夹绝对路径。具体方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">##sys.path.append(dir)</span></span><br><span class="line">sys.path.append(<span class="string">'your\module（package）\file\path'</span>)</span><br><span class="line"><span class="comment">##sys.path.insert(pos,dir)</span></span><br><span class="line">sys.path.insert(<span class="number">0</span>,<span class="string">'your\module（package）\file\path'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>1、这里pos参数是插入sys.path这个list数据的位置，pos=0，即list第一位，优先级高。</p><p>2、python程序向sys.path添加的目录只在此程序的生命周期之内有效。程序结束，失效。所以这是一种动态方法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#win7</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.path)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">[<span class="string">''</span>, <span class="string">'C:\\Python27\\lib\\site-packages\\pip-8.1.1-py2.7.egg'</span>, <span class="string">'C:\\windows\\syst</span></span><br><span class="line"><span class="string">em32\\python27.zip'</span>, <span class="string">'C:\\Python27\\DLLs'</span>, <span class="string">'C:\\Python27\\lib'</span>, <span class="string">'C:\\Python27\\l</span></span><br><span class="line"><span class="string">ib\\plat-win'</span>, <span class="string">'C:\\Python27\\lib\\lib-tk'</span>, <span class="string">'C:\\Python27'</span>, <span class="string">'C:\\Users\\rongxian</span></span><br><span class="line"><span class="string">g\\AppData\\Roaming\\Python\\Python27\\site-packages'</span>, <span class="string">'C:\\Python27\\lib\\site-</span></span><br><span class="line"><span class="string">packages'</span>]</span><br></pre></td></tr></table></figure><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>（1）另外检索路径还有系统环境变量，所以可以将模块（包）路径添加在系统环境变量中。</p><p>（2）粗暴一点直接将模块（包）拷贝到sys.path的其中一个路径下面。但是这种管理比较乱。</p><p>（3）Python在遍历sys.path的目录过程中，会解析 <code>.pth</code> 文件，将文件中所记录的路径加入到 sys.path ，这样 .pth 文件中的路径也可以找到了。例如我们在<code>C:\Python27\lib\site-packages</code> 中新建一个<code>.pth</code>文件。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .pth file for the your module or package</span></span><br><span class="line"><span class="string">'your\module（package）\file\path'</span></span><br></pre></td></tr></table></figure><p>这样在模块（包）上线时，我们只需要将模块（包）的目录或者文件绝对路径放在新建的.path文件中即可。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>【1】<a href="http://www.cnblogs.com/russellluo/p/3328683.html#_3" target="_blank" rel="noopener">http://www.cnblogs.com/russellluo/p/3328683.html#_3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;包和模块&quot;&gt;&lt;a href=&quot;#包和模块&quot; class=&quot;headerlink&quot; title=&quot;包和模块&quot;&gt;&lt;/a&gt;包和模块&lt;/h3&gt;&lt;p&gt;首先要介绍Python中两个概念：包和模块。简单的理解（从文件系统角度），包（package）是一个文件夹，而模块（modu
      
    
    </summary>
    
      <category term="python" scheme="https://zjrongxiang.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://zjrongxiang.github.io/tags/python/"/>
    
      <category term="import" scheme="https://zjrongxiang.github.io/tags/import/"/>
    
  </entry>
  
  <entry>
    <title>数据科学实践中常用开放数据集介绍</title>
    <link href="https://zjrongxiang.github.io/2018/04/05/2018-04-01-datasets_example/"/>
    <id>https://zjrongxiang.github.io/2018/04/05/2018-04-01-datasets_example/</id>
    <published>2018-04-05T11:30:00.000Z</published>
    <updated>2018-04-05T15:07:58.609Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>数据科学研究的对象是数据，学习过程中需要相关数据集辅助大家练习、做实验。从而体会数据科学中算法方法论。中国古语云：巧妇难有无米之炊，说的就是数据对于数据科学学习的重要性。</p><p>这篇文章收集介绍了各种常用的开放数据集，供大家学习参考。会持续更新。</p><h3 id="开放数据集"><a href="#开放数据集" class="headerlink" title="开放数据集"></a>开放数据集</h3><p>这里主要将开放数据分为三类：图像类、自然语言（NLP）类、音频类。</p><h4 id="图像类"><a href="#图像类" class="headerlink" title="图像类"></a>图像类</h4><h5 id="MNIST手写数据集"><a href="#MNIST手写数据集" class="headerlink" title="MNIST手写数据集"></a>MNIST手写数据集</h5><ul><li><p>介绍：</p><p>MNIST（全称：Modified National Institute of Standards and Technology database）数据集是常见的深度学习开放数据集（基本属于深度学习的hello world数据集）。这是一个手写阿拉伯数据集（0-9数字），数据主要采集于美国高中学生。数据集总量为7W个手写数字图像（训练集6w个、测试机1w个）。</p><p><img src="\images\picture\digits.jpeg" alt=""></p></li></ul><table><thead><tr><th style="text-align:center">文件</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td style="text-align:center"><a href="http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz" target="_blank" rel="noopener">train-images-idx3-ubyte.gz</a></td><td style="text-align:center">训练集图片 - 60000张训练图片</td></tr><tr><td style="text-align:center"><a href="http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz" target="_blank" rel="noopener">train-labels-idx1-ubyte.gz</a></td><td style="text-align:center">训练集图片对应的数字标签（0-9）</td></tr><tr><td style="text-align:center"><a href="http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz" target="_blank" rel="noopener">t10k-images-idx3-ubyte.gz</a></td><td style="text-align:center">测试集图片 - 10000 张 图片</td></tr><tr><td style="text-align:center"><a href="http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz" target="_blank" rel="noopener">t10k-labels-idx1-ubyte.gz</a></td><td style="text-align:center">测试集图片对应的数字标签</td></tr></tbody></table><ul><li><p>数据存储大小：二进制文件，50M，压缩形式约10M。每张图像被归一化成28*28的像素矩阵。</p></li><li><p>图像数据格式：像素值为0到255. 0表示背景（白色），255表示前景（黑色）。例如下面手写数字1的数据矩阵表示：</p><p><img src="\images\picture\MNIST-Matrix.png" alt="图像数据矩阵"></p></li><li><p>官方网页连接：<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/</a></p></li><li><p>读取数据案例（Python）：</p><p>Tensorflow中已经有对MNIST数据集解析的脚本，我们可以直接调用：</p></li></ul><table><thead><tr><th style="text-align:center">文件</th><th style="text-align:center">目的</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://github.com/tensorflow/tensorflow/blob/r1.1/tensorflow/examples/tutorials/mnist/input_data.py" target="_blank" rel="noopener">input_data.py</a>、<a href="https://github.com/tensorflow/tensorflow/blob/r1.1/tensorflow/contrib/learn/python/learn/datasets/mnist.py" target="_blank" rel="noopener">mnist.py</a></td><td style="text-align:center">用于读取MNIST数据集</td></tr></tbody></table>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment">#tf为1.7版本</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line">data_dir = <span class="string">'/root/tftest/mnistdata/'</span></span><br><span class="line"><span class="comment">#data_dir为数据集文件存放目录</span></span><br><span class="line">mnist = input_data.read_data_sets(data_dir, one_hot=<span class="keyword">True</span>，validation_size=<span class="number">5000</span>)</span><br><span class="line"><span class="comment">#mnist = input_data.read_data_sets(data_dir, one_hot=False)</span></span><br><span class="line"><span class="comment">#one_hot参数True，表示标签进行one-hot编码处理。</span></span><br><span class="line"><span class="comment">#validation_size参数可以从训练集中划出一部分数据作为验证集。默认是5w个，可以自己调节。</span></span><br><span class="line"></span><br><span class="line">x_train,y_train,x_test,y_test,x_vali,y_vali = \</span><br><span class="line">mnist.train.images,mnist.train.labels,mnist.test.images,mnist.test.labels,\</span><br><span class="line">mnist.validation.images,mnist.validation.labels</span><br><span class="line"><span class="comment">#x_train的数据类型为：&lt;class 'numpy.ndarray'&gt;</span></span><br></pre></td></tr></table></figure><p>​       上面的例子划分好数据就可以喂给各种算法模型进行训练。</p><ul><li><p>扩展：EMNIST数据集：<a href="https://arxiv.org/abs/1702.05373。" target="_blank" rel="noopener">https://arxiv.org/abs/1702.05373。</a></p><p>按照MNIST规范，数据集更大：包含240,000个训练图像和40,000个手写数字测试图像。</p></li></ul><h5 id="MS-COCO图像分割数据集"><a href="#MS-COCO图像分割数据集" class="headerlink" title="MS-COCO图像分割数据集"></a>MS-COCO图像分割数据集</h5><ul><li><p>介绍：</p><p>MS-COCO（全称是Common Objects in Context）是微软团队提供的一个可以用来进行图像识别的数据集。数据集中的图像分为训练、验证和测试集。COCO数据集现在有3种标注类型：<strong>object instances（目标实例）, object keypoints（目标上的关键点）, 和image captions（看图说话）</strong>，使用JSON文件存储。</p><p>一共有33w张图像，80个对象类别，每幅图5个字母、25w个关键点。</p></li><li><p>数据存储大小：约25G（压缩形式）</p></li><li><p>数据格式：中文介绍可以参考知乎这篇文章：<a href="https://zhuanlan.zhihu.com/p/29393415" target="_blank" rel="noopener">COCO数据集的标注格式</a> 。</p></li><li><p>官方网站：<a href="http://mscoco.org/" target="_blank" rel="noopener">http://mscoco.org/</a></p></li></ul><h5 id="ImageNet图像数据集"><a href="#ImageNet图像数据集" class="headerlink" title="ImageNet图像数据集"></a>ImageNet图像数据集</h5><ul><li><p>介绍：</p><p>Imagenet是深度学习中大名鼎鼎的数据集。数据集有1400多万幅图片，涵盖2万多个类别；其中有超过百万的图片有明确的类别标注和图像中物体位置的标注。深度学习中关于图像分类、定位、检测等研究工作大多基于此数据集展开。Imagenet数据集文档详细，有专门的团队维护，使用非常方便，在计算机视觉领域研究论文中应用非常广，几乎成为了目前深度学习图像领域算法性能检验的“标准”数据集。</p></li><li><p>数据存储大小：约150G</p></li><li><p>官方网站：<a href="http://www.image-net.org/" target="_blank" rel="noopener">http://www.image-net.org/</a></p></li></ul><p>Open Image图像数据集</p><ul><li><p>介绍：</p><p>Open Image为Google提供。数据集包含近900万个图像URL。这些图像已经用数千个类的图像级标签边框进行了注释。该数据集包含9,011,219张图像的训练集，41,260张图像的验证集以及125,436张图像的测试集。</p></li><li><p>数据大小：500G</p></li><li><p>官方网站：<a href="https://github.com/openimages/dataset" target="_blank" rel="noopener">https://github.com/openimages/dataset</a></p></li></ul><h5 id="VisualQA图像数据库"><a href="#VisualQA图像数据库" class="headerlink" title="VisualQA图像数据库"></a>VisualQA图像数据库</h5><ul><li><p>介绍：</p><p>VQA是一个包含有关图像的开放式问题的数据集。这些问题需要理解视野和语言。数据集有265,016张图片。</p></li><li><p>数据大小：25G</p></li><li><p>官方网站：<a href="http://www.visualqa.org/" target="_blank" rel="noopener">http://www.visualqa.org/</a></p></li></ul><h5 id="The-Street-View-House-Numbers-SVHN-Dataset街边号码牌数据集"><a href="#The-Street-View-House-Numbers-SVHN-Dataset街边号码牌数据集" class="headerlink" title="The Street View House Numbers (SVHN) Dataset街边号码牌数据集"></a>The Street View House Numbers (SVHN) Dataset街边号码牌数据集</h5><ul><li><p>介绍：</p><p>SVHN图像数据集用于开发机器学习和对象识别算法，对数据预处理和格式化的要求最低。它可以被看作与<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST</a>相似，但是将更多标记数据（超过600,000个数字图像）并入一个数量级并且来自显着更难以解决的真实世界问题（识别自然场景图像中的数字和数字）。SVHN数据从谷歌街景图片中的房屋号码中获得的。书记含有用于训练的73257个数字，用于测试的26032个数字以及用作额外训练数据的531131个附加数字。</p></li><li><p>数据集大小： [train.tar.gz]， [test.tar.gz]， [extra.tar.gz ] 共三个文件。</p></li><li><p>官方网站：<a href="http://ufldl.stanford.edu/housenumbers/" target="_blank" rel="noopener">http://ufldl.stanford.edu/housenumbers/</a></p></li></ul><h5 id="CIFAR-10图像数据集"><a href="#CIFAR-10图像数据集" class="headerlink" title="CIFAR-10图像数据集"></a>CIFAR-10图像数据集</h5><ul><li><p>介绍：</p><p>CIFAR-10数据集由10个类的60,000个图像组成（每个类在上图中表示为一行）。总共有50,000个训练图像和10,000个测试图像。数据集分为6个部分 - 5个培训批次和1个测试批次。每批有10,000个图像。</p></li><li><p>数据大小：170M</p></li><li><p>官方网站：<a href="http://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">http://www.cs.toronto.edu/~kriz/cifar.html</a></p></li></ul><h5 id="Fashion-MNIST"><a href="#Fashion-MNIST" class="headerlink" title="Fashion-MNIST"></a>Fashion-MNIST</h5><ul><li><p>介绍</p><p>Fashion-MNIST包含60,000个训练图像和10,000个测试图像。它是一个类似MNIST的时尚产品数据库。开发人员认为MNIST已被过度使用，因此他们将其作为该数据集的直接替代品。每张图片都以灰度显示，并与10个类别的标签相关联。</p></li><li><p>数据集大小：30M</p></li><li><p>官方网站：<a href="https://github.com/zalandoresearch/fashion-mnist" target="_blank" rel="noopener">https://github.com/zalandoresearch/fashion-mnist</a></p></li></ul><h4 id="自然语言类数据库"><a href="#自然语言类数据库" class="headerlink" title="自然语言类数据库"></a>自然语言类数据库</h4><h5 id="IMDB电影评论数据集"><a href="#IMDB电影评论数据集" class="headerlink" title="IMDB电影评论数据集"></a>IMDB电影评论数据集</h5><ul><li><p>介绍：</p><p>这是电影爱好者的梦幻数据集。它具有比此领域以前的任何数据集更多的数据。除了训练和测试评估示例之外，还有更多未标记的数据供您使用。原始文本和预处理的单词格式包也包括在内。</p></li><li><p>数据集大小：80 M</p></li><li><p>官方网站：<a href="http://ai.stanford.edu/~amaas/data/sentiment/" target="_blank" rel="noopener">http://ai.stanford.edu/~amaas/data/sentiment/</a></p></li><li><p>模型案例：<a href="https://arxiv.org/abs/1705.09207" target="_blank" rel="noopener">https://arxiv.org/abs/1705.09207</a></p></li></ul><h5 id="Twenty-Newsgroups-Data-Set"><a href="#Twenty-Newsgroups-Data-Set" class="headerlink" title="Twenty Newsgroups Data Set"></a>Twenty Newsgroups Data Set</h5><ul><li><p>介绍：</p><p>该数据集包含有关新闻组的信息。为了管理这个数据集，从20个不同的新闻组中获取了1000篇Usenet文章。这些文章具有典型特征，如主题行，签名和引号。</p></li><li><p>数据集大小：20 M</p></li><li><p>官方网站：<a href="https://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups" target="_blank" rel="noopener">https://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups</a></p></li><li><p>模型案例：<a href="https://arxiv.org/abs/1606.01781" target="_blank" rel="noopener">https://arxiv.org/abs/1606.01781</a></p></li></ul><h5 id="Sentiment140情感分析数据集"><a href="#Sentiment140情感分析数据集" class="headerlink" title="Sentiment140情感分析数据集"></a>Sentiment140情感分析数据集</h5><ul><li><p>介绍：</p><p>Sentiment140是一个可用于情感分析的数据集。</p></li><li><p>数据集大小：80 M</p></li><li><p>官方网站：<a href="http://help.sentiment140.com/for-students/" target="_blank" rel="noopener">http://help.sentiment140.com/for-students/</a></p></li><li><p>模型案例：<a href="http://www.aclweb.org/anthology/W17-5202" target="_blank" rel="noopener">http://www.aclweb.org/anthology/W17-5202</a></p></li></ul><h5 id="WordNet"><a href="#WordNet" class="headerlink" title="WordNet"></a>WordNet</h5><ul><li><p>介绍：</p><p>WordNet是英语synsets的大型数据库。Synsets是同义词组，每个描述不同的概念。WordNet的结构使其成为NLP非常有用的工具。</p></li><li><p>数据集大小：10 M</p></li><li><p>官方网站：<a href="https://wordnet.princeton.edu/" target="_blank" rel="noopener">https://wordnet.princeton.edu/</a></p></li><li><p>模型案例：<a href="https://aclanthology.info/pdf/R/R11/R11-1097.pdf" target="_blank" rel="noopener">https://aclanthology.info/pdf/R/R11/R11-1097.pdf</a></p></li></ul><h5 id="Yelp评论"><a href="#Yelp评论" class="headerlink" title="Yelp评论"></a>Yelp评论</h5><ul><li><p>介绍：</p><p>这是Yelp为了学习目的而发布的一个开放数据集。它由数百万用户评论，商业属性和来自多个大都市地区的超过20万张照片组成。这是一个非常常用的全球NLP挑战数据集。</p></li><li><p>数据集大小：2.66 GB JSON，2.9 GB SQL和7.5 GB照片（全部压缩）</p></li><li><p>官方网站：<a href="https://www.yelp.com/dataset" target="_blank" rel="noopener">https://www.yelp.com/dataset</a></p></li><li><p>模型案例：<a href="https://arxiv.org/pdf/1710.00519.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1710.00519.pdf</a></p></li></ul><h5 id="维基百科语料库"><a href="#维基百科语料库" class="headerlink" title="维基百科语料库"></a>维基百科语料库</h5><ul><li><p>介绍：</p><p>该数据集是维基百科全文的集合。它包含来自400多万篇文章的将近19亿字。什么使得这个强大的NLP数据集是你可以通过单词，短语或段落本身的一部分进行搜索。</p></li><li><p>数据集大小： 20 MB</p></li><li><p>官方网站：<a href="https://corpus.byu.edu/wiki/" target="_blank" rel="noopener">https://corpus.byu.edu/wiki/</a></p></li><li><p>模型案例：<a href="https://arxiv.org/pdf/1711.03953.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1711.03953.pdf</a></p></li></ul><h5 id="博客作者身份语料库"><a href="#博客作者身份语料库" class="headerlink" title="博客作者身份语料库"></a>博客作者身份语料库</h5><ul><li><p>介绍：</p><p>此数据集包含从数千名博主收集的博客帖子，从blogger.com收集。每个博客都作为一个单独的文件提供。每个博客至少包含200次常用英语单词。</p></li><li><p>数据集大小： 300 MB</p></li><li><p>官方网站：<a href="http://u.cs.biu.ac.il/~koppel/BlogCorpus.htm" target="_blank" rel="noopener">http://u.cs.biu.ac.il/~koppel/BlogCorpus.htm</a></p></li><li><p>模型案例：<a href="https://arxiv.org/pdf/1609.06686.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1609.06686.pdf</a></p></li></ul><h5 id="欧洲语言的机器翻译"><a href="#欧洲语言的机器翻译" class="headerlink" title="欧洲语言的机器翻译"></a>欧洲语言的机器翻译</h5><ul><li><p>介绍：</p><p>数据集包含四种欧洲语言。</p></li><li><p>数据集大小： 约15 G</p></li><li><p>官方网站：<a href="http://statmt.org/wmt11/translation-task.html" target="_blank" rel="noopener">http://statmt.org/wmt11/translation-task.html</a></p></li><li><p>模型案例：<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">https://arxiv.org/abs/1706.03762</a></p></li></ul><h4 id="音频-语音数据集"><a href="#音频-语音数据集" class="headerlink" title="音频/语音数据集"></a>音频/语音数据集</h4><h5 id="口语数字数据集"><a href="#口语数字数据集" class="headerlink" title="口语数字数据集"></a>口语数字数据集</h5><ul><li><p>介绍：</p><p>为了解决识别音频样本中的口头数字的任务而创建。这是一个开放的数据集，所以希望随着人们继续贡献更多样本，它会不断增长。</p></li><li><p>数据集大小： 约10 G=M</p></li><li><p>记录数量：1500个音频样本</p></li><li><p>官方网站：<a href="https://github.com/Jakobovski/free-spoken-digit-dataset" target="_blank" rel="noopener">https://github.com/Jakobovski/free-spoken-digit-dataset</a></p></li><li><p>模型案例：<a href="https://arxiv.org/pdf/1712.00866" target="_blank" rel="noopener">https://arxiv.org/pdf/1712.00866</a></p></li></ul><h5 id="免费音乐档案（FMA）"><a href="#免费音乐档案（FMA）" class="headerlink" title="免费音乐档案（FMA）"></a>免费音乐档案（FMA）</h5><ul><li><p>介绍：</p><p>FMA是音乐分析的数据集。数据集由全长和HQ音频，预先计算的特征以及音轨和用户级元数据组成。它是一个开放数据集，用于评估MIR中的几个任务。以下是数据集连同其包含的csv文件列表：</p><ul><li><code>tracks.csv</code>：所有106,574首曲目的每首曲目元数据，如ID，标题，艺术家，流派，标签和播放次数。</li><li><code>genres.csv</code>：所有163种风格的ID与他们的名字和父母（用于推断流派层次和顶级流派）。</li><li><code>features.csv</code>：用<a href="https://librosa.github.io/librosa/" target="_blank" rel="noopener">librosa</a>提取的共同特征  。</li><li><code>echonest.csv</code>：由<a href="http://the.echonest.com/" target="_blank" rel="noopener">Echonest</a>  （现在的  <a href="https://www.spotify.com/" target="_blank" rel="noopener">Spotify</a>）为13,129首音轨的子集提供的音频功能  。</li></ul></li><li><p>数据集大小： 约1T</p></li><li><p>记录数量：1500个音频样本</p></li><li><p>官方网站：<a href="https://github.com/mdeff/fma" target="_blank" rel="noopener">https://github.com/mdeff/fma</a></p></li><li><p>模型案例：<a href="https://arxiv.org/pdf/1803.05337.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1803.05337.pdf</a></p></li></ul><h5 id="舞厅"><a href="#舞厅" class="headerlink" title="舞厅"></a>舞厅</h5><ul><li><p>介绍：</p><p>该数据集包含舞厅跳舞音频文件。以真实音频格式提供了许多舞蹈风格的一些特征摘录。 以下是数据集的一些特征：</p></li><li><p>数据集大小： 约14 G</p></li><li><p>记录数量：约700个音频样本</p></li><li><p>官方网站：<a href="http://mtg.upf.edu/ismir2004/contest/tempoContest/node5.html" target="_blank" rel="noopener">http://mtg.upf.edu/ismir2004/contest/tempoContest/node5.html</a></p></li><li><p>模型案例：<a href="https://pdfs.semanticscholar.org/0cc2/952bf70c84e0199fcf8e58a8680a7903521e.pdf" target="_blank" rel="noopener">https://pdfs.semanticscholar.org/0cc2/952bf70c84e0199fcf8e58a8680a7903521e.pdf</a></p></li></ul><h5 id="百万歌曲数据集"><a href="#百万歌曲数据集" class="headerlink" title="百万歌曲数据集"></a>百万歌曲数据集</h5><ul><li><p>介绍：</p><p>百万歌曲数据集是音频功能和元数据的一百万当代流行音乐曲目可自由可用的集合。 其目的是：</p><ul><li>鼓励对扩大到商业规模的算法进行研究</li><li>为评估研究提供参考数据集</li><li>作为使用API创建大型数据集的捷径（例如Echo Nest的）</li><li>帮助新研究人员在MIR领域开始工作</li></ul><p>数据集的核心是一百万首歌曲的特征分析和元数据。该数据集不包含任何音频，只包含派生的功能。示例音频可以通过使用哥伦比亚大学提供的<a href="https://github.com/tb2332/MSongsDB/tree/master/Tasks_Demos/Preview7digital" target="_blank" rel="noopener">代码</a>从<a href="http://www.7digital.com/" target="_blank" rel="noopener">7digital等</a>服务中获取。</p></li><li><p>数据集大小： 约280 G</p></li><li><p>记录数量：它的一百万首歌曲！</p></li><li><p>官方网站：<a href="https://labrosa.ee.columbia.edu/millionsong/" target="_blank" rel="noopener">https://labrosa.ee.columbia.edu/millionsong/</a></p></li><li><p>模型案例：<a href="http://www.ke.tu-darmstadt.de/events/PL-12/papers/08-aiolli.pdf" target="_blank" rel="noopener">http://www.ke.tu-darmstadt.de/events/PL-12/papers/08-aiolli.pdf</a></p></li></ul><h5 id="LibriSpeech"><a href="#LibriSpeech" class="headerlink" title="LibriSpeech"></a>LibriSpeech</h5><ul><li><p>介绍：</p><p>该数据集是大约1000小时的英语语音的大型语料库。这些数据来自LibriVox项目的有声读物。它已被分割并正确对齐。如果您正在寻找一个起点，请查看已准备好的声学模型，这些模型在<a href="http://www.kaldi-asr.org/downloads/build/6/trunk/egs/" target="_blank" rel="noopener">kaldi-asr.org</a>和语言模型上进行了训练，适合评估，<a href="http://www.openslr.org/11/" target="_blank" rel="noopener">网址</a>为<a href="http://www.openslr.org/11/" target="_blank" rel="noopener">http://www.openslr.org/11/</a>。</p></li><li><p>数据集大小： 约60 G</p></li><li><p>记录数量：1000小时的演讲</p></li><li><p>官方网站：<a href="http://www.openslr.org/12/" target="_blank" rel="noopener">http://www.openslr.org/12/</a></p></li><li><p>模型案例：<a href="https://arxiv.org/abs/1712.09444" target="_blank" rel="noopener">https://arxiv.org/abs/1712.09444</a></p></li></ul><h5 id="VoxCeleb"><a href="#VoxCeleb" class="headerlink" title="VoxCeleb"></a>VoxCeleb</h5><ul><li><p>介绍：</p><p>VoxCeleb是一个大型的说话人识别数据集。它包含约1,200名来自YouTube视频的约10万个话语。数据大部分是性别平衡的（男性占55％）。名人跨越不同的口音，职业和年龄。开发和测试集之间没有重叠。对于隔离和识别哪个超级巨星来说，这是一个有趣的用例。</p></li><li><p>数据集大小： 约150 M</p></li><li><p>记录数量： 1,251位名人的100,000条话语</p></li><li><p>官方网站：<a href="http://www.robots.ox.ac.uk/~vgg/data/voxceleb/" target="_blank" rel="noopener">http://www.robots.ox.ac.uk/~vgg/data/voxceleb/</a></p></li><li><p>模型案例：<a href="https://www.robots.ox.ac.uk/~vgg/publications/2017/Nagrani17/nagrani17.pdf" target="_blank" rel="noopener">https://www.robots.ox.ac.uk/~vgg/publications/2017/Nagrani17/nagrani17.pdf</a></p></li></ul><h4 id="比赛数据"><a href="#比赛数据" class="headerlink" title="比赛数据"></a>比赛数据</h4><h5 id="Twitter情绪分析数据"><a href="#Twitter情绪分析数据" class="headerlink" title="Twitter情绪分析数据"></a>Twitter情绪分析数据</h5><ul><li><p>介绍：</p><p>仇恨以种族主义和性别歧视为形式的言论已成为叽叽喳喳的麻烦，重要的是将这类推文与其他人分开。在这个实践问题中，我们提供既有正常又有仇恨推文的Twitter数据。您作为数据科学家的任务是确定推文是仇恨推文，哪些不是。</p></li><li><p>数据集大小： 约3 M</p></li><li><p>记录数量： 31,962条推文</p></li><li><p>官方网站：<a href="https://datahack.analyticsvidhya.com/contest/practice-problem-twitter-sentiment-analysis/" target="_blank" rel="noopener">https://datahack.analyticsvidhya.com/contest/practice-problem-twitter-sentiment-analysis/</a></p></li></ul><h5 id="印度演员的年龄检测"><a href="#印度演员的年龄检测" class="headerlink" title="印度演员的年龄检测"></a>印度演员的年龄检测</h5><ul><li><p>介绍：</p><p>对于任何深度学习爱好者来说，这是一个令人着迷的挑战。该数据集包含数千个印度演员的图像，你的任务是确定他们的年龄。所有图像都是手动选择的，并从视频帧中剪切，导致尺度，姿势，表情，照度，年龄，分辨率，遮挡和化妆的高度可变性。</p></li><li><p>数据集大小： 约48 M</p></li><li><p>记录数量： 训练集中的19,906幅图像和测试集中的6636幅图像</p></li><li><p>官方网站：<a href="https://datahack.analyticsvidhya.com/contest/practice-problem-age-detection/" target="_blank" rel="noopener">https://datahack.analyticsvidhya.com/contest/practice-problem-age-detection/</a></p></li></ul><h5 id="城市声音分类"><a href="#城市声音分类" class="headerlink" title="城市声音分类"></a>城市声音分类</h5><ul><li><p>介绍：</p><p>这个数据集包含超过8000个来自10个班级的城市声音摘录。这个实践问题旨在向您介绍常见分类方案中的音频处理。</p></li><li><p>数据集大小： 训练集 - 3 GB（压缩），测试集 - 2 GB（压缩）</p></li><li><p>记录数量： 来自10个班级的8732个城市声音标注的声音片段（&lt;= 4s）</p></li><li><p>官方网站：<a href="https://datahack.analyticsvidhya.com/contest/practice-problem-urban-sound-classification/" target="_blank" rel="noopener">https://datahack.analyticsvidhya.com/contest/practice-problem-urban-sound-classification/</a></p></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>【1】   <a href="https://www.tensorflow.org/versions/r1.1/get_started/mnist/beginners" target="_blank" rel="noopener">https://www.tensorflow.org/versions/r1.1/get_started/mnist/beginners</a></p><p>【2】  <a href="https://www.analyticsvidhya.com/blog/2018/03/comprehensive-collection-deep-learning-datasets/" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2018/03/comprehensive-collection-deep-learning-datasets/</a></p><p>【3】  <a href="https://deeplearning4j.org/cn/opendata" target="_blank" rel="noopener">https://deeplearning4j.org/cn/opendata</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;数据科学研究的对象是数据，学习过程中需要相关数据集辅助大家练习、做实验。从而体会数据科学中算法方法论。中国古语云：巧妇难有无米之炊，说的就是
      
    
    </summary>
    
      <category term="datasets" scheme="https://zjrongxiang.github.io/categories/datasets/"/>
    
    
      <category term="datasets" scheme="https://zjrongxiang.github.io/tags/datasets/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu挂载新的硬盘（2T以上）</title>
    <link href="https://zjrongxiang.github.io/2018/04/01/2018-04-01-ubuntu_add_disk/"/>
    <id>https://zjrongxiang.github.io/2018/04/01/2018-04-01-ubuntu_add_disk/</id>
    <published>2018-04-01T15:30:00.000Z</published>
    <updated>2018-04-04T14:21:39.551Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统环境："><a href="#系统环境：" class="headerlink" title="系统环境："></a>系统环境：</h3><p>Linux version 4.13.0-37-generic (Ubuntu 5.4.0-6ubuntu1~16.04.9)</p><p>root用户登入操作</p><h3 id="查看硬盘信息"><a href="#查看硬盘信息" class="headerlink" title="查看硬盘信息"></a>查看硬盘信息</h3><p>机器断电时，接入硬盘。开机后用下面的命令查看硬盘状况（<font color="red">非root用户需sudo</font>）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# fdisk -l</span><br><span class="line">Disk /dev/sda: 465.8 GiB, 500107862016 bytes, 976773168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: CC8004FC-D422-48FA-8ACF-54C3F48E860B</span><br><span class="line"></span><br><span class="line">Device         Start       End   Sectors   Size Type</span><br><span class="line">/dev/sda1       2048   1050623   1048576   512M EFI System</span><br><span class="line">/dev/sda2    1050624 909946879 908896256 433.4G Linux filesystem</span><br><span class="line">/dev/sda3  909946880 976771071  66824192  31.9G Linux swap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3.7 TiB, 4000787030016 bytes, 7814037168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br></pre></td></tr></table></figure><p>查看到系统由两块硬盘：/dev/sda和/dev/sdb，如果还有其他硬盘会继续sdc、sdd编号。</p><p>正在使用的系统盘sda已经有三个分区（sda1、sda2、sda3），新挂载的硬盘sdb位分区。</p><h3 id="新挂载硬盘分区"><a href="#新挂载硬盘分区" class="headerlink" title="新挂载硬盘分区"></a>新挂载硬盘分区</h3><p>新硬盘存储空间一共4T，我们对硬盘进行分区。划分为两个分区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.27.1).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">/dev/sdb: device contains a valid 'ext4' signature; it is strongly recommended to wipe the device with wipefs(8) if this is sible collisions</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table.</span><br><span class="line">The size of this disk is 3.7 TiB (4000787030016 bytes). DOS partition table format can not be used on drives for volumes lar512-byte sectors. Use GUID partition table format (GPT).</span><br><span class="line"></span><br><span class="line">Created a new DOS disklabel with disk identifier 0x6b028a17.</span><br><span class="line"></span><br><span class="line">Command (m for help):</span><br></pre></td></tr></table></figure><p>注意这里已经有警告：<em>The size of this disk is 3.7 TiB (4000787030016 bytes). DOS partition table format can not be used on drives for volumes lar512-byte sectors. Use GUID partition table format (GPT)</em></p><p>这里情况特殊，新加入的磁盘为4T。fdisk命令对于大于2T的分区无法划分。如果继续使用fdisk工具，最多只能分出2T的分区，剩下的空间无法利用。这不坑爹嘛。提示我们使用parted命令。</p><h3 id="使用parted分区"><a href="#使用parted分区" class="headerlink" title="使用parted分区"></a>使用parted分区</h3><p>parted命令可以划分单个分区大于2T的GPT格式的分区。</p><p>更改分区表类型：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# parted -s /dev/sdb mklabel gpt</span><br></pre></td></tr></table></figure><p>使用parted进行分区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# parted /dev/sdb</span><br><span class="line">GNU Parted 3.2</span><br><span class="line">Using /dev/sdb</span><br><span class="line">Welcome to GNU Parted! Type 'help' to view a list of commands.</span><br><span class="line">(parted) print                                                            </span><br><span class="line">Model: ATA WDC WD40EFRX-68N (scsi)</span><br><span class="line">Disk /dev/sdb: 4001GB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start  End  Size  File system  Name  Flags</span><br><span class="line"></span><br><span class="line">(parted) mklabel gpt                                                      </span><br><span class="line">Warning: The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost. Do you want to continue?</span><br><span class="line">Yes/No? yes                                                               </span><br><span class="line">(parted) mkpart                                                           </span><br><span class="line">Partition name?  []?                                                      </span><br><span class="line">File system type?  [ext2]? ext4                                           </span><br><span class="line">Start? 0%                                                                 </span><br><span class="line">End? 100%                                                                 </span><br><span class="line">(parted) print                                                            </span><br><span class="line">Model: ATA WDC WD40EFRX-68N (scsi)</span><br><span class="line">Disk /dev/sdb: 4001GB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  4001GB  4001GB  ext4</span><br><span class="line"></span><br><span class="line">(parted) quit                                                             </span><br><span class="line">Information: You may need to update /etc/fstab.</span><br></pre></td></tr></table></figure><p>最后我们验证一下，sdb1分区成功，提示我们要更新系统文件：/etc/fstab。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# ls /dev/sd*                                          </span><br><span class="line">/dev/sda  /dev/sda1  /dev/sda2  /dev/sda3  /dev/sdb  /dev/sdb1</span><br><span class="line">root@deeplearning:~# fdisk -l</span><br><span class="line">Disk /dev/sda: 465.8 GiB, 500107862016 bytes, 976773168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: CC8004FC-D422-48FA-8ACF-54C3F48E860B</span><br><span class="line"></span><br><span class="line">Device         Start       End   Sectors   Size Type</span><br><span class="line">/dev/sda1       2048   1050623   1048576   512M EFI System</span><br><span class="line">/dev/sda2    1050624 909946879 908896256 433.4G Linux filesystem</span><br><span class="line">/dev/sda3  909946880 976771071  66824192  31.9G Linux swap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3.7 TiB, 4000787030016 bytes, 7814037168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 0D8B0FBC-83F6-4D77-ABDB-98875EC511E4</span><br><span class="line"></span><br><span class="line">Device     Start        End    Sectors  Size Type</span><br><span class="line">/dev/sdb1   2048 7814035455 7814033408  3.7T Linux filesystem</span><br></pre></td></tr></table></figure><h3 id="格式化新建分区"><a href="#格式化新建分区" class="headerlink" title="格式化新建分区"></a>格式化新建分区</h3><p>将分区格式化为ext4格式的文件系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:~# mkfs.ext4 /dev/sdb1</span><br><span class="line">mke2fs 1.42.13 (17-May-2015)</span><br><span class="line">Creating filesystem with 976754176 4k blocks and 244195328 inodes</span><br><span class="line">Filesystem UUID: dfcd419f-38a5-4a5c-9b93-9f236d2c2444</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, </span><br><span class="line">4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968, </span><br><span class="line">102400000, 214990848, 512000000, 550731776, 644972544</span><br><span class="line"></span><br><span class="line">Allocating group tables: done                            </span><br><span class="line">Writing inode tables: done                            </span><br><span class="line">Creating journal (32768 blocks): done</span><br><span class="line">Writing superblocks and filesystem accounting information:            </span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>如果有多个分区需要依次执行格式化。</p><h3 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h3><p>新建硬盘即将挂载的目录，然后将硬盘挂载到该目录下。并验证挂载成功，检查硬盘空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# mkdir /data</span><br><span class="line">root@deeplearning:/# mount /dev/sdb1 /data</span><br><span class="line">root@deeplearning:/# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev             16G     0   16G   0% /dev</span><br><span class="line">tmpfs           3.2G  9.3M  3.2G   1% /run</span><br><span class="line">/dev/sda2       427G   21G  385G   5% /</span><br><span class="line">tmpfs            16G     0   16G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M   1% /run/lock</span><br><span class="line">tmpfs            16G     0   16G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1       511M  3.5M  508M   1% /boot/efi</span><br><span class="line">tmpfs           3.2G   12K  3.2G   1% /run/user/1000</span><br><span class="line">/dev/sdb1       3.6T   68M  3.4T   1% /data</span><br></pre></td></tr></table></figure><p>上面我们把新的硬盘挂载到了/data目录，硬盘空间大小正常。</p><h3 id="配置开机自动挂载分区"><a href="#配置开机自动挂载分区" class="headerlink" title="配置开机自动挂载分区"></a>配置开机自动挂载分区</h3><h4 id="查看分区的UUID"><a href="#查看分区的UUID" class="headerlink" title="查看分区的UUID"></a>查看分区的UUID</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# blkid</span><br><span class="line"><span class="meta">#</span>（略）...</span><br><span class="line">/dev/sdb1: UUID="dfcd419f-38a5-4a5c-9b93-9f236d2c2444" TYPE="ext4" PARTUUID="fe373bd5-5b19-4ed0-8713-716455a8ebb4"</span><br></pre></td></tr></table></figure><h4 id="配置-etc-fstab"><a href="#配置-etc-fstab" class="headerlink" title="配置/etc/fstab"></a>配置/etc/fstab</h4><p>将分区信息写到/etc/fstab文件中让它永久挂载:</p><p>将下面的配置信息加入配置文件尾部：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=dfcd419f-38a5-4a5c-9b93-9f236d2c2444 /data ext4 defaults 0 1</span><br></pre></td></tr></table></figure><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="etc-fstab配置说明"><a href="#etc-fstab配置说明" class="headerlink" title="/etc/fstab配置说明"></a>/etc/fstab配置说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Use &apos;blkid&apos; to print the universally unique identifier for a</span><br><span class="line"># device; this may be used with UUID= as a more robust way to name devices</span><br><span class="line"># that works even if disks are added and removed. See fstab(5).</span><br><span class="line"></span><br><span class="line">&lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;      &lt;pass&gt;</span><br><span class="line">    1               2            3         4             5            6</span><br><span class="line">对应参数说明：</span><br><span class="line">1、指代文件系统的设备名。最初，该字段只包含待挂载分区的设备名（如/dev/sda1）。现在，除设备名外，还可以包含LABEL或UUID</span><br><span class="line">2、文件系统挂载点。文件系统包含挂载点下整个目录树结构里的所有数据，除非其中某个目录又挂载了另一个文件系统</span><br><span class="line">3、文件系统类型。下面是多数常见文件系统类型（ext3,tmpfs,devpts,sysfs,proc,swap,vfat）</span><br><span class="line">4、mount命令选项。mount选项包括noauto（启动时不挂载该文件系统）和ro（只读方式挂载文件系统）等。在该字段里添加用户或属主选项，即可允许该用户挂载文件系统。多个选项之间必须用逗号隔开。其他选项的相关信息可参看mount命令手册页（-o选项处）</span><br><span class="line">5、转储文件系统？该字段只在用dump备份时才有意义。数字1表示该文件系统需要转储，0表示不需要转储</span><br><span class="line">6、文件系统检查？该字段里的数字表示文件系统是否需要用fsck检查。0表示不必检查该文件系统，数字1示意该文件系统需要先行检查（用于根文件系统）。数字2则表示完成根文件系统检查后，再检查该文件系统。</span><br></pre></td></tr></table></figure><h4 id="Parted命令说明（本文使用交互模式完成配置）"><a href="#Parted命令说明（本文使用交互模式完成配置）" class="headerlink" title="Parted命令说明（本文使用交互模式完成配置）"></a>Parted命令说明（本文使用交互模式完成配置）</h4><p>Parted 命令分为两种模式：命令行模式和交互模式。</p><ul><li>命令行模式： parted [option] device [command] ,该模式可以直接在命令行下对磁盘进行分区操作，比较适合编程应用。</li><li>交互模式：parted [option] device 类似于使用fdisk /dev/xxx</li><li>MBR：MBR分区表(即主引导记录)大家都很熟悉。所支持的最大卷：2T，而且对分区有限制：最多4个主分区或3个主分区加一个扩展分区</li><li>GPT： GPT（即GUID分区表）。是源自EFI标准的一种较新的磁盘分区表结构的标准，是未来磁盘分区的主要形式。与MBR分区方式相比，具有如下优点。突破MBR 4个主分区限制，每个磁盘最多支持128个分区。支持大于2T的分区，最大卷可达18EB。</li></ul><p>parted是一个可以分区并进行分区调整的工具，他可以创建，破坏，移动，复制，调整ext2 linux-swap fat fat32 reiserfs类型的分区，可以创建，调整，移动Macintosh的HFS分区，检测jfs，ntfs，ufs，xfs分区。</p><p>使用方法：<code>parted [options] [device [command [options...]...]]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">options</span><br><span class="line">-h  显示帮助信息</span><br><span class="line">-l  显示所有块设备上的分区</span><br><span class="line">device 对哪个块设备进行操作，如果没有指定则使用第一个块设备</span><br><span class="line">command [options...]</span><br><span class="line"></span><br><span class="line">check partition  对分区做一个简单的检测</span><br><span class="line"></span><br><span class="line">cp [source-device] source dest  复制source-device设备上的source分区到当前设备的dest分区</span><br><span class="line"></span><br><span class="line">mklabel label-type 创建新分区表类型，label-type可以是："bsd", "dvh", "gpt",  "loop","mac", "msdos", "pc98", or "sun" 一般的pc机都是msdos格式，如果分区大于2T则需要选用gpt格式的分区表。</span><br><span class="line"></span><br><span class="line">mkfs partition fs-type   在partition分区上创建一个fs-type文件系统，fs-type可以是："fat16", "fat32", "ext2", "linux-swap","reiserfs" 注意不支持ext3格式的文件系统，只能先分区然后用专有命令进行格式化。</span><br><span class="line"></span><br><span class="line">mkpart part-type [fs-type] start end  创建一个part-type类型的分区，part-type可以是："primary", "logical", or "extended" 如果指定fs-type则在创建分区的同时进行格式化。start和end指的是分区的起始位置，单位默认是M。</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">mkpart  primary  0  -1   0表示分区的开始  -1表示分区的结尾  意思是划分整个硬盘空间为主分区</span><br><span class="line">mkpartfs part-type fs-type start end 创建一个fs-type类型的part-type分区，不推荐使用，最好是使用mkpart分区完成后使用mke2fs进行格式化。</span><br><span class="line">name partition name 给分区设置一个名字，这种设置只能用在Mac, PC98, and GPT类型的分区表，设置时名字用引号括起来</span><br><span class="line">select device 在机器上有多个硬盘时，选择操作那个硬盘</span><br><span class="line">resize partition start end  调整分区大小</span><br><span class="line">rm partition  删除一个分区</span><br><span class="line">rescue start end  拯救一个位于stat和end之间的分区</span><br><span class="line">unit unit 在前面分区时，默认分区时数值的单位是M，这个参数卡伊改变默认单位，"kB", "MB",  "GB",  "TB"</span><br><span class="line">move partition start end 移动partition分区</span><br><span class="line">print  显示分区表信息  </span><br><span class="line">quit 退出parted</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>【1】  <a href="http://magicmonster.com/kb/os/linux/large_hdd.html" target="_blank" rel="noopener">Setting up a large (2TB+) hard disk drive on Linux</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;系统环境：&quot;&gt;&lt;a href=&quot;#系统环境：&quot; class=&quot;headerlink&quot; title=&quot;系统环境：&quot;&gt;&lt;/a&gt;系统环境：&lt;/h3&gt;&lt;p&gt;Linux version 4.13.0-37-generic (Ubuntu 5.4.0-6ubuntu1~16.
      
    
    </summary>
    
      <category term="ubuntu" scheme="https://zjrongxiang.github.io/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="https://zjrongxiang.github.io/tags/ubuntu/"/>
    
      <category term="disk" scheme="https://zjrongxiang.github.io/tags/disk/"/>
    
      <category term="parted" scheme="https://zjrongxiang.github.io/tags/parted/"/>
    
  </entry>
  
  <entry>
    <title>Hexo:解决Typora编辑table无法被解析问题</title>
    <link href="https://zjrongxiang.github.io/2018/04/01/2018-04-05-Hexo_table/"/>
    <id>https://zjrongxiang.github.io/2018/04/01/2018-04-05-Hexo_table/</id>
    <published>2018-04-01T15:30:00.000Z</published>
    <updated>2018-04-05T15:07:08.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="掉坑背景"><a href="#掉坑背景" class="headerlink" title="掉坑背景"></a>掉坑背景</h3><p>使用Typora编辑Makedown文件，添加表格，但是提交给Hexo渲染网页，无法正常解析显示，而是显示源码。例如：<br>| Table Header 1 | Table Header 2 |<br>| ————– | ————– |<br>| Division 1     | Division 2     |<br>| Division 1     | Division 2     |</p><h3 id="爬坑过程和解决办法"><a href="#爬坑过程和解决办法" class="headerlink" title="爬坑过程和解决办法"></a>爬坑过程和解决办法</h3><p>一开始认为是Hexo的bug，Google也没人遇到类似情况，都准备在github上建问题单了。最后本着严谨的态度，以文本的格式打开文档，发现表格源码和正文之间没有空行！！！！！</p><p>这尼玛坑爹呀，所以Hexo无法解析，但是Typora能正常解析。空出一行后正常解析：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;正文&gt;</span><br><span class="line">(空一行)</span><br><span class="line">| Table Header 1 | Table Header 2 |</span><br><span class="line">| - | - | </span><br><span class="line">| Division 1 | Division 2 | </span><br><span class="line">| Division 1 | Division 2 |</span><br></pre></td></tr></table></figure><table><thead><tr><th>Table Header 1</th><th>Table Header 2</th></tr></thead><tbody><tr><td>Division 1</td><td>Division 2</td></tr><tr><td>Division 1</td><td>Division 2</td></tr></tbody></table><p>这一点Typora做的不够兼容（只怪他太过于强大的解析能力。。。。）。Tyopra不服了，我强大也有错？？哈哈哈</p><p>记录该坑供掉坑小伙伴参考。</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>如果掉坑小伙伴，上面办法没解决。用文本方式打开文件，逐个排查原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;掉坑背景&quot;&gt;&lt;a href=&quot;#掉坑背景&quot; class=&quot;headerlink&quot; title=&quot;掉坑背景&quot;&gt;&lt;/a&gt;掉坑背景&lt;/h3&gt;&lt;p&gt;使用Typora编辑Makedown文件，添加表格，但是提交给Hexo渲染网页，无法正常解析显示，而是显示源码。例如：&lt;br
      
    
    </summary>
    
      <category term="hexo" scheme="https://zjrongxiang.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://zjrongxiang.github.io/tags/hexo/"/>
    
      <category term="Typora" scheme="https://zjrongxiang.github.io/tags/Typora/"/>
    
      <category term="table" scheme="https://zjrongxiang.github.io/tags/table/"/>
    
  </entry>
  
  <entry>
    <title>jupyter notebook:主题和字体的美化</title>
    <link href="https://zjrongxiang.github.io/2018/03/19/2018-03-26-jupyter-notebook/"/>
    <id>https://zjrongxiang.github.io/2018/03/19/2018-03-26-jupyter-notebook/</id>
    <published>2018-03-19T11:30:00.000Z</published>
    <updated>2018-04-06T04:06:41.421Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Jupyter notebook是数据科学常用的代码交互式工具。通常在server端启jupyter进程（web服务），client端打开浏览器，jupyter提供代码编写和调试交互环境。非常方便。</p><p>但是jupyter提供的默认界面不够美观，特别是windows操作系统默认字体为浏览器默认字体–宋体（下图），另外默认主题太难看了，没有通常IDE提供的主题美观。</p><p><img src="\images\picture\jupyter01.jpg" alt=""></p><p>发现一个Jupyter的美化工具：<strong><a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="noopener">jupyterthemes</a></strong> ，和大家分享一下。简单介绍一下安装和配置。细节介绍参考项目的介绍文档。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用pip安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# pip install jupyterthemes</span><br></pre></td></tr></table></figure><p>或者使用<a href="https://anaconda.org/conda-forge/jupyterthemes" target="_blank" rel="noopener">Anaconda的conda安装</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# conda install -c conda-forge jupyterthemes</span><br></pre></td></tr></table></figure><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>使用<code>jt -h</code>显示命令帮助说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# jt -h</span><br><span class="line">usage: jt [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT]</span><br><span class="line">          [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-dfs DFFONTSIZE]</span><br><span class="line">          [-ofs OUTFONTSIZE] [-mathfs MATHFONTSIZE] [-m MARGINS]</span><br><span class="line">          [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-cellw CELLWIDTH]</span><br><span class="line">          [-lineh LINEHEIGHT] [-altp] [-altmd] [-altout] [-P] [-T] [-N] [-vim]</span><br><span class="line">          [-r] [-dfonts]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line"><span class="meta">  #</span>-h，--help显示此帮助信息并退出</span><br><span class="line">  -l, --list            list available themes</span><br><span class="line"><span class="meta">  #</span>-l， 列出可用主题</span><br><span class="line">  -t THEME, --theme THEME</span><br><span class="line">                        theme name to install（配置需要安装的主题）</span><br><span class="line">  -f MONOFONT, --monofont MONOFONT</span><br><span class="line">                        monospace code font（代码的字体）</span><br><span class="line">  -fs MONOSIZE, --monosize MONOSIZE</span><br><span class="line">                        code font-size（代码字体大小）</span><br><span class="line">  -nf NBFONT, --nbfont NBFONT</span><br><span class="line">                        notebook font（notebook 字体）</span><br><span class="line">  -nfs NBFONTSIZE, --nbfontsize NBFONTSIZE</span><br><span class="line">                        notebook fontsize（notebook 字体大小）</span><br><span class="line">  -tf TCFONT, --tcfont TCFONT</span><br><span class="line">                        txtcell font（文本的字体）</span><br><span class="line">  -tfs TCFONTSIZE, --tcfontsize TCFONTSIZE</span><br><span class="line">                        txtcell fontsize（文本的字体大小）</span><br><span class="line">  -dfs DFFONTSIZE, --dffontsize DFFONTSIZE</span><br><span class="line">                        pandas dataframe fontsize（pandas类型的字体大小）</span><br><span class="line">  -ofs OUTFONTSIZE, --outfontsize OUTFONTSIZE</span><br><span class="line">                        output area fontsize（输出区域字体大小）</span><br><span class="line">  -mathfs MATHFONTSIZE, --mathfontsize MATHFONTSIZE</span><br><span class="line">                        mathjax fontsize (in %)（数学公式字体大小）</span><br><span class="line">  -m MARGINS, --margins MARGINS</span><br><span class="line">                        fix margins of main intro page</span><br><span class="line">  -cursw CURSORWIDTH, --cursorwidth CURSORWIDTH</span><br><span class="line">                        set cursorwidth (px)（设置光标宽度）</span><br><span class="line">  -cursc CURSORCOLOR, --cursorcolor CURSORCOLOR</span><br><span class="line">                        cursor color (r, b, g, p)（设置光标颜色）</span><br><span class="line">  -cellw CELLWIDTH, --cellwidth CELLWIDTH</span><br><span class="line">                        set cell width (px or %)（单元的宽度）</span><br><span class="line">  -lineh LINEHEIGHT, --lineheight LINEHEIGHT</span><br><span class="line">                        code/text line-height (%)（行高）</span><br><span class="line">  -altp, --altprompt    alt input prompt style</span><br><span class="line">  -altmd, --altmarkdown</span><br><span class="line">                        alt markdown cell style</span><br><span class="line">  -altout, --altoutput  set output bg color to notebook bg</span><br><span class="line">  -P, --hideprompt      hide cell input prompt</span><br><span class="line">  -T, --toolbar         make toolbar visible（工具栏可见）</span><br><span class="line">  -N, --nbname          nb name/logo visible</span><br><span class="line">  -vim, --vimext        toggle styles for vim</span><br><span class="line">  -r, --reset           reset to default theme（设置成默认主题）</span><br><span class="line">  -dfonts, --defaultfonts</span><br><span class="line">                        force fonts to browser default（设置成浏览器默认字体）</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>例如下面的命令完成效果：</p><p>使用的主题是：monokai，工具栏可见，命名笔记本的选项，代码的字体为13，代码的字体为consolamono。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# jt -t monokai -T -N -fs 13 -f consolamono</span><br></pre></td></tr></table></figure><p>如果jupyter进程已启，需要重新启进程后生效。</p><p>实现的效果截图：</p><p><img src="\images\picture\jupyter2.jpg" alt=""></p><p>其他主题效果大家可以自己尝试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;Jupyter notebook是数据科学常用的代码交互式工具。通常在server端启jupyter进程（web服务），client端打开浏
      
    
    </summary>
    
      <category term="jupyter_notebook" scheme="https://zjrongxiang.github.io/categories/jupyter-notebook/"/>
    
    
      <category term="jupyter notebook" scheme="https://zjrongxiang.github.io/tags/jupyter-notebook/"/>
    
  </entry>
  
  <entry>
    <title>树莓派：使用USB摄像头自制家庭监控</title>
    <link href="https://zjrongxiang.github.io/2018/03/18/2018-03-18-raspberry_usb_camera/"/>
    <id>https://zjrongxiang.github.io/2018/03/18/2018-03-18-raspberry_usb_camera/</id>
    <published>2018-03-18T11:30:00.000Z</published>
    <updated>2018-04-04T14:31:39.756Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树莓派摄像头和USB摄像头"><a href="#树莓派摄像头和USB摄像头" class="headerlink" title="树莓派摄像头和USB摄像头"></a>树莓派摄像头和USB摄像头</h3><blockquote><p>树莓派有配套的摄像头模块（Raspberry Pi camera board），如下图。</p><p>另外树莓派也支持USB摄像头。关于树莓派支持的USB摄像头有个<a href="https://elinux.org/RPi_USB_Webcams" target="_blank" rel="noopener">清单参考</a>（需要梯子）。大家购买前最好确认一下是否在兼容清单中。</p></blockquote><p><img src="\images\picture\camera_pi.png" alt="camera_pi"></p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><h4 id="第一步：检查USB摄像头和树莓派的兼容性"><a href="#第一步：检查USB摄像头和树莓派的兼容性" class="headerlink" title="第一步：检查USB摄像头和树莓派的兼容性"></a>第一步：检查USB摄像头和树莓派的兼容性</h4><p>将USB摄像头和树莓派连接，查看USB接口连接情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/# lsusb</span><br><span class="line">Bus 001 Device 004: ID 046d:0825 Logitech, Inc. Webcam C270</span><br><span class="line">Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet Adapter</span><br><span class="line">Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp.</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure><p>发现004口上面连接并识别了摄像头（我的是Logitech 270摄像头）。</p><blockquote><p>如果没有识别出来，需要查看USB兼容清单是否有该型号。另外由于树莓派供电功率较小，也有可能是USB供电功率不足，需要有外置电源的USB摄像头。</p></blockquote><p>另外还可以查看设备驱动情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/# ls /dev/vid*</span><br><span class="line">/dev/video0</span><br></pre></td></tr></table></figure><p>发现video0设备，说明识别了USB摄像头（罗技的c270i）</p><h4 id="第二步：MOTION软件实现"><a href="#第二步：MOTION软件实现" class="headerlink" title="第二步：MOTION软件实现"></a>第二步：MOTION软件实现</h4><p>对于USB摄像头，有多种软件包可以实现拍照和摄像等功能，这里使用<a href="https://github.com/Motion-Project/motion" target="_blank" rel="noopener">motion</a>。</p><h5 id="安装motion"><a href="#安装motion" class="headerlink" title="安装motion"></a>安装motion</h5>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/# sudo apt-get install motion</span><br></pre></td></tr></table></figure><h5 id="编辑配置配置文件"><a href="#编辑配置配置文件" class="headerlink" title="编辑配置配置文件"></a>编辑配置配置文件</h5>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# vi /etc/motion/motion.conf</span><br></pre></td></tr></table></figure><h5 id="调整相关参数"><a href="#调整相关参数" class="headerlink" title="调整相关参数"></a>调整相关参数</h5>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> The mini-http server listens to this port for requests (default: 0 = disabled)</span><br><span class="line">stream_port 8082</span><br><span class="line"><span class="meta">#</span> web界面访问端口</span><br><span class="line"><span class="meta">#</span> TCP/IP port for the http server to listen on (default: 0 = disabled)</span><br><span class="line">webcontrol_port 8080</span><br><span class="line"><span class="meta">#</span>控制端口</span><br><span class="line"><span class="meta">#</span> Restrict control connections to localhost only (default: on)</span><br><span class="line">webcontrol_localhost off</span><br><span class="line"><span class="meta">#</span> Target base directory for pictures and films</span><br><span class="line"><span class="meta">#</span> Recommended to use absolute path. (Default: current working directory)</span><br><span class="line">target_dir /var/lib/motion</span><br><span class="line"><span class="meta">#</span>照片及视频存放路径</span><br></pre></td></tr></table></figure><p>其他参数调整如下：</p><p>​          <em>ffmpeg_output_movies</em>=off</p><p>​           <em>stream_localhost</em>=off</p><p>​           <em>webcontrol_localhost</em>=off</p><p>  ​         <em>locate_motion_mode</em>=peview</p><p>  ​         <em>locate_motion_style</em>=redbox</p><p>​           <em>text_changes</em>=on</p><h5 id="开启motion进程"><a href="#开启motion进程" class="headerlink" title="开启motion进程"></a>开启motion进程</h5><p>修改motion文件，设置为守护进程运行（即参数配置为：yes）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> vi /etc/default/motion</span><br><span class="line"><span class="meta">#</span> set to 'yes' to enable the motion daemon</span><br><span class="line">start_motion_daemon=yes</span><br></pre></td></tr></table></figure><p>启进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/etc/init.d# motion start</span><br><span class="line">[0] [NTC] [ALL] conf_load: Processing thread 0 - config file /etc/motion/motion.conf</span><br><span class="line">[0] [ALR] [ALL] conf_cmdparse: Unknown config option "sdl_threadnr"</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Motion 3.2.12+git20140228 Started</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Logging to syslog</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Using log type (ALL) log level (NTC)</span><br><span class="line">[0] [NTC] [ALL] become_daemon: Motion going to daemon mode</span><br></pre></td></tr></table></figure><h5 id="查看监控画面"><a href="#查看监控画面" class="headerlink" title="查看监控画面"></a>查看监控画面</h5><p>地址栏中输入地址和端口号（IP：8082），上面配置的web界面访问端口为8082：</p><p><img src="\images\picture\example.png" alt=""></p><h5 id="查看监控数据存放目录"><a href="#查看监控数据存放目录" class="headerlink" title="查看监控数据存放目录"></a>查看监控数据存放目录</h5><p>另外目录/var/lib/motion中存放历史数据。</p><h4 id="第三步：内网穿透（外网访问web监控界面）"><a href="#第三步：内网穿透（外网访问web监控界面）" class="headerlink" title="第三步：内网穿透（外网访问web监控界面）"></a>第三步：内网穿透（外网访问web监控界面）</h4><p>实现上面的步骤，你只能在家里本地局域网访问监控界面，意义不大。</p><p>由于目前中国宽带服务公司都不会给家庭网络外网地址。所以需要内网穿透，实现外网访问家庭内网。</p><p>具体可以使用frp软件实现内网穿透。具体做法参考的博客中另一篇介绍frp的分享文章。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>【1】 <a href="https://www.bouvet.no/bouvet-deler/utbrudd/building-a-motion-activated-security-camera-with-the-raspberry-pi-zero" target="_blank" rel="noopener">https://www.bouvet.no/bouvet-deler/utbrudd/building-a-motion-activated-security-camera-with-the-raspberry-pi-zero</a></p><p>【2】 <a href="https://medium.com/@Cvrsor/how-to-make-a-diy-home-alarm-system-with-a-raspberry-pi-and-a-webcam-2d5a2d61da3d" target="_blank" rel="noopener">https://medium.com/@Cvrsor/how-to-make-a-diy-home-alarm-system-with-a-raspberry-pi-and-a-webcam-2d5a2d61da3d</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;树莓派摄像头和USB摄像头&quot;&gt;&lt;a href=&quot;#树莓派摄像头和USB摄像头&quot; class=&quot;headerlink&quot; title=&quot;树莓派摄像头和USB摄像头&quot;&gt;&lt;/a&gt;树莓派摄像头和USB摄像头&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;树莓派有配套的摄像头模块（
      
    
    </summary>
    
      <category term="raspberry" scheme="https://zjrongxiang.github.io/categories/raspberry/"/>
    
    
      <category term="raspberry" scheme="https://zjrongxiang.github.io/tags/raspberry/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu系统版本信息查询</title>
    <link href="https://zjrongxiang.github.io/2018/03/14/2018-03-15-ubuntu_ssh_ip_OK/"/>
    <id>https://zjrongxiang.github.io/2018/03/14/2018-03-15-ubuntu_ssh_ip_OK/</id>
    <published>2018-03-14T11:30:00.000Z</published>
    <updated>2018-04-06T03:38:28.720Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要汇总查询Ubuntu系统的信息的相关命令及展示案例。</p><p>会持续更新。</p><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><h4 id="查看：CPU信息"><a href="#查看：CPU信息" class="headerlink" title="查看：CPU信息"></a>查看：CPU信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# cat /proc/version</span><br><span class="line">Linux version 4.13.0-37-generic (buildd@lcy01-amd64-012) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9)) #42~16.04.1-Ubuntu SMP Wed Mar 7 16:03:28 UTC 2018</span><br></pre></td></tr></table></figure><h4 id="查看：内核、操作系统、CPU信息"><a href="#查看：内核、操作系统、CPU信息" class="headerlink" title="查看：内核、操作系统、CPU信息"></a>查看：内核、操作系统、CPU信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# uname -a</span><br><span class="line">Linux deeplearning 4.13.0-37-generic #42~16.04.1-Ubuntu SMP Wed Mar 7 16:03:28 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><h4 id="查看：操作系统版本信息"><a href="#查看：操作系统版本信息" class="headerlink" title="查看：操作系统版本信息"></a>查看：操作系统版本信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 16.04.4 LTS</span><br><span class="line">Release:        16.04</span><br><span class="line">Codename:       xenial</span><br></pre></td></tr></table></figure><h4 id="查看：计算机名"><a href="#查看：计算机名" class="headerlink" title="查看：计算机名"></a>查看：计算机名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# hostname</span><br><span class="line">vultr.guest</span><br></pre></td></tr></table></figure><h3 id="资源信息"><a href="#资源信息" class="headerlink" title="资源信息"></a>资源信息</h3><h4 id="查看：存储分区的使用信息"><a href="#查看：存储分区的使用信息" class="headerlink" title="查看：存储分区的使用信息"></a>查看：存储分区的使用信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            469M     0  469M   0% /dev</span><br><span class="line">tmpfs            99M   11M   89M  11% /run</span><br><span class="line">/dev/vda1        25G   12G   12G  49% /</span><br><span class="line">tmpfs           495M     0  495M   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           495M     0  495M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs            99M     0   99M   0% /run/user/0</span><br></pre></td></tr></table></figure><h4 id="查看：系统运行时间、用户数量"><a href="#查看：系统运行时间、用户数量" class="headerlink" title="查看：系统运行时间、用户数量"></a>查看：系统运行时间、用户数量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# uptime</span><br><span class="line"> 23:04:54 up 10 days, 17:21,  1 user,  load average: 0.21, 0.06, 0.02</span><br></pre></td></tr></table></figure><h3 id="磁盘信息"><a href="#磁盘信息" class="headerlink" title="磁盘信息"></a>磁盘信息</h3><h4 id="查看-所有分区信息"><a href="#查看-所有分区信息" class="headerlink" title="查看:所有分区信息"></a>查看:所有分区信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# fdisk -l</span><br><span class="line">Disk /dev/vda: 25 GiB, 26843545600 bytes, 52428800 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0xcb855d49</span><br><span class="line"></span><br><span class="line">Device     Boot Start      End  Sectors Size Id Type</span><br><span class="line">/dev/vda1  *     2048 52428257 52426210  25G 83 Linux</span><br></pre></td></tr></table></figure><h3 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h3><h4 id="查看：网络接口信息"><a href="#查看：网络接口信息" class="headerlink" title="查看：网络接口信息"></a>查看：网络接口信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# ifconfig</span><br><span class="line"><span class="meta">#</span>（略）</span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 198660  bytes 27478459 (27.4 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 198660  bytes 27478459 (27.4 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><h4 id="查看：防火墙信息"><a href="#查看：防火墙信息" class="headerlink" title="查看：防火墙信息"></a>查看：防火墙信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# iptables -L</span><br><span class="line">Chain DOCKER-USER (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">RETURN     all  --  anywhere             anywhere</span><br></pre></td></tr></table></figure><h4 id="查看：路由表"><a href="#查看：路由表" class="headerlink" title="查看：路由表"></a>查看：路由表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">#（略）</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br></pre></td></tr></table></figure><h4 id="查看：监听端口、已经建立的连接"><a href="#查看：监听端口、已经建立的连接" class="headerlink" title="查看：监听端口、已经建立的连接"></a>查看：监听端口、已经建立的连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# netstat -lntp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      749/sshd</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# netstat -antp</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      749/sshd</span><br></pre></td></tr></table></figure><h4 id="查看：网络统计信息"><a href="#查看：网络统计信息" class="headerlink" title="查看：网络统计信息"></a>查看：网络统计信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# netstat -s</span><br><span class="line">Ip:</span><br><span class="line">    Forwarding: 1</span><br><span class="line">    5729182 total packets received</span><br><span class="line">    9 with invalid addresses</span><br><span class="line">#略信息</span><br></pre></td></tr></table></figure><h3 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h3><h4 id="查看：所有进程信息"><a href="#查看：所有进程信息" class="headerlink" title="查看：所有进程信息"></a>查看：所有进程信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# ps -ef </span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 Mar25 ?        00:00:44 /sbin/init</span><br></pre></td></tr></table></figure><h4 id="查看：实时显示进程状态"><a href="#查看：实时显示进程状态" class="headerlink" title="查看：实时显示进程状态"></a>查看：实时显示进程状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# top</span><br><span class="line">top - 23:24:19 up 10 days, 17:41,  1 user,  load average: 0.02, 0.02, 0.00</span><br><span class="line">Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.7 us,  0.3 sy,  0.0 ni, 99.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1012392 total,    74384 free,   270236 used,   667772 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   556896 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                 </span><br><span class="line">25691 root      20   0  554760  13348   3448 S  0.3  1.3  35:21.42 docker-containe </span><br><span class="line">#（略信息）</span><br></pre></td></tr></table></figure><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><h4 id="查看：活动用户"><a href="#查看：活动用户" class="headerlink" title="查看：活动用户"></a>查看：活动用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# w</span><br><span class="line"> 23:25:22 up 10 days, 17:42,  1 user,  load average: 0.33, 0.08, 0.02</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/0    140.31.74.0      22:59    2.00s  0.06s  0.00s w</span><br></pre></td></tr></table></figure><h4 id="查看：用户登录日志信息"><a href="#查看：用户登录日志信息" class="headerlink" title="查看：用户登录日志信息"></a>查看：用户登录日志信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# last</span><br><span class="line">root     pts/0        113.41.56.0      Wed Apr  4 22:59   still logged in</span><br><span class="line">root     pts/0        113.41.56.0      Wed Apr  4 08:37 - 13:38  (05:00)</span><br><span class="line"></span><br><span class="line">wtmp begins Sun Apr  1 19:59:32 2018</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客主要汇总查询Ubuntu系统的信息的相关命令及展示案例。&lt;/p&gt;
&lt;p&gt;会持续更新。&lt;/p&gt;
&lt;h3 id=&quot;系统信息&quot;&gt;&lt;a href=&quot;#系统信息&quot; class=&quot;headerlink&quot; title=&quot;系统信息&quot;&gt;&lt;/a&gt;系统信息&lt;/h3&gt;&lt;h4 id=&quot;查看：
      
    
    </summary>
    
      <category term="ubuntu" scheme="https://zjrongxiang.github.io/categories/ubuntu/"/>
    
    
      <category term="Ubuntu" scheme="https://zjrongxiang.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu添加国内apt更新源</title>
    <link href="https://zjrongxiang.github.io/2018/03/14/2018-03-15-ubuntu_apt_change/"/>
    <id>https://zjrongxiang.github.io/2018/03/14/2018-03-15-ubuntu_apt_change/</id>
    <published>2018-03-14T11:30:00.000Z</published>
    <updated>2018-04-06T03:43:41.473Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要介绍如何更改Ubuntu系统的apt源。</p><h3 id="关于源"><a href="#关于源" class="headerlink" title="关于源"></a>关于源</h3><p>我们使用apt安装软件时，会到国外源下载软件包。但是由于各种原因（你懂的）国外站点到国内的下载速度非常缓慢，甚至1k/s。对于大的包，这是无法忍受的等待，经常会超时中断。所以我们换成国内的源站点。其中口碑比较好的源站点有：阿里源、清华源、中科大源等。</p><p>Ubuntu系统的源地址文件位置：/etc/apt/sources.list</p><h3 id="更换步骤"><a href="#更换步骤" class="headerlink" title="更换步骤"></a>更换步骤</h3><h4 id="第一步：备份"><a href="#第一步：备份" class="headerlink" title="第一步：备份"></a>第一步：备份</h4><blockquote><p>对于系统文件的修改建议实施备份。养成良好的变更习惯。关键时候能救命。</p><p>关于备份文件命名有两个建议：（1）含有backup字段提示为备份文件；（2）含有备份日期，便于区分多个备份。当然如果是多用户话应该含有用户名，便于区分。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# cp /etc/apt/sources.list /etc/apt/sources.list.backup.20180315</span><br></pre></td></tr></table></figure><h4 id="第二步：添加源地址"><a href="#第二步：添加源地址" class="headerlink" title="第二步：添加源地址"></a>第二步：添加源地址</h4><blockquote><p>我们添加<a href="https://opsx.alibaba.com/" target="_blank" rel="noopener">阿里源</a>， 进入阿里云开源镜像站，找到ubuntu的帮助信息：</p><p>我们版本号Ubuntu 16.04.4 LTS，并且Codename: xenial。需要根据自己的版本对应相应的源。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure><p>直接将source.list中内容用上面的源地址内容替换，保存后退出。更新源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# apt-get update</span><br></pre></td></tr></table></figure><h3 id="附录：apt的常用操作命令清单"><a href="#附录：apt的常用操作命令清单" class="headerlink" title="附录：apt的常用操作命令清单"></a>附录：apt的常用操作命令清单</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  更新源</span><br><span class="line">sudo apt-get install package 安装包</span><br><span class="line">sudo apt-get remove package 删除包</span><br><span class="line">sudo apt-cache search package 搜索软件包</span><br><span class="line">sudo apt-cache show package  获取包的相关信息，如说明、大小、版本等</span><br><span class="line">sudo apt-get install package --reinstall  重新安装包</span><br><span class="line">sudo apt-get -f install  修复安装</span><br><span class="line">sudo apt-get remove package --purge 删除包，包括配置文件等</span><br><span class="line">sudo apt-get build-dep package 安装相关的编译环境</span><br><span class="line">sudo apt-get upgrade 更新已安装的包</span><br><span class="line">sudo apt-get dist-upgrade 升级系统</span><br><span class="line">sudo apt-cache depends package 了解使用该包依赖那些包</span><br><span class="line">sudo apt-cache rdepends package 查看该包被哪些包依赖</span><br><span class="line">sudo apt-get source package  下载该包的源代码</span><br><span class="line">sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包</span><br><span class="line">sudo apt-get check 检查是否有损坏的依赖</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客主要介绍如何更改Ubuntu系统的apt源。&lt;/p&gt;
&lt;h3 id=&quot;关于源&quot;&gt;&lt;a href=&quot;#关于源&quot; class=&quot;headerlink&quot; title=&quot;关于源&quot;&gt;&lt;/a&gt;关于源&lt;/h3&gt;&lt;p&gt;我们使用apt安装软件时，会到国外源下载软件包。但是由于各种原因
      
    
    </summary>
    
      <category term="ubuntu" scheme="https://zjrongxiang.github.io/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="https://zjrongxiang.github.io/tags/ubuntu/"/>
    
      <category term="apt" scheme="https://zjrongxiang.github.io/tags/apt/"/>
    
      <category term="mirrors" scheme="https://zjrongxiang.github.io/tags/mirrors/"/>
    
  </entry>
  
  <entry>
    <title>动手实现深度学习相机</title>
    <link href="https://zjrongxiang.github.io/2018/03/14/2018-03-14-deeplearning_camera/"/>
    <id>https://zjrongxiang.github.io/2018/03/14/2018-03-14-deeplearning_camera/</id>
    <published>2018-03-14T11:30:00.000Z</published>
    <updated>2018-03-14T12:13:33.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017年年底，亚马逊（AWS）宣布将推出深度学习相机——<a href="https://www.amazon.com/AWS-DeepLens-learning-enabled-developers/dp/B075Y3CK37" target="_blank" rel="noopener">DeepLens </a> ，亚马逊官网已经开始预售，预计6月14日发货。但是售价为249刀（约1600人民币）。偏贵了。</p><p>具体介绍可以参考这篇文章：<a href="http://blog.csdn.net/R1uNW1W/article/details/78699883" target="_blank" rel="noopener">AWS深度学习摄像头，将对机器学习产业有何影响？</a></p></blockquote><p>看到有人利用树莓派和简易摄像头实现了一个深度学习相机，用来检测院子里面小鸟吃食。正好自己有一个树莓派，可以参考玩一下。进一步优化甚至可以放在家门口，对访客人脸识别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;2017年年底，亚马逊（AWS）宣布将推出深度学习相机——&lt;a href=&quot;https://www.amazon.com/AWS-DeepLens-learning-enabled-developers/dp/B075Y3CK37&quot; target=
      
    
    </summary>
    
      <category term="deep learning" scheme="https://zjrongxiang.github.io/categories/deep-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>动手实现Ubuntu系统WOL远程唤醒</title>
    <link href="https://zjrongxiang.github.io/2018/03/14/2018-03-14-ubuntu_wol/"/>
    <id>https://zjrongxiang.github.io/2018/03/14/2018-03-14-ubuntu_wol/</id>
    <published>2018-03-14T11:30:00.000Z</published>
    <updated>2018-04-09T04:49:10.526Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要介绍通过局域网唤醒服务器（远程启动计算机）。作者具体在Ubuntu操作系统上实现。</p><blockquote><p>目前中国家庭宽带网络都是没有外网IP的，如果外网访问家庭网络，需要做端口映射，实现远程访问。</p></blockquote><h3 id="什么是WoL（Wake-on-LAN）"><a href="#什么是WoL（Wake-on-LAN）" class="headerlink" title="什么是WoL（Wake on LAN）"></a>什么是WoL（Wake on LAN）</h3><p>电脑处在关机（或休眠）状态时，只要主机保持连接电源、网线连接网卡，其实网卡和主板仍然有微弱供电。这部分供电能让网卡监听和解读来自外部网络的广播信息。</p><p>其中会对一种特殊的广播信息——Magic Packet（魔法数据包）进行侦测。Magic Packet网络包以广播的形式发送，发送的范围可以是整个局域网或者指定的子网。另外Magic Packet中唤醒服务器IP可以是多个，侦测主机一旦发现包中的唤醒IP集中包含自己的IP，会通知主板、电源供电器，开始执行唤醒，打开机器。</p><h3 id="检查主机板块和网卡是否支持Wol"><a href="#检查主机板块和网卡是否支持Wol" class="headerlink" title="检查主机板块和网卡是否支持Wol"></a>检查主机板块和网卡是否支持Wol</h3><ul><li>BOIS </li><li>网卡（NIC）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@deeplearning:/# ethtool enp0s31f6</span><br></pre></td></tr></table></figure><p>其中有下面的字段信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supports Wake-on: pumbg</span><br><span class="line">Wake-on: g</span><br></pre></td></tr></table></figure><h3 id="具体部署步骤"><a href="#具体部署步骤" class="headerlink" title="具体部署步骤"></a>具体部署步骤</h3><p>需要安装wakeonlan包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# sudo apt-get install wakeonlan</span><br></pre></td></tr></table></figure><p>下面的命令通过树莓派发送魔术包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# wakeonlan -i 192.168.1.3 b0:6f:bf:b0:9f:2f</span><br><span class="line">Sending magic packet to 192.168.1.3:9 with b0:6f:b0:bf:9f:2f</span><br></pre></td></tr></table></figure><h3 id="ARP缓存及设置静态ARP"><a href="#ARP缓存及设置静态ARP" class="headerlink" title="ARP缓存及设置静态ARP"></a>ARP缓存及设置静态ARP</h3><p>在网关配置ARP信息（IP与物理地址进行绑定）</p><p>发送网段的广播：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# wakeonlan -i 192.168.1.0 b0:6f:bf:b0:9f:2f</span><br><span class="line">Sending magic packet to 192.168.1.0:9 with b0:6f:b0:bf:9f:2f</span><br></pre></td></tr></table></figure><p><a href="https://help.ubuntu.com/community/WakeOnLan" target="_blank" rel="noopener">https://help.ubuntu.com/community/WakeOnLan</a></p><p>wiki</p><p><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E5%96%9A%E9%86%92" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E5%96%9A%E9%86%92</a></p><p><a href="https://en.wikipedia.org/wiki/Wake-on-LAN" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Wake-on-LAN</a></p><p><a href="http://softsmith.blogspot.com/2014/05/ubuntu-wake-on-lan.html" target="_blank" rel="noopener">http://softsmith.blogspot.com/2014/05/ubuntu-wake-on-lan.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客主要介绍通过局域网唤醒服务器（远程启动计算机）。作者具体在Ubuntu操作系统上实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前中国家庭宽带网络都是没有外网IP的，如果外网访问家庭网络，需要做端口映射，实现远程访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 
      
    
    </summary>
    
      <category term="ubuntu" scheme="https://zjrongxiang.github.io/categories/ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>树莓派：搭建家庭内网穿透服务器（frp实现）</title>
    <link href="https://zjrongxiang.github.io/2018/03/01/2018-03-12-raspberry_frp/"/>
    <id>https://zjrongxiang.github.io/2018/03/01/2018-03-12-raspberry_frp/</id>
    <published>2018-03-01T11:30:00.000Z</published>
    <updated>2019-01-13T08:05:48.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h3><p>对于目前家庭网络，有下面两个迫切需求：</p><ul><li>需要远程（比如在单位、路途等）SSH访问家里PC服务器、后续实现远程唤醒服务器。</li></ul><ul><li>后续部署自制家庭监控，需要远程访问监控web界面。</li></ul><p>鉴于上面的需求，技术上需要实现外网访问内网（即内网穿透）。下面详细介绍具体实现步骤。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a><strong>环境准备</strong></h3><ul><li><p><strong>一台树莓派主机</strong>。由于耗电较少，适合长期开机，作为中转服务器。</p></li><li><p><strong>一个公网IP</strong>。由于电信宽带不提供公网IP，只能自己想办法。正好有一台外网VPS服务器（独有公网IP）</p></li></ul><blockquote><p>另外顺便打个不收钱的广告：VPS可以使用<a href="https://www.vultr.com/?ref=7252538" target="_blank" rel="noopener">vultr</a>的虚机，支持支付宝，非常方便。</p></blockquote><h3 id="FRP介绍"><a href="#FRP介绍" class="headerlink" title="FRP介绍"></a><strong>FRP介绍</strong></h3><p>实现内网穿透有很多方法：frp软件、ngrok软件、还有花生壳。关于frp有详细的<a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">官方介绍文档</a> ，不再赘述。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a><strong>实现步骤</strong></h3><h4 id="第一步：配置VPS服务器"><a href="#第一步：配置VPS服务器" class="headerlink" title="第一步：配置VPS服务器"></a><strong>第一步：配置VPS服务器</strong></h4><p>VPS操作系统为Ubuntu，下载linux_amd64版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# wget https://github.com/fatedier/frp/releases/download/v0.16.1/frp_0.16.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~# tar -zxvf frp_0.16.1_linux_amd64.tar.gz</span><br><span class="line">frp_0.16.1_linux_amd64/</span><br><span class="line">frp_0.16.1_linux_amd64/frpc_full.ini</span><br><span class="line">frp_0.16.1_linux_amd64/LICENSE</span><br><span class="line">frp_0.16.1_linux_amd64/frpc.ini</span><br><span class="line">frp_0.16.1_linux_amd64/frps.ini</span><br><span class="line">frp_0.16.1_linux_amd64/frpc</span><br><span class="line">frp_0.16.1_linux_amd64/frps_full.ini</span><br><span class="line">frp_0.16.1_linux_amd64/frps</span><br><span class="line">root@vultr:~# cd frp_0.16.1_linux_amd64/</span><br><span class="line">root@vultr:~/frp_0.16.1_linux_amd64# ls</span><br><span class="line">frpc  frpc_full.ini  frpc.ini  frps  frps_full.ini  frps.ini  LICENSE</span><br></pre></td></tr></table></figure><p>对于VPS服务端只有两个文件是需要的：<code>frps</code> （服务）和<code>frps.ini</code> （配置文件）是需要的，我们拷贝到<code>/bin</code>目录下面（这一步主要是集中放在bin目录便于管理）。</p><blockquote><p><code>frpc</code> 和<code>frpc.ini</code>是客户端服务和配置文件，后面介绍。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~/frp_0.16.1_linux_amd64# cp frps /bin/frps</span><br><span class="line">root@vultr:~/frp_0.16.1_linux_amd64# cp frps.ini /bin/frps.ini</span><br></pre></td></tr></table></figure><p>然后对配置文件进行修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:/bin# vi frps.ini</span><br><span class="line"><span class="meta">#</span>修改配置文件</span><br><span class="line">[common]</span><br><span class="line">bind_addr = 10.66.2.137</span><br><span class="line"><span class="meta">#</span>VPS公网IP地址（为了保护隐私，上面地址是虚构的）</span><br><span class="line">bind_port = 7000</span><br><span class="line"><span class="meta">#</span>frp服务端口，用户自己定于一个空闲端口（不要和其他应用服务端口冲突）。需要注意的是必须与frpc.ini相同</span><br><span class="line">vhost_http_port = 80</span><br><span class="line"><span class="meta">#</span>http服务端口</span><br><span class="line">vhost_https_port = 443</span><br><span class="line"><span class="meta">#</span>https服务端口</span><br><span class="line">dashboard_port = 7500</span><br><span class="line"><span class="meta">#</span>web控制台端口，10.66.2.137：7500可以访问控制界面</span><br><span class="line"><span class="meta">#</span>下面两个参数是控制界面的用户名和密码</span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = Password123！</span><br><span class="line"></span><br><span class="line">privilege_token = Password123！</span><br><span class="line"><span class="meta">#</span>特权模式密钥，需与frpc.ini相同</span><br><span class="line"></span><br><span class="line">log_file = /bin/frps_log/frps.log</span><br><span class="line"><span class="meta">#</span>日志文件存储路径</span><br><span class="line">log_level = info</span><br><span class="line"><span class="meta">#</span>日志记录级别</span><br><span class="line">log_max_days = 7</span><br><span class="line"><span class="meta">#</span>日志最大存储天数</span><br><span class="line">max_pool_count = 5</span><br><span class="line"><span class="meta">#</span>后端连接池最大连接数量</span><br><span class="line"><span class="meta">#</span>口令超时时间</span><br><span class="line">authentication_timeout = 900</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>subdomain_host = frp.com    #服务端绑定域名</span><br><span class="line">tcp_mux = true</span><br></pre></td></tr></table></figure><p>保存修改后的配置文件，后台启服务端进程，下面是命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:/bin# nohup ./frps -c ./frps.ini &amp;</span><br><span class="line"><span class="meta">#</span>查看服务进程：</span><br><span class="line">root@vultr:/bin# ps -ef|grep frp</span><br><span class="line">root      1339     1  0 Mar25 ?        00:03:54 ./frps -c ./frps.ini</span><br><span class="line">root      5320  4958  0 11:42 pts/1    00:00:00 grep --color=auto frp</span><br></pre></td></tr></table></figure><p>以上完成服务端配置。</p><h4 id="第二步：配置树莓派客户端"><a href="#第二步：配置树莓派客户端" class="headerlink" title="第二步：配置树莓派客户端"></a><strong>第二步：配置树莓派客户端</strong></h4><blockquote><p>注意：树莓派的CPU处理器是ARM的，所以注意下载的版本包。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# wget https://github.com/fatedier/frp/releases/download/v0.16.1/frp_0.16.1_linux_arm.tar.gz</span><br></pre></td></tr></table></figure><p>解压缩下载的包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# tar -zxvf frp_0.16.1_linux_arm.tar.gz </span><br><span class="line">frp_0.16.1_linux_arm/</span><br><span class="line">frp_0.16.1_linux_arm/frpc_full.ini</span><br><span class="line">frp_0.16.1_linux_arm/LICENSE</span><br><span class="line">frp_0.16.1_linux_arm/frpc.ini</span><br><span class="line">frp_0.16.1_linux_arm/frps.ini</span><br><span class="line">frp_0.16.1_linux_arm/frpc</span><br><span class="line">frp_0.16.1_linux_arm/frps_full.ini</span><br><span class="line">frp_0.16.1_linux_arm/frps</span><br><span class="line">root@raspberrypi:~# cd frp_0.16.1_linux_arm</span><br><span class="line">root@raspberrypi:~/frp_0.16.1_linux_arm# ls</span><br><span class="line">frpc  frpc_full.ini  frpc.ini  frps  frps_full.ini  frps.ini  LICENSE</span><br></pre></td></tr></table></figure><p>类似服务端操作将<code>frpc</code>和<code>frpc.ini</code>拷贝到<code>/bin</code>目录下面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~/frp_0.16.1_linux_arm# cp frpc /bin/frpc</span><br><span class="line">root@raspberrypi:~/frp_0.16.1_linux_arm# cp frpc.ini /bin/frpc.ini</span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/bin# vi frpc.ini</span><br><span class="line"><span class="meta">#</span>修改客户端配置文件</span><br><span class="line">[common]</span><br><span class="line">server_addr = 10.66.2.137</span><br><span class="line"><span class="meta">#</span>VPS公网IP地址（为了保护隐私，上面地址是虚构的）</span><br><span class="line">server_port = 7000</span><br><span class="line">privilege_token = Password123！</span><br><span class="line"></span><br><span class="line">log_file = /bin/frpc.log</span><br><span class="line"><span class="meta">#</span>日志目录</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 7</span><br><span class="line">pool_count = 5</span><br><span class="line">tcp_mux = true</span><br><span class="line"><span class="meta">#</span>配置SSH端口映射</span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line"><span class="meta">#</span>本地端口</span><br><span class="line">local_port = 22</span><br><span class="line"><span class="meta">#</span>映射端口</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 80</span><br><span class="line">use_encryption = false</span><br><span class="line">use_compression = true</span><br><span class="line">subdomain = web</span><br><span class="line"><span class="meta">#</span>所绑定的公网服务器域名，一级、二级域名都可以。这里没有就不用配置了</span><br><span class="line">custom_domains = web.frp.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>远程监控端口映射</span><br><span class="line">[motion]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 8082</span><br><span class="line">remote_port = 8000</span><br></pre></td></tr></table></figure><p>保存修改，后台启客户端进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/bin# nohup ./frpc -c ./frpc.ini &amp;</span><br><span class="line">root@raspberrypi:/bin# ps -ef|grep frp</span><br><span class="line">root      4627     1  0 4月02 ?       00:05:19 ./frpc -c ./frpc.ini</span><br><span class="line">root     13731 13669  0 19:56 pts/0    00:00:00 grep frp</span><br></pre></td></tr></table></figure><h4 id="第三步：验证"><a href="#第三步：验证" class="headerlink" title="第三步：验证"></a><strong>第三步：验证</strong></h4><h5 id="FRP管理界面（http-公网IP-7500）"><a href="#FRP管理界面（http-公网IP-7500）" class="headerlink" title="FRP管理界面（http://公网IP:7500）"></a><strong>FRP管理界面（http://公网IP:7500）</strong></h5><p>显示两个端口映射都是online可用的：</p><p><img src="\images\picture\frp1.png" alt=""></p><p>下面是整体视图：</p><p><img src="\images\picture\frp2.png" alt=""></p><h5 id="SSH服务"><a href="#SSH服务" class="headerlink" title="SSH服务"></a><strong>SSH服务</strong></h5><p>我们已经将本地访问ssh的服务端口（192.168.1.2：22）映射到外网端口（10.66.2.137：6000）。</p><p>例如使用putty工具，IP地址填写：10.66.2.137，端口：6000。</p><p>连接后使用树莓派本地ssh用户和密码即可登录。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h3><p>[1]  FRP官方网站 <a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;对于目前家庭网络，有下面两个迫切需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要远程（比如在单位、路途等）SSH访问
      
    
    </summary>
    
      <category term="raspberry" scheme="https://zjrongxiang.github.io/categories/raspberry/"/>
    
    
      <category term="raspberry" scheme="https://zjrongxiang.github.io/tags/raspberry/"/>
    
      <category term="frp" scheme="https://zjrongxiang.github.io/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>树莓派：更改APT为国内源</title>
    <link href="https://zjrongxiang.github.io/2018/03/01/2018-03-12-raspberry_apt-get/"/>
    <id>https://zjrongxiang.github.io/2018/03/01/2018-03-12-raspberry_apt-get/</id>
    <published>2018-03-01T11:30:00.000Z</published>
    <updated>2018-04-05T13:47:23.086Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>发现树莓派wget国外源异常慢。其实可以更改为国内的apt源，不用走海下光缆啦。</p><h3 id="更改步骤"><a href="#更改步骤" class="headerlink" title="更改步骤"></a>更改步骤</h3><h4 id="编辑sources-list文件"><a href="#编辑sources-list文件" class="headerlink" title="编辑sources.list文件"></a>编辑sources.list文件</h4><p>还没安装我喜爱的vim，只能先用nano编辑文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:~# nano /etc/apt/sources.list</span><br></pre></td></tr></table></figure><h4 id="修改源"><a href="#修改源" class="headerlink" title="修改源"></a>修改源</h4><p>将原始的源注释掉，添加阿里云的源地址（在这里感谢阿里爸爸）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contrib rpi</span><br><span class="line">deb-src http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contrib rpi</span><br></pre></td></tr></table></figure><h4 id="更软件索引清单"><a href="#更软件索引清单" class="headerlink" title="更软件索引清单"></a>更软件索引清单</h4><p>最后更新一下，以后就可以快速apt-get啦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;发现树莓派wget国外源异常慢。其实可以更改为国内的apt源，不用走海下光缆啦。&lt;/p&gt;
&lt;h3 id=&quot;更改步骤&quot;&gt;&lt;a href=&quot;#更
      
    
    </summary>
    
      <category term="raspberry" scheme="https://zjrongxiang.github.io/categories/raspberry/"/>
    
    
      <category term="raspberry" scheme="https://zjrongxiang.github.io/tags/raspberry/"/>
    
      <category term="apt-get" scheme="https://zjrongxiang.github.io/tags/apt-get/"/>
    
  </entry>
  
  <entry>
    <title>SAS 9.4 部署及SID文件调整</title>
    <link href="https://zjrongxiang.github.io/2018/02/06/2018-02-09-SAS_install/"/>
    <id>https://zjrongxiang.github.io/2018/02/06/2018-02-09-SAS_install/</id>
    <published>2018-02-06T11:30:00.000Z</published>
    <updated>2018-04-01T17:38:47.218Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要介绍个人部署SAS 9.4软件过程及安装过程中调整SID文件技巧。由于工作中经常使用SAS软件连接数据库查数，所以个人电脑准备也装备一下，部署过程分享给大家。</p><h4 id="第一部-下载SAS-9-4介质及安装"><a href="#第一部-下载SAS-9-4介质及安装" class="headerlink" title="第一部    下载SAS 9.4介质及安装"></a>第一部    下载SAS 9.4介质及安装</h4><p>相信大家的资源检索能力，肯定能找到可用的安装介质。</p><blockquote><p><em>介质可以参考一个网盘地址：<a href="http://pan.baidu.com/s/1qYz7ZNA" target="_blank" rel="noopener">http://pan.baidu.com/s/1qYz7ZNA</a> 密码：ulig</em></p></blockquote><p>解压缩后windows 直接执行setup.exe文件，linux 执行setup.sh文件执行命令：sh setup.sh。</p><p>然后选择安装语言、需要安装的组件、选择（32bit或64bit）等，不再赘述。</p><h4 id="第二部分-SID文件的导入"><a href="#第二部分-SID文件的导入" class="headerlink" title="第二部分  SID文件的导入"></a>第二部分  SID文件的导入</h4><blockquote><p><em>如果你有未过期的SID文件，直接导入后安装即可。下面主要介绍没有时咋办（本文介绍方法主要是个人学习使用哈，商业使用建议购买SID哈，毕竟不差钱）</em></p></blockquote><h5 id="1、闹心的方法"><a href="#1、闹心的方法" class="headerlink" title="1、闹心的方法"></a>1、闹心的方法</h5><p>首先找到旧的SID文件（授权时间已经过期），导入SID文件前，将操作系统修改为历史时间，然后顺利安装。但是每次使用SAS都要将系统时间后调，否则没法启动SAS正常使用。确实很闹心，而且修改系统时间后很多软件会提示异常，比如浏览器等。</p><h5 id="2、奇技淫巧"><a href="#2、奇技淫巧" class="headerlink" title="2、奇技淫巧"></a>2、奇技淫巧</h5><ul><li style="list-style: none"><input type="checkbox"> 其实认真查找SID文件，还是可以找到不过期的。</li></ul><blockquote><p><em>比如下面的链接：<a href="http://downloads.npust.edu.tw/otherFile/20170703022854.txt" target="_blank" rel="noopener">http://downloads.npust.edu.tw/otherFile/20170703022854.txt</a></em></p><p><em>过期时间为：30APR2018</em></p></blockquote><ul><li><p>[ ] 如果用这个SID提示无效或报错，这时候我们需要调整一下这个SID文件。</p><pre><code>- 在安装源文件目录中找到order.xml文件，我的目录为：~\SAS 9.4\order_data\99YYS5\order.xm。在文件中找到两个参数：setnumid=&quot;51200421&quot;、number=&quot;99YYS5&quot;</code></pre></li></ul><pre><code>- 将SID文件中下面两个参数调整和order文件中相同：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>调整后</span><br><span class="line">Order=99YYS5</span><br><span class="line">Setnumid=51200421</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>[ ] 最后重新加载SID文件，顺利安装。</p><pre><code>&gt; 另外如果还是报错可能是遇到别的坑了。。。。。</code></pre></li></ul><h4 id="第三部分-分享一个坑"><a href="#第三部分-分享一个坑" class="headerlink" title="第三部分  分享一个坑"></a>第三部分  分享一个坑</h4><p>作者部署平台是win7。所以涉及“C:\ Program Files”（<strong>存放64bit软件</strong>）和“C:\ Program Files(x86)”（<strong>存放32bit软件</strong>）。</p><p>而下载的SAS 9.4是32bit的，路径选择了“C:\ Program Files”，所以导入SID一直报错。</p><p>最后缓过神，调整了安装路径为“C:\ Program Files（x86）”（存放32bit软件的地方），最后顺利安装。</p><h4 id="第四部分-一点提示"><a href="#第四部分-一点提示" class="headerlink" title="第四部分  一点提示"></a>第四部分  一点提示</h4><p>SID文件中会有各个组件的授权，如果使用SAS软件部分组件无效，可能是SID文件中未有该组件的授权信息。下面是截取一个SID的授权组件的信息。例如有基础SAS 、SAS EG、还有SAS和oracle、Teradata连接的组件等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Base SAS31DEC2017</span><br><span class="line">SAS Enterprise Guide31DEC2017</span><br><span class="line">SAS Enterprise Miner Personal Client31DEC2017</span><br><span class="line">SAS/ACCESS Interface to Oracle31DEC2017</span><br><span class="line">SAS/ACCESS Interface to PC Files31DEC2017</span><br><span class="line">SAS/ACCESS Interface to Teradata31DEC2017</span><br></pre></td></tr></table></figure><p>例如：Interface to Oracle组件用来和oracle数据链接。连接后SAS EG客户端可以读取数据库中表，新建映射逻辑库就可以用SAS EG来做表操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客主要介绍个人部署SAS 9.4软件过程及安装过程中调整SID文件技巧。由于工作中经常使用SAS软件连接数据库查数，所以个人电脑准备也装备一下，部署过程分享给大家。&lt;/p&gt;
&lt;h4 id=&quot;第一部-下载SAS-9-4介质及安装&quot;&gt;&lt;a href=&quot;#第一部-下载SAS
      
    
    </summary>
    
      <category term="SAS install" scheme="https://zjrongxiang.github.io/categories/SAS-install/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu操作系统静态IP地址</title>
    <link href="https://zjrongxiang.github.io/2018/02/06/2018-02-25-Linux_ip/"/>
    <id>https://zjrongxiang.github.io/2018/02/06/2018-02-25-Linux_ip/</id>
    <published>2018-02-06T11:30:00.000Z</published>
    <updated>2018-04-01T17:38:57.157Z</updated>
    
    <content type="html"><![CDATA[<p>有一台Linux台式机（Ubuntu 16.04.3 LTS (GNU/Linux 4.13.0-32-generic x86_64)）。之前IP是DHCP服务分配的。准备给服务器分配静态IP，方便使用。</p><p>ubuntu的网络参数保存在文件/etc/network/interfaces中。</p><h4 id="1、编辑interfaces文件"><a href="#1、编辑interfaces文件" class="headerlink" title="1、编辑interfaces文件"></a>1、编辑interfaces文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/network/interfaces</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><h4 id="2、添加静态IP信息及DNS信息"><a href="#2、添加静态IP信息及DNS信息" class="headerlink" title="2、添加静态IP信息及DNS信息"></a>2、添加静态IP信息及DNS信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto enp0s31f6</span><br><span class="line">iface enp0s31f6 inet static</span><br><span class="line">address 192.168.31.62</span><br><span class="line">gateway 192.168.31.254</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">dns-nameservers 192.168.31.1 8.8.8.8</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有一台Linux台式机（Ubuntu 16.04.3 LTS (GNU/Linux 4.13.0-32-generic x86_64)）。之前IP是DHCP服务分配的。准备给服务器分配静态IP，方便使用。&lt;/p&gt;
&lt;p&gt;ubuntu的网络参数保存在文件/etc/networ
      
    
    </summary>
    
      <category term="Linux IP" scheme="https://zjrongxiang.github.io/categories/Linux-IP/"/>
    
    
  </entry>
  
  <entry>
    <title>Python标准库timeit的使用简介</title>
    <link href="https://zjrongxiang.github.io/2018/01/25/2018-01-25-Python-timeit/"/>
    <id>https://zjrongxiang.github.io/2018/01/25/2018-01-25-Python-timeit/</id>
    <published>2018-01-25T11:30:00.000Z</published>
    <updated>2018-04-01T17:38:22.827Z</updated>
    
    <content type="html"><![CDATA[<p>Python调试代码时，经常需要测算一些代码模块或函数的执行效率（即耗时）。常用手段会在代码前后分别用time.time()记下开始和结束的时间，然后相减获得执行耗时。</p><p> 本篇博客是一篇学习笔记，介绍Python一个内置模块实现代码执行计时。</p><h4 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h4><ul><li>timeit属于Python的标准库。文件路径在~Lib/timeit.py。</li><li>timeit同时具有<strong>命令行接口</strong>和<strong>可调用的函数接口</strong>。</li></ul><h4 id="一、命令行接口"><a href="#一、命令行接口" class="headerlink" title="一、命令行接口"></a>一、命令行接口</h4><p><strong>1、案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;python -m timeit <span class="string">'"-".join(str(n) for n in range(100))</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;100000 loops, best of 3: 14.1 usec per loop</span></span><br></pre></td></tr></table></figure><p>回显内容：语句<code>&quot;-&quot;.join(str(n) for n in range(100)</code>执行了10w次，平均耗时14.1 usec。</p><p><strong>2、接口参数说明</strong></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python -m timeit [-n N] [-r N] [-s S] [-t] [-c] [-h] [statement ...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#[-n N] 表示测试语句（statement）执行的次数。如果不指定，会连续执行10，100，1000，...即10的倍数次，直到总时间至少0.2秒，结束。</span></span><br><span class="line"><span class="comment">#[-r N] 计数器重复次数。默认是3。返回一个list，记录每次耗时。</span></span><br><span class="line"><span class="comment">#[-s S] statement之前前的初始化语句。默认为pass。</span></span><br><span class="line"><span class="comment">#[-t] 使用time.time()。</span></span><br><span class="line"><span class="comment">#[-c] 使用time.clock()。</span></span><br><span class="line"><span class="comment">#[-v] 会输出更多的执行过程信息。10次的耗时，1000次耗时，等等</span></span><br><span class="line"><span class="comment">#[-h] 单独使用，反馈接口的使用信息。</span></span><br></pre></td></tr></table></figure><p>注意：statement和[-s S]的参数按照字符串的形式传入。</p><h4 id="二、函数接口"><a href="#二、函数接口" class="headerlink" title="二、函数接口"></a>二、函数接口</h4><h5 id="1、类timeit-Timer"><a href="#1、类timeit-Timer" class="headerlink" title="1、类timeit.Timer"></a>1、类timeit.Timer</h5><ul><li>案例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"><span class="comment">#定义一个类</span></span><br><span class="line">t=timeit.Timer(<span class="string">'char in text'</span>,setup=<span class="string">'text="sample string";char="g"'</span>)</span><br><span class="line"><span class="comment">#timeit()函数</span></span><br><span class="line">t.timeit()</span><br><span class="line"><span class="comment">#回显：0.019882534000089436</span></span><br><span class="line"><span class="comment">#repeat()函数</span></span><br><span class="line">t.repeat()</span><br><span class="line"><span class="comment">#回显：[0.01990252700011297, 0.01574616299990339, 0.015739961000008407]</span></span><br></pre></td></tr></table></figure><ul><li>参数说明</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、初始化一个Timer类的参数：</span></span><br><span class="line">timeit.Timer(stmt=<span class="string">'pass'</span>, setup=<span class="string">'pass'</span>, timer=&lt;timer function&gt;)</span><br><span class="line"><span class="comment">#2、timeit(number=1000000)</span></span><br><span class="line"><span class="comment"># 默认number执行100w次。</span></span><br><span class="line"><span class="comment">#3、repeat(repeat=3，number=1000000)</span></span><br><span class="line"><span class="comment"># 默认执行100w次，重复3次（返回list）</span></span><br></pre></td></tr></table></figure><h5 id="2、两个函数"><a href="#2、两个函数" class="headerlink" title="2、两个函数"></a>2、两个函数</h5><ul><li>类似Timer的类，timeit也有两个函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、timeit函数</span></span><br><span class="line">timeit.timeit(stmt=<span class="string">"pass"</span>, setup=<span class="string">"pass"</span>, timer=default_timer,number=default_number)</span><br><span class="line"><span class="comment">#参数说明：stmt即statement，重复执行的语句。setup即执行前的初始化语句（执行一次）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2、repeat函数</span></span><br><span class="line">timeit.repeat(stmt=<span class="string">'pass'</span>, setup=<span class="string">'pass'</span>, timer=&lt;default timer&gt;, repeat=<span class="number">3</span>, number=<span class="number">1000000</span>)</span><br><span class="line"><span class="comment">#类似Timer类中函数。</span></span><br></pre></td></tr></table></figure><ul><li>案例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_example</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="string">"-"</span>.join(str(i))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(timeit.timeit(<span class="string">"test_example()"</span>, setup=<span class="string">"from __main__ import test_example"</span>))</span><br><span class="line"><span class="comment">#25.844697911000367</span></span><br></pre></td></tr></table></figure><p>例子中statement是个函数，重复执行前需要在setup中提前import。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python调试代码时，经常需要测算一些代码模块或函数的执行效率（即耗时）。常用手段会在代码前后分别用time.time()记下开始和结束的时间，然后相减获得执行耗时。&lt;/p&gt;
&lt;p&gt; 本篇博客是一篇学习笔记，介绍Python一个内置模块实现代码执行计时。&lt;/p&gt;
&lt;h4 
      
    
    </summary>
    
      <category term="Python" scheme="https://zjrongxiang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis学习笔记（数据类型及常用命令）</title>
    <link href="https://zjrongxiang.github.io/2018/01/25/2018-01-25-Redis-study/"/>
    <id>https://zjrongxiang.github.io/2018/01/25/2018-01-25-Redis-study/</id>
    <published>2018-01-25T11:30:00.000Z</published>
    <updated>2018-04-01T17:38:34.182Z</updated>
    
    <content type="html"><![CDATA[<p>Redis作为内存数据库，具有高效的读取性能。首次安装完Redis和Python连接redis的包。尝试做一些hello world的练习。</p><h3 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h3><ul><li>Redis是一个键值数据库（Key-Value）</li><li>其中Value值支持5中数据类型。分别是string（字符串）、list（列表）、set（集合）、hash（散列）、zset（有序集合）</li></ul><h3 id="redis-cli控制台的使用及各种数据类型的操作"><a href="#redis-cli控制台的使用及各种数据类型的操作" class="headerlink" title="redis-cli控制台的使用及各种数据类型的操作"></a>redis-cli控制台的使用及各种数据类型的操作</h3><ul><li>进入控制台</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt;redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>表示进入控制台，可以和redis进行互动。首先尝试字符串类型的三个命令（set、get、del）。</p><h4 id="1、string类型的3个常用命令"><a href="#1、string类型的3个常用命令" class="headerlink" title="1、string类型的3个常用命令"></a>1、string类型的3个常用命令</h4><p><strong>set命令</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set hello world</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>set命令用于给redis中指定键赋值。这里key为hello，而键值value为world。如果key不存在会自动新建该键。</p><p><strong>get命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">"world"</span><br></pre></td></tr></table></figure><p>get命令用于从redis中获取指定键的值。例子获取了hello键的值，返回键值字符串“world”。</p><p><strong>del命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>del命令用于从redis中删除指定键的键值。且我们用get命令检验，确实被删除了。</p><h4 id="2、list类型的4个命令"><a href="#2、list类型的4个命令" class="headerlink" title="2、list类型的4个命令"></a>2、list类型的4个命令</h4><p><strong>rpush、lpush命令</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list-test item1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush list-test item2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush list-test item1</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lpush list-test item3</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><p>上面的命令我们从右边先后推入了item1，item2，item1；然后从左边推入了item3。所以最后的形式应该是[“item3”,”item1”,”item2”,”item1”]</p><p><strong>lrange命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list-test 0 -1</span><br><span class="line">1) "item3"</span><br><span class="line">2) "item1"</span><br><span class="line">3) "item2"</span><br><span class="line">4) "item1"</span><br></pre></td></tr></table></figure><p>lrange用于获取list中指定范围的值。这里0是起始索引，-1是最后一个索引（类似python中的list索引）。</p><p><strong>lindex 命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lindex list-test 2</span><br><span class="line">"item2"</span><br></pre></td></tr></table></figure><p>lindex命令从list中获得指定索引位置的值。这里2实际是第三个值，所以返回“item2”。</p><p><strong>lpop、rpop命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpop list-test</span><br><span class="line">"item3"</span><br><span class="line">127.0.0.1:6379&gt; lrange list-test 0 -1</span><br><span class="line">1) "item1"</span><br><span class="line">2) "item2"</span><br><span class="line">3) "item1"</span><br></pre></td></tr></table></figure><p>lpop命令将list-test中最左边的值删除（弹掉），我们用lrange命令查看，确实已经删除。rpop类似使用。</p><h4 id="3、set集合类型的四个命令"><a href="#3、set集合类型的四个命令" class="headerlink" title="3、set集合类型的四个命令"></a>3、set集合类型的四个命令</h4><p><strong>sadd命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set-test item</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-test item1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-test item2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-test item3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-test item4</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>使用sadd命令向集合set-test加入了5个字符串值。注意set类型类似python中的set类型。无序值不重复。</p><p><strong>sismember命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember set-test item3</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>sismember用来查看值是否在集合中。上面检查item3是否在set-test，返回1，表示在集合中。</p><p><strong>srem命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srem set-test item2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; srem set-test item6</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>srem命令查看值是否在集合中，如果在返回1且删除该值。否则返回0。</p><p><strong>smembers命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers set-test</span><br><span class="line">1) "item"</span><br><span class="line">2) "item4"</span><br><span class="line">3) "item1"</span><br><span class="line">4) "item3"</span><br></pre></td></tr></table></figure><p>smembers命令查看集合中所有值。上面的结果也验证了srem确实将item2删除了。</p><blockquote><p>set类型还有集合之间的运算（数学），例如sinter、sunion、sdiff分别是集合的交集、并集、差集运算。</p></blockquote><h4 id="4、hash散列类型的命令"><a href="#4、hash散列类型的命令" class="headerlink" title="4、hash散列类型的命令"></a>4、hash散列类型的命令</h4><p>散列的数据类型是存储多个键值对之间的映射。</p><p><strong>hset命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset hash-test sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hash-test sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hash-test sub-key3 value3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hash-test sub-key2 value2</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>hset 向hash-test中插入键及键值。返回1表示原hash中无该值，0表示重复插入。</p><p><strong>hgetall命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall hash-test</span><br><span class="line">1) "sub-key1"</span><br><span class="line">2) "value1"</span><br><span class="line">3) "sub-key2"</span><br><span class="line">4) "value2"</span><br><span class="line">5) "sub-key3"</span><br><span class="line">6) "value3"</span><br></pre></td></tr></table></figure><p>hgetall命令从hash-test中获取所有的键值。</p><p><strong>hget命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget hash-test sub-key2</span><br><span class="line">"value2"</span><br></pre></td></tr></table></figure><p>hget命令从hash-test中获得指定键的键值。</p><p><strong>hdel命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel hash-test sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall hash-test</span><br><span class="line">1) "sub-key1"</span><br><span class="line">2) "value1"</span><br><span class="line">3) "sub-key3"</span><br><span class="line">4) "value3"</span><br></pre></td></tr></table></figure><p>hdel命令删除指定键及键值。</p><h4 id="5、有序集合的命令"><a href="#5、有序集合的命令" class="headerlink" title="5、有序集合的命令"></a>5、有序集合的命令</h4><p><strong>zadd命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset-test 123 number1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset-test 456 number2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset-test 123 number1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>zadd命令zset-test中插入分值（score）及成员名（member）。</p><p><strong>zrange命令</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange zset-test 0 -1 withscores</span><br><span class="line">1) "number1"</span><br><span class="line">2) "123"</span><br><span class="line">3) "number2"</span><br><span class="line">4) "456"</span><br><span class="line">127.0.0.1:6379&gt; zrange zset-test 0 -1</span><br><span class="line">1) "number1"</span><br><span class="line">2) "number2"</span><br></pre></td></tr></table></figure><p>zrange命令获取指定范围的分值和成员名。其中withscores参数用来控制是否同时获得score值。</p><p><strong>zrangebyscores命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrangebyscore zset-test 0 200 withscores</span><br><span class="line">1) "number1"</span><br><span class="line">2) "123"</span><br></pre></td></tr></table></figure><p>zrangebyscores命令获取scores指定范围的分值和成员名。</p><p><strong>zrem命令</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem zset-test number1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange zset-test 0 -1 withscores</span><br><span class="line">1) "number2"</span><br><span class="line">2) "456"</span><br></pre></td></tr></table></figure><p>zrem命令检查zset-test中知否有该分值和成员名。如果有返回1，并且删除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis作为内存数据库，具有高效的读取性能。首次安装完Redis和Python连接redis的包。尝试做一些hello world的练习。&lt;/p&gt;
&lt;h3 id=&quot;Redis的数据类型&quot;&gt;&lt;a href=&quot;#Redis的数据类型&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="Redis" scheme="https://zjrongxiang.github.io/categories/Redis/"/>
    
    
  </entry>
  
</feed>
