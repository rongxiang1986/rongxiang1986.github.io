<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">



  
  
  <link rel="stylesheet" href="/lib/Han/dist/han.min.css?v=3.3">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="目录 背景  第一部分   tsfresh包安装  第二部分   特征提取及介绍  第三部分   特征参数设置  第四部分   特征选择和过滤  参考文献及资料   背景时间序列类型的数据是我们数据处理经常遇到的数据类型，这类数据主要特征是具备时间属性，即数据按照时间顺序先后产生。 https://www.iotword.com/4212.html tsfresh是一个时间序列数据特征提取和特征选">
<meta property="og:type" content="article">
<meta property="og:title" content="Tsfresh时间序列特征提取包介绍">
<meta property="og:url" content="https://zjrongxiang.github.io/posts/1d1f5e4b/index.html">
<meta property="og:site_name" content="RongXiang">
<meta property="og:description" content="目录 背景  第一部分   tsfresh包安装  第二部分   特征提取及介绍  第三部分   特征参数设置  第四部分   特征选择和过滤  参考文献及资料   背景时间序列类型的数据是我们数据处理经常遇到的数据类型，这类数据主要特征是具备时间属性，即数据按照时间顺序先后产生。 https://www.iotword.com/4212.html tsfresh是一个时间序列数据特征提取和特征选">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-10-25T15:01:29.691Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tsfresh时间序列特征提取包介绍">
<meta name="twitter:description" content="目录 背景  第一部分   tsfresh包安装  第二部分   特征提取及介绍  第三部分   特征参数设置  第四部分   特征选择和过滤  参考文献及资料   背景时间序列类型的数据是我们数据处理经常遇到的数据类型，这类数据主要特征是具备时间属性，即数据按照时间顺序先后产生。 https://www.iotword.com/4212.html tsfresh是一个时间序列数据特征提取和特征选">



  <link rel="alternate" href="/atom.xml" title="RongXiang" type="application/atom+xml">




  <link rel="canonical" href="https://zjrongxiang.github.io/posts/1d1f5e4b/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Tsfresh时间序列特征提取包介绍 | RongXiang</title>
  




  <script async src="//www.googletagmanager.com/gtag/js?id=UA-113063423-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-113063423-1');
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <!-- <a href="https://github.com/zjrongxiang"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a> -->
    <a href="https://github.com/zjrongxiang"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RongXiang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">我的烂笔头</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zjrongxiang.github.io/posts/1d1f5e4b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rong xiang">
      <meta itemprop="description" content="Keep a Pure Curiosity">
      <meta itemprop="image" content="/images/avatar/person.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RongXiang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Tsfresh时间序列特征提取包介绍

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-30 22:42:00" itemprop="dateCreated datePublished" datetime="2019-09-30T22:42:00+08:00">2019-09-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-10-25 23:01:29" itemprop="dateModified" datetime="2022-10-25T23:01:29+08:00">2022-10-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/1d1f5e4b/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/1d1f5e4b/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">141k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">2:08</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><p>背景</p>
</li>
<li><p>第一部分   tsfresh包安装</p>
</li>
<li><p>第二部分   特征提取及介绍</p>
</li>
<li><p>第三部分   特征参数设置</p>
</li>
<li><p>第四部分   特征选择和过滤</p>
</li>
<li><p>参考文献及资料</p>
</li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>时间序列类型的数据是我们数据处理经常遇到的数据类型，这类数据主要特征是具备时间属性，即数据按照时间顺序先后产生。</p>
<p><a href="https://www.iotword.com/4212.html" target="_blank" rel="noopener">https://www.iotword.com/4212.html</a></p>
<p>tsfresh是一个时间序列数据特征提取和特征选取工具包，主要用于时间序列数据的特征工程。官网地址为：<a href="https://github.com/blue-yonder/tsfresh" target="_blank" rel="noopener">https://github.com/blue-yonder/tsfresh</a> 。</p>
<h2 id="第一部分-tsfresh包安装"><a href="#第一部分-tsfresh包安装" class="headerlink" title="第一部分   tsfresh包安装"></a>第一部分   tsfresh包安装</h2><p>安装tsfresh可以使用pip命令进行安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pip install tsfresh</span></span><br></pre></td></tr></table></figure>
<p>包文件介绍：</p>
<h2 id="第一部分-项目结构"><a href="#第一部分-项目结构" class="headerlink" title="第一部分 项目结构"></a>第一部分 项目结构</h2><h2 id="第二部分-特征提取及介绍"><a href="#第二部分-特征提取及介绍" class="headerlink" title="第二部分 特征提取及介绍"></a>第二部分 特征提取及介绍</h2><p>tsfresh中的特征提取代码在tsfresh/feature_extraction/feature_calculators.py中。我们逐个介绍这些特征的包。</p>
<p>对于特征分为两类：</p>
<ul>
<li>简单类：特征提取只输出有个单个数值。</li>
<li>组合类：</li>
</ul>
<h3 id="1、时间序列平方和"><a href="#1、时间序列平方和" class="headerlink" title="1、时间序列平方和"></a>1、时间序列平方和</h3><p>函数：tsfresh.feature_extraction.feature_calculators.abs_energy(x)<br>$$<br>E=\sum_{i=1}^{n} x_{i}^{2}，其中{x_i}_{i=1}^n为时间序列；<br>$$<br>源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs_energy</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the absolute energy of the time series which is the sum over the squared values</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        E=\sum_&#123;i=1&#125;^&#123;n&#125; x_&#123;i&#125;^&#123;2&#125;</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line">    <span class="keyword">return</span> np.dot(x, x)</span><br></pre></td></tr></table></figure>
<h4 id="2、时间序列一阶差分绝对和"><a href="#2、时间序列一阶差分绝对和" class="headerlink" title="2、时间序列一阶差分绝对和"></a>2、时间序列一阶差分绝对和</h4><p>函数：tsfresh.feature_extraction.feature_calculators.absolute_sum_of_changes(x)<br>$$<br>\sum_{i=1}^{n-1}\left|x_{i+1}-x_{i}\right|<br>$$<br>源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">absolute_sum_of_changes</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the sum over the absolute value of consecutive changes in the series x</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        \\sum_&#123;i=1, \ldots, n-1&#125; \\mid x_&#123;i+1&#125;- x_i \\mid</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(np.abs(np.diff(x)))</span><br></pre></td></tr></table></figure>
<h4 id="3、时间序列各阶自相关系数的聚合统计特征"><a href="#3、时间序列各阶自相关系数的聚合统计特征" class="headerlink" title="3、时间序列各阶自相关系数的聚合统计特征"></a>3、时间序列各阶自相关系数的聚合统计特征</h4><p>函数：tsfresh.feature_extraction.feature_calculators.agg_autocorrelation(x, param)</p>
<p>该特征为各阶自相关系数的聚合统计特征。<br>$$<br>R(l)=\frac{1}{(n-l) \sigma^{2}} \sum_{i=1}^{n-l}\left(x_{i}-\mu\right)\left(x_{i+l}-\mu\right)<br>$$<br>parma(list) 包含一个字典{“f_agg”: x, “maxlag”, n} 其中x为聚合函数名，n为最大差分阶数。函数返回时序数据的各阶差分值之间的聚合（方差、均值）统计特征。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">agg_autocorrelation</span><span class="params">(x, param)</span>:</span></span><br><span class="line">    <span class="string">r"""</span></span><br><span class="line"><span class="string">    Calculates the value of an aggregation function :math:`f_&#123;agg&#125;` (e.g. the variance or the mean) over the</span></span><br><span class="line"><span class="string">    autocorrelation :math:`R(l)` for different lags. The autocorrelation :math:`R(l)` for lag :math:`l` is defined as</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        R(l) = \frac&#123;1&#125;&#123;(n-l)\sigma^&#123;2&#125;&#125; \sum_&#123;t=1&#125;^&#123;n-l&#125;(X_&#123;t&#125;-\mu )(X_&#123;t+l&#125;-\mu)</span></span><br><span class="line"><span class="string">    where :math:`X_i` are the values of the time series, :math:`n` its length. Finally, :math:`\sigma^2` and</span></span><br><span class="line"><span class="string">    :math:`\mu` are estimators for its variance and mean</span></span><br><span class="line"><span class="string">    (See `Estimation of the Autocorrelation function &lt;http://en.wikipedia.org/wiki/Autocorrelation#Estimation&gt;`_).</span></span><br><span class="line"><span class="string">    The :math:`R(l)` for different lags :math:`l` form a vector. This feature calculator applies the aggregation</span></span><br><span class="line"><span class="string">    function :math:`f_&#123;agg&#125;` to this vector and returns</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        f_&#123;agg&#125; \left( R(1), \ldots, R(m)\right) \quad \text&#123;for&#125; \quad m = max(n, maxlag).</span></span><br><span class="line"><span class="string">    Here :math:`maxlag` is the second parameter passed to this function.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param param: contains dictionaries &#123;"f_agg": x, "maxlag", n&#125; with x str, the name of a numpy function</span></span><br><span class="line"><span class="string">                  (e.g. "mean", "var", "std", "median"), its the name of the aggregator function that is applied to the</span></span><br><span class="line"><span class="string">                  autocorrelations. Further, n is an int and the maximal number of lags to consider.</span></span><br><span class="line"><span class="string">    :type param: list</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># if the time series is longer than the following threshold, we use fft to calculate the acf</span></span><br><span class="line">    THRESHOLD_TO_USE_FFT = <span class="number">1250</span></span><br><span class="line">    var = np.var(x)</span><br><span class="line">    n = len(x)</span><br><span class="line">    max_maxlag = max([config[<span class="string">"maxlag"</span>] <span class="keyword">for</span> config <span class="keyword">in</span> param])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> np.abs(var) &lt; <span class="number">10</span>**<span class="number">-10</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        a = [<span class="number">0</span>] * len(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a = acf(x, unbiased=<span class="keyword">True</span>, fft=n &gt; THRESHOLD_TO_USE_FFT, nlags=max_maxlag)[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> [(<span class="string">"f_agg_\"&#123;&#125;\"__maxlag_&#123;&#125;"</span>.format(config[<span class="string">"f_agg"</span>], config[<span class="string">"maxlag"</span>]),</span><br><span class="line">             getattr(np, config[<span class="string">"f_agg"</span>])(a[:int(config[<span class="string">"maxlag"</span>])])) <span class="keyword">for</span> config <span class="keyword">in</span> param]</span><br></pre></td></tr></table></figure>
<h4 id="4、时间序列基于分块时序聚合值的线性回归"><a href="#4、时间序列基于分块时序聚合值的线性回归" class="headerlink" title="4、时间序列基于分块时序聚合值的线性回归"></a>4、时间序列基于分块时序聚合值的线性回归</h4><p>函数：tsfresh.feature_extraction.feature_calculators.agg_linear_trend(x, param)</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">agg_linear_trend</span><span class="params">(x, param)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Calculates a linear least-squares regression for values of the time series that were aggregated over chunks versus</span></span><br><span class="line"><span class="string">    the sequence from 0 up to the number of chunks minus one.</span></span><br><span class="line"><span class="string">    This feature assumes the signal to be uniformly sampled. It will not use the time stamps to fit the model.</span></span><br><span class="line"><span class="string">    The parameters attr controls which of the characteristics are returned. Possible extracted attributes are "pvalue",</span></span><br><span class="line"><span class="string">    "rvalue", "intercept", "slope", "stderr", see the documentation of linregress for more information.</span></span><br><span class="line"><span class="string">    The chunksize is regulated by "chunk_len". It specifies how many time series values are in each chunk.</span></span><br><span class="line"><span class="string">    Further, the aggregation function is controlled by "f_agg", which can use "max", "min" or , "mean", "median"</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param param: contains dictionaries &#123;"attr": x, "chunk_len": l, "f_agg": f&#125; with x, f an string and l an int</span></span><br><span class="line"><span class="string">    :type param: list</span></span><br><span class="line"><span class="string">    :return: the different feature values</span></span><br><span class="line"><span class="string">    :return type: pandas.Series</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># todo: we could use the index of the DataFrame here</span></span><br><span class="line"></span><br><span class="line">    calculated_agg = &#123;&#125;</span><br><span class="line">    res_data = []</span><br><span class="line">    res_index = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> parameter_combination <span class="keyword">in</span> param:</span><br><span class="line"></span><br><span class="line">        chunk_len = parameter_combination[<span class="string">"chunk_len"</span>]</span><br><span class="line">        f_agg = parameter_combination[<span class="string">"f_agg"</span>]</span><br><span class="line"></span><br><span class="line">        aggregate_result = _aggregate_on_chunks(x, f_agg, chunk_len)</span><br><span class="line">        <span class="keyword">if</span> f_agg <span class="keyword">not</span> <span class="keyword">in</span> calculated_agg <span class="keyword">or</span> chunk_len <span class="keyword">not</span> <span class="keyword">in</span> calculated_agg[f_agg]:</span><br><span class="line">            <span class="keyword">if</span> chunk_len &gt;= len(x):</span><br><span class="line">                calculated_agg[f_agg] = &#123;chunk_len: np.NaN&#125;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lin_reg_result = linregress(range(len(aggregate_result)), aggregate_result)</span><br><span class="line">                calculated_agg[f_agg] = &#123;chunk_len: lin_reg_result&#125;</span><br><span class="line"></span><br><span class="line">        attr = parameter_combination[<span class="string">"attr"</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> chunk_len &gt;= len(x):</span><br><span class="line">            res_data.append(np.NaN)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res_data.append(getattr(calculated_agg[f_agg][chunk_len], attr))</span><br><span class="line"></span><br><span class="line">        res_index.append(<span class="string">"f_agg_\"&#123;&#125;\"__chunk_len_&#123;&#125;__attr_\"&#123;&#125;\""</span>.format(f_agg, chunk_len, attr))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> zip(res_index, res_data)</span><br></pre></td></tr></table></figure>
<h4 id="5、时间序列近似熵"><a href="#5、时间序列近似熵" class="headerlink" title="5、时间序列近似熵"></a>5、时间序列近似熵</h4><p>函数：tsfresh.feature_extraction.feature_calculators.approximate_entropy(x, m, r)</p>
<p>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">approximate_entropy</span><span class="params">(x, m, r)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Implements a vectorized Approximate entropy algorithm.</span></span><br><span class="line"><span class="string">        https://en.wikipedia.org/wiki/Approximate_entropy</span></span><br><span class="line"><span class="string">    For short time-series this method is highly dependent on the parameters,</span></span><br><span class="line"><span class="string">    but should be stable for N &gt; 2000, see:</span></span><br><span class="line"><span class="string">        Yentes et al. (2012) -</span></span><br><span class="line"><span class="string">        *The Appropriate Use of Approximate Entropy and Sample Entropy with Short Data Sets*</span></span><br><span class="line"><span class="string">    Other shortcomings and alternatives discussed in:</span></span><br><span class="line"><span class="string">        Richman &amp; Moorman (2000) -</span></span><br><span class="line"><span class="string">        *Physiological time-series analysis using approximate entropy and sample entropy*</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param m: Length of compared run of data</span></span><br><span class="line"><span class="string">    :type m: int</span></span><br><span class="line"><span class="string">    :param r: Filtering level, must be positive</span></span><br><span class="line"><span class="string">    :type r: float</span></span><br><span class="line"><span class="string">    :return: Approximate entropy</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line"></span><br><span class="line">    N = x.size</span><br><span class="line">    r *= np.std(x)</span><br><span class="line">    <span class="keyword">if</span> r &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"Parameter r must be positive."</span>)</span><br><span class="line">    <span class="keyword">if</span> N &lt;= m+<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_phi</span><span class="params">(m)</span>:</span></span><br><span class="line">        x_re = np.array([x[i:i+m] <span class="keyword">for</span> i <span class="keyword">in</span> range(N - m + <span class="number">1</span>)])</span><br><span class="line">        C = np.sum(np.max(np.abs(x_re[:, np.newaxis] - x_re[np.newaxis, :]),</span><br><span class="line">                          axis=<span class="number">2</span>) &lt;= r, axis=<span class="number">0</span>) / (N-m+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> np.sum(np.log(C)) / (N - m + <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.abs(_phi(m) - _phi(m + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="6、时间序列自回归系数"><a href="#6、时间序列自回归系数" class="headerlink" title="6、时间序列自回归系数"></a>6、时间序列自回归系数</h4><p>函数：tsfresh.feature_extraction.feature_calculators.ar_coefficient(x, param)</p>
<p>衡量时序数据的的周期性、不可预测性和波动性。</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ar_coefficient</span><span class="params">(x, param)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    This feature calculator fits the unconditional maximum likelihood</span></span><br><span class="line"><span class="string">    of an autoregressive AR(k) process.</span></span><br><span class="line"><span class="string">    The k parameter is the maximum lag of the process</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        X_&#123;t&#125;=\\varphi_0 +\\sum _&#123;&#123;i=1&#125;&#125;^&#123;k&#125;\\varphi_&#123;i&#125;X_&#123;&#123;t-i&#125;&#125;+\\varepsilon_&#123;t&#125;</span></span><br><span class="line"><span class="string">    For the configurations from param which should contain the maxlag "k" and such an AR process is calculated. Then</span></span><br><span class="line"><span class="string">    the coefficients :math:`\\varphi_&#123;i&#125;` whose index :math:`i` contained from "coeff" are returned.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param param: contains dictionaries &#123;"coeff": x, "k": y&#125; with x,y int</span></span><br><span class="line"><span class="string">    :type param: list</span></span><br><span class="line"><span class="string">    :return x: the different feature values</span></span><br><span class="line"><span class="string">    :return type: pandas.Series</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    calculated_ar_params = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    x_as_list = list(x)</span><br><span class="line">    calculated_AR = AR(x_as_list)</span><br><span class="line"></span><br><span class="line">    res = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> parameter_combination <span class="keyword">in</span> param:</span><br><span class="line">        k = parameter_combination[<span class="string">"k"</span>]</span><br><span class="line">        p = parameter_combination[<span class="string">"coeff"</span>]</span><br><span class="line"></span><br><span class="line">        column_name = <span class="string">"k_&#123;&#125;__coeff_&#123;&#125;"</span>.format(k, p)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> calculated_ar_params:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                calculated_ar_params[k] = calculated_AR.fit(maxlag=k, solver=<span class="string">"mle"</span>).params</span><br><span class="line">            <span class="keyword">except</span> (LinAlgError, ValueError):</span><br><span class="line">                calculated_ar_params[k] = [np.NaN]*k</span><br><span class="line"></span><br><span class="line">        mod = calculated_ar_params[k]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p &lt;= k:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                res[column_name] = mod[p]</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                res[column_name] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[column_name] = np.NaN</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [(key, value) <span class="keyword">for</span> key, value <span class="keyword">in</span> res.items()]</span><br></pre></td></tr></table></figure>
<h4 id="7、时间序列ADF检验"><a href="#7、时间序列ADF检验" class="headerlink" title="7、时间序列ADF检验"></a>7、时间序列ADF检验</h4><p>函数：tsfresh.feature_extraction.feature_calculators.augmented_dickey_fuller(x, param)</p>
<p>测试一个自回归模型是否存在单位根，衡量时序数据的平稳性。</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">augmented_dickey_fuller</span><span class="params">(x, param)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    The Augmented Dickey-Fuller test is a hypothesis test which checks whether a unit root is present in a time</span></span><br><span class="line"><span class="string">    series sample. This feature calculator returns the value of the respective test statistic.</span></span><br><span class="line"><span class="string">    See the statsmodels implementation for references and more details.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param param: contains dictionaries &#123;"attr": x&#125; with x str, either "teststat", "pvalue" or "usedlag"</span></span><br><span class="line"><span class="string">    :type param: list</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    res = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = adfuller(x)</span><br><span class="line">    <span class="keyword">except</span> LinAlgError:</span><br><span class="line">        res = np.NaN, np.NaN, np.NaN</span><br><span class="line">    <span class="keyword">except</span> ValueError: <span class="comment"># occurs if sample size is too small</span></span><br><span class="line">        res = np.NaN, np.NaN, np.NaN</span><br><span class="line">    <span class="keyword">except</span> MissingDataError: <span class="comment"># is thrown for e.g. inf or nan in the data</span></span><br><span class="line">        res = np.NaN, np.NaN, np.NaN</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [(<span class="string">'attr_"&#123;&#125;"'</span>.format(config[<span class="string">"attr"</span>]),</span><br><span class="line">                  res[<span class="number">0</span>] <span class="keyword">if</span> config[<span class="string">"attr"</span>] == <span class="string">"teststat"</span></span><br><span class="line">             <span class="keyword">else</span> res[<span class="number">1</span>] <span class="keyword">if</span> config[<span class="string">"attr"</span>] == <span class="string">"pvalue"</span></span><br><span class="line">             <span class="keyword">else</span> res[<span class="number">2</span>] <span class="keyword">if</span> config[<span class="string">"attr"</span>] == <span class="string">"usedlag"</span> <span class="keyword">else</span> np.NaN)</span><br><span class="line">            <span class="keyword">for</span> config <span class="keyword">in</span> param]</span><br></pre></td></tr></table></figure>
<h4 id="8、时间序列lag阶自相关性"><a href="#8、时间序列lag阶自相关性" class="headerlink" title="8、时间序列lag阶自相关性"></a>8、时间序列lag阶自相关性</h4><p>函数：tsfresh.feature_extraction.feature_calculators.autocorrelation(x, lag)</p>
<p>计算lag阶滞后时序数据的自相关性（浮点数）</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">autocorrelation</span><span class="params">(x, lag)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Calculates the autocorrelation of the specified lag, according to the formula [1]</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        \\frac&#123;1&#125;&#123;(n-l)\sigma^&#123;2&#125;&#125; \\sum_&#123;t=1&#125;^&#123;n-l&#125;(X_&#123;t&#125;-\\mu )(X_&#123;t+l&#125;-\\mu)</span></span><br><span class="line"><span class="string">    where :math:`n` is the length of the time series :math:`X_i`, :math:`\sigma^2` its variance and :math:`\mu` its</span></span><br><span class="line"><span class="string">    mean. `l` denotes the lag.</span></span><br><span class="line"><span class="string">    .. rubric:: References</span></span><br><span class="line"><span class="string">    [1] https://en.wikipedia.org/wiki/Autocorrelation#Estimation</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param lag: the lag</span></span><br><span class="line"><span class="string">    :type lag: int</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># This is important: If a series is passed, the product below is calculated</span></span><br><span class="line">    <span class="comment"># based on the index, which corresponds to squaring the series.</span></span><br><span class="line">    <span class="keyword">if</span> type(x) <span class="keyword">is</span> pd.Series:</span><br><span class="line">        x = x.values</span><br><span class="line">    <span class="keyword">if</span> len(x) &lt; lag:</span><br><span class="line">        <span class="keyword">return</span> np.nan</span><br><span class="line">    <span class="comment"># Slice the relevant subseries based on the lag</span></span><br><span class="line">    y1 = x[:(len(x)-lag)]</span><br><span class="line">    y2 = x[lag:]</span><br><span class="line">    <span class="comment"># Subtract the mean of the whole series x</span></span><br><span class="line">    x_mean = np.mean(x)</span><br><span class="line">    <span class="comment"># The result is sometimes referred to as "covariation"</span></span><br><span class="line">    sum_product = np.sum((y1 - x_mean) * (y2 - x_mean))</span><br><span class="line">    <span class="comment"># Return the normalized unbiased covariance</span></span><br><span class="line">    v = np.var(x)</span><br><span class="line">    <span class="keyword">if</span> np.isclose(v, <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> np.NaN</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> sum_product / ((len(x) - lag) * v)</span><br></pre></td></tr></table></figure>
<h4 id="9、时间序列分组熵"><a href="#9、时间序列分组熵" class="headerlink" title="9、时间序列分组熵"></a>9、时间序列分组熵</h4><p>函数：tsfresh.feature_extraction.feature_calculators.binned_entropy(x, max_bins)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binned_entropy</span><span class="params">(x, max_bins)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    First bins the values of x into max_bins equidistant bins.</span></span><br><span class="line"><span class="string">    Then calculates the value of</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        - \\sum_&#123;k=0&#125;^&#123;min(max\\_bins, len(x))&#125; p_k log(p_k) \\cdot \\mathbf&#123;1&#125;_&#123;(p_k &gt; 0)&#125;</span></span><br><span class="line"><span class="string">    where :math:`p_k` is the percentage of samples in bin :math:`k`.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param max_bins: the maximal number of bins</span></span><br><span class="line"><span class="string">    :type max_bins: int</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line">    hist, bin_edges = np.histogram(x, bins=max_bins)</span><br><span class="line">    probs = hist / x.size</span><br><span class="line">    <span class="keyword">return</span> - np.sum(p * np.math.log(p) <span class="keyword">for</span> p <span class="keyword">in</span> probs <span class="keyword">if</span> p != <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="10、时序数据非线性度量"><a href="#10、时序数据非线性度量" class="headerlink" title="10、时序数据非线性度量"></a>10、时序数据非线性度量</h4><p>函数：tsfresh.feature_extraction.feature_calculators.c3(x, lag)</p>
<ul>
<li>基于物理学的时序数据非线性度量（浮点数）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c3</span><span class="params">(x, lag)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    This function calculates the value of</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        \\frac&#123;1&#125;&#123;n-2lag&#125; \sum_&#123;i=0&#125;^&#123;n-2lag&#125; x_&#123;i + 2 \cdot lag&#125;^2 \cdot x_&#123;i + lag&#125; \cdot x_&#123;i&#125;</span></span><br><span class="line"><span class="string">    which is</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        \\mathbb&#123;E&#125;[L^2(X)^2 \cdot L(X) \cdot X]</span></span><br><span class="line"><span class="string">    where :math:`\\mathbb&#123;E&#125;` is the mean and :math:`L` is the lag operator. It was proposed in [1] as a measure of</span></span><br><span class="line"><span class="string">    non linearity in the time series.</span></span><br><span class="line"><span class="string">    .. rubric:: References</span></span><br><span class="line"><span class="string">    |  [1] Schreiber, T. and Schmitz, A. (1997).</span></span><br><span class="line"><span class="string">    |  Discrimination power of measures for nonlinearity in a time series</span></span><br><span class="line"><span class="string">    |  PHYSICAL REVIEW E, VOLUME 55, NUMBER 5</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param lag: the lag that should be used in the calculation of the feature</span></span><br><span class="line"><span class="string">    :type lag: int</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line">    n = x.size</span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span> * lag &gt;= n:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> np.mean((_roll(x, <span class="number">2</span> * -lag) * _roll(x, -lag) * x)[<span class="number">0</span>:(n - <span class="number">2</span> * lag)])</span><br></pre></td></tr></table></figure>
<h4 id="11、时间序列给定区间的统计量"><a href="#11、时间序列给定区间的统计量" class="headerlink" title="11、时间序列给定区间的统计量"></a>11、时间序列给定区间的统计量</h4><p>函数：tsfresh.feature_extraction.feature_calculators.change_quantiles(x, ql, qh, isabs, f_agg)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_quantiles</span><span class="params">(x, ql, qh, isabs, f_agg)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    First fixes a corridor given by the quantiles ql and qh of the distribution of x.</span></span><br><span class="line"><span class="string">    Then calculates the average, absolute value of consecutive changes of the series x inside this corridor.</span></span><br><span class="line"><span class="string">    Think about selecting a corridor on the</span></span><br><span class="line"><span class="string">    y-Axis and only calculating the mean of the absolute change of the time series inside this corridor.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param ql: the lower quantile of the corridor</span></span><br><span class="line"><span class="string">    :type ql: float</span></span><br><span class="line"><span class="string">    :param qh: the higher quantile of the corridor</span></span><br><span class="line"><span class="string">    :type qh: float</span></span><br><span class="line"><span class="string">    :param isabs: should the absolute differences be taken?</span></span><br><span class="line"><span class="string">    :type isabs: bool</span></span><br><span class="line"><span class="string">    :param f_agg: the aggregator function that is applied to the differences in the bin</span></span><br><span class="line"><span class="string">    :type f_agg: str, name of a numpy function (e.g. mean, var, std, median)</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> ql &gt;= qh:</span><br><span class="line">        ValueError(<span class="string">"ql=&#123;&#125; should be lower than qh=&#123;&#125;"</span>.format(ql, qh))</span><br><span class="line"></span><br><span class="line">    div = np.diff(x)</span><br><span class="line">    <span class="keyword">if</span> isabs:</span><br><span class="line">        div = np.abs(div)</span><br><span class="line">    <span class="comment"># All values that originate from the corridor between the quantiles ql and qh will have the category 0,</span></span><br><span class="line">    <span class="comment"># other will be np.NaN</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bin_cat = pd.qcut(x, [ql, qh], labels=<span class="keyword">False</span>)</span><br><span class="line">        bin_cat_0 = bin_cat == <span class="number">0</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:  <span class="comment"># Occurs when ql are qh effectively equal, e.g. x is not long enough or is too categorical</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># We only count changes that start and end inside the corridor</span></span><br><span class="line">    ind = (bin_cat_0 &amp; _roll(bin_cat_0, <span class="number">1</span>))[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> sum(ind) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ind_inside_corridor = np.where(ind == <span class="number">1</span>)</span><br><span class="line">        aggregator = getattr(np, f_agg)</span><br><span class="line">        <span class="keyword">return</span> aggregator(div[ind_inside_corridor])</span><br></pre></td></tr></table></figure>
<h4 id="12、时间序列复杂度"><a href="#12、时间序列复杂度" class="headerlink" title="12、时间序列复杂度"></a>12、时间序列复杂度</h4><p>函数：tsfresh.feature_extraction.feature_calculators.cid_ce(x, normalize)</p>
<p>用来评估时间序列的复杂度，越复杂的序列有越多的谷峰。 （浮点数）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cid_ce</span><span class="params">(x, normalize)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    This function calculator is an estimate for a time series complexity [1] (A more complex time series has more peaks,</span></span><br><span class="line"><span class="string">    valleys etc.). It calculates the value of</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        \\sqrt&#123; \\sum_&#123;i=0&#125;^&#123;n-2lag&#125; ( x_&#123;i&#125; - x_&#123;i+1&#125;)^2 &#125;</span></span><br><span class="line"><span class="string">    .. rubric:: References</span></span><br><span class="line"><span class="string">    |  [1] Batista, Gustavo EAPA, et al (2014).</span></span><br><span class="line"><span class="string">    |  CID: an efficient complexity-invariant distance for time series.</span></span><br><span class="line"><span class="string">    |  Data Mining and Knowledge Discovery 28.3 (2014): 634-669.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param normalize: should the time series be z-transformed?</span></span><br><span class="line"><span class="string">    :type normalize: bool</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line">    <span class="keyword">if</span> normalize:</span><br><span class="line">        s = np.std(x)</span><br><span class="line">        <span class="keyword">if</span> s!=<span class="number">0</span>:</span><br><span class="line">            x = (x - np.mean(x))/s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    x = np.diff(x)</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(np.dot(x, x))</span><br></pre></td></tr></table></figure>
<h4 id="13、时间序列高于均值个数"><a href="#13、时间序列高于均值个数" class="headerlink" title="13、时间序列高于均值个数"></a>13、时间序列高于均值个数</h4><p>函数：tsfresh.feature_extraction.feature_calculators.count_above_mean(x)</p>
<p>源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_above_mean</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the number of values in x that are higher than the mean of x</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m = np.mean(x)</span><br><span class="line">    <span class="keyword">return</span> np.where(x &gt; m)[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure>
<h4 id="14、时间序列低于均值个数"><a href="#14、时间序列低于均值个数" class="headerlink" title="14、时间序列低于均值个数"></a>14、时间序列低于均值个数</h4><p>函数：tsfresh.feature_extraction.feature_calculators.count_below_mean(x)</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_below_mean</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the number of values in x that are lower than the mean of x</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m = np.mean(x)</span><br><span class="line">    <span class="keyword">return</span> np.where(x &lt; m)[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure>
<h4 id="15、时间序列Ricker小波分析"><a href="#15、时间序列Ricker小波分析" class="headerlink" title="15、时间序列Ricker小波分析"></a>15、时间序列Ricker小波分析</h4><p>函数：tsfresh.feature_extraction.feature_calculators.cwt_coefficients(x, param)</p>
<ul>
<li>连续的小波分析，ricker子波是地震勘探中常用的子波类型，ricker子波是基于波动方程严格推导得到的。（pandas.Series）</li>
</ul>
<h4 id="16、时间序列分块局部熵比率"><a href="#16、时间序列分块局部熵比率" class="headerlink" title="16、时间序列分块局部熵比率"></a>16、时间序列分块局部熵比率</h4><p>tsfresh.feature_extraction.feature_calculators.energy_ratio_by_chunks(x, param)</p>
<p>将时序数据分块后，计算目标块数据的熵与全体的熵比率。当数据不够均分时，会将多余的数据在前面的块中散布。（浮点数）</p>
<h4 id="17、时间序列绝对傅里叶变换的谱统计量"><a href="#17、时间序列绝对傅里叶变换的谱统计量" class="headerlink" title="17、时间序列绝对傅里叶变换的谱统计量"></a>17、时间序列绝对傅里叶变换的谱统计量</h4><p>tsfresh.feature_extraction.feature_calculators.fft_aggregated(x, param)</p>
<h4 id="18、时间序列傅里叶变换系数"><a href="#18、时间序列傅里叶变换系数" class="headerlink" title="18、时间序列傅里叶变换系数"></a>18、时间序列傅里叶变换系数</h4><p>tsfresh.feature_extraction.feature_calculators.fft_coefficient(x, param)</p>
<h4 id="19、时间序列第一个最大值位置"><a href="#19、时间序列第一个最大值位置" class="headerlink" title="19、时间序列第一个最大值位置"></a>19、时间序列第一个最大值位置</h4><p>函数：tsfresh.feature_extraction.feature_calculators.first_location_of_maximum(x)</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_location_of_maximum</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the first location of the maximum value of x.</span></span><br><span class="line"><span class="string">    The position is calculated relatively to the length of x.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line">    <span class="keyword">return</span> np.argmax(x) / len(x) <span class="keyword">if</span> len(x) &gt; <span class="number">0</span> <span class="keyword">else</span> np.NaN</span><br></pre></td></tr></table></figure>
<h4 id="20、时间序列第一个最小值位置"><a href="#20、时间序列第一个最小值位置" class="headerlink" title="20、时间序列第一个最小值位置"></a>20、时间序列第一个最小值位置</h4><p>函数：tsfresh.feature_extraction.feature_calculators.first_location_of_minimum(x)</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_location_of_minimum</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the first location of the minimal value of x.</span></span><br><span class="line"><span class="string">    The position is calculated relatively to the length of x.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line">    <span class="keyword">return</span> np.argmin(x) / len(x) <span class="keyword">if</span> len(x) &gt; <span class="number">0</span> <span class="keyword">else</span> np.NaN</span><br></pre></td></tr></table></figure>
<h4 id="21、时间序列Langevin模型拟合的多项式系数"><a href="#21、时间序列Langevin模型拟合的多项式系数" class="headerlink" title="21、时间序列Langevin模型拟合的多项式系数"></a>21、时间序列Langevin模型拟合的多项式系数</h4><p>tsfresh.feature_extraction.feature_calculators.friedrich_coefficients(x, param)</p>
<h4 id="22、时间序列数值是否有重复"><a href="#22、时间序列数值是否有重复" class="headerlink" title="22、时间序列数值是否有重复"></a>22、时间序列数值是否有重复</h4><p>函数：tsfresh.feature_extraction.feature_calculators.has_duplicate(x)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_duplicate</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Checks if any value in x occurs more than once</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line">    <span class="keyword">return</span> x.size != np.unique(x).size</span><br></pre></td></tr></table></figure>
<h4 id="23、时间序列最大值是否有重复"><a href="#23、时间序列最大值是否有重复" class="headerlink" title="23、时间序列最大值是否有重复"></a>23、时间序列最大值是否有重复</h4><p>函数：tsfresh.feature_extraction.feature_calculators.has_duplicate_max(x)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_duplicate</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Checks if any value in x occurs more than once</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line">    <span class="keyword">return</span> x.size != np.unique(x).size</span><br></pre></td></tr></table></figure>
<h4 id="24、时间序列最小值是否有重复"><a href="#24、时间序列最小值是否有重复" class="headerlink" title="24、时间序列最小值是否有重复"></a>24、时间序列最小值是否有重复</h4><p>函数：tsfresh.feature_extraction.feature_calculators.has_duplicate_min(x)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_duplicate_min</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Checks if the minimal value of x is observed more than once</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line">    <span class="keyword">return</span> np.sum(x == np.min(x)) &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="25、时间序列分位数索引"><a href="#25、时间序列分位数索引" class="headerlink" title="25、时间序列分位数索引"></a>25、时间序列分位数索引</h4><p>tsfresh.feature_extraction.feature_calculators.index_mass_quantile(x, param)</p>
<h4 id="26、时间序列峰度"><a href="#26、时间序列峰度" class="headerlink" title="26、时间序列峰度"></a>26、时间序列峰度</h4><p>tsfresh.feature_extraction.feature_calculators.kurtosis(x)</p>
<p>描述数据分布形态的陡缓程度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kurtosis</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the kurtosis of x (calculated with the adjusted Fisher-Pearson standardized</span></span><br><span class="line"><span class="string">    moment coefficient G2).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, pd.Series):</span><br><span class="line">        x = pd.Series(x)</span><br><span class="line">    <span class="keyword">return</span> pd.Series.kurtosis(x)</span><br></pre></td></tr></table></figure>
<h4 id="27、时间序列标准差是否大于r倍偏差"><a href="#27、时间序列标准差是否大于r倍偏差" class="headerlink" title="27、时间序列标准差是否大于r倍偏差"></a>27、时间序列标准差是否大于r倍偏差</h4><p>函数：tsfresh.feature_extraction.feature_calculators.large_standard_deviation(x, r)</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_standard_deviation</span><span class="params">(x, r)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Boolean variable denoting if the standard dev of x is higher</span></span><br><span class="line"><span class="string">    than 'r' times the range = difference between max and min of x.</span></span><br><span class="line"><span class="string">    Hence it checks if</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        std(x) &gt; r * (max(X)-min(X))</span></span><br><span class="line"><span class="string">    According to a rule of the thumb, the standard deviation should be a forth of the range of the values.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param r: the percentage of the range to compare with</span></span><br><span class="line"><span class="string">    :type r: float</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line">    <span class="keyword">return</span> np.std(x) &gt; (r * (np.max(x) - np.min(x)))</span><br></pre></td></tr></table></figure>
<h4 id="28、时间序列最后一个最大值位置"><a href="#28、时间序列最后一个最大值位置" class="headerlink" title="28、时间序列最后一个最大值位置"></a>28、时间序列最后一个最大值位置</h4><p>函数：tsfresh.feature_extraction.feature_calculators.last_location_of_maximum(x)</p>
<p>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_location_of_maximum</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the relative last location of the maximum value of x.</span></span><br><span class="line"><span class="string">    The position is calculated relatively to the length of x.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    x = np.asarray(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> - np.argmax(x[::<span class="number">-1</span>]) / len(x) <span class="keyword">if</span> len(x) &gt; <span class="number">0</span> <span class="keyword">else</span> np.NaN</span><br></pre></td></tr></table></figure>
<h4 id="29、时间序列最后一个最大值位置"><a href="#29、时间序列最后一个最大值位置" class="headerlink" title="29、时间序列最后一个最大值位置"></a>29、时间序列最后一个最大值位置</h4><p>函数：tsfresh.feature_extraction.feature_calculators.last_location_of_minimum(x)</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_location_of_minimum</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the last location of the minimal value of x.</span></span><br><span class="line"><span class="string">    The position is calculated relatively to the length of x.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    x = np.asarray(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> - np.argmin(x[::<span class="number">-1</span>]) / len(x) <span class="keyword">if</span> len(x) &gt; <span class="number">0</span> <span class="keyword">else</span> np.NaN</span><br></pre></td></tr></table></figure>
<h4 id="30、时间序列的长度"><a href="#30、时间序列的长度" class="headerlink" title="30、时间序列的长度"></a>30、时间序列的长度</h4><p>函数：tsfresh.feature_extraction.feature_calculators.length(x)</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the length of x</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> len(x)</span><br></pre></td></tr></table></figure>
<h4 id="31、时间序列线性回归分析"><a href="#31、时间序列线性回归分析" class="headerlink" title="31、时间序列线性回归分析"></a>31、时间序列线性回归分析</h4><p>tsfresh.feature_extraction.feature_calculators.linear_trend(x, param)</p>
<h4 id="32、时间序列均值上的最长连续自列长度"><a href="#32、时间序列均值上的最长连续自列长度" class="headerlink" title="32、时间序列均值上的最长连续自列长度"></a>32、时间序列均值上的最长连续自列长度</h4><p>tsfresh.feature_extraction.feature_calculators.longest_strike_above_mean(x)</p>
<h4 id="33、时间序列均值下的最长连续自列长度"><a href="#33、时间序列均值下的最长连续自列长度" class="headerlink" title="33、时间序列均值下的最长连续自列长度"></a>33、时间序列均值下的最长连续自列长度</h4><p>tsfresh.feature_extraction.feature_calculators.longest_strike_below_mean(x)</p>
<h4 id="34、时间序列最大langevin不动点"><a href="#34、时间序列最大langevin不动点" class="headerlink" title="34、时间序列最大langevin不动点"></a>34、时间序列最大langevin不动点</h4><p>tsfresh.feature_extraction.feature_calculators.max_langevin_fixed_point(x, r, m)</p>
<h4 id="35、时间序列最大值"><a href="#35、时间序列最大值" class="headerlink" title="35、时间序列最大值"></a>35、时间序列最大值</h4><p>函数：tsfresh.feature_extraction.feature_calculators.maximum(x)</p>
<p>该特征为时间序列最大值。<br>$$<br>MAX = max{x_{i}}_{i=1}^{n}<br>$$<br>源代码为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximum</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Calculates the highest value of the time series x.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.max(x)</span><br></pre></td></tr></table></figure>
<h4 id="36、时间序列平均值"><a href="#36、时间序列平均值" class="headerlink" title="36、时间序列平均值"></a>36、时间序列平均值</h4><p>函数：tsfresh.feature_extraction.feature_calculators.mean(x)</p>
<p>该特征为时间序列平均值。<br>$$<br>Mean = Mean{x_{i}}_{i=1}^{n}<br>$$<br>源代码为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the mean of x</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.mean(x)</span><br></pre></td></tr></table></figure>
<h4 id="37、时间序列一阶差分绝对平均值"><a href="#37、时间序列一阶差分绝对平均值" class="headerlink" title="37、时间序列一阶差分绝对平均值"></a>37、时间序列一阶差分绝对平均值</h4><p>函数：tsfresh.feature_extraction.feature_calculators.mean_abs_change(x)</p>
<p>$$<br>\frac{1}{n}\sum_{i=1}^{n-1}\left|x_{i+1}-x_{i}\right|<br>$$<br>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean_abs_change</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the mean over the absolute differences between subsequent time series values which is</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        \\frac&#123;1&#125;&#123;n&#125; \\sum_&#123;i=1,\ldots, n-1&#125; | x_&#123;i+1&#125; - x_&#123;i&#125;|</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.mean(np.abs(np.diff(x)))</span><br></pre></td></tr></table></figure>
<h4 id="38、时间序列一阶差分平均值"><a href="#38、时间序列一阶差分平均值" class="headerlink" title="38、时间序列一阶差分平均值"></a>38、时间序列一阶差分平均值</h4><p>函数：tsfresh.feature_extraction.feature_calculators.mean_change(x)</p>
<p>$$<br>\frac{1}{n} \sum_{i=1}^{n-1}x_{i+1}-x_{i}<br>$$<br>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean_change</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the mean over the differences between subsequent time series values which is</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        \\frac&#123;1&#125;&#123;n&#125; \\sum_&#123;i=1,\ldots, n-1&#125;  x_&#123;i+1&#125; - x_&#123;i&#125;</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.mean(np.diff(x))</span><br></pre></td></tr></table></figure>
<h4 id="39、时间序列二阶导数的中心均值"><a href="#39、时间序列二阶导数的中心均值" class="headerlink" title="39、时间序列二阶导数的中心均值"></a>39、时间序列二阶导数的中心均值</h4><p>函数：tsfresh.feature_extraction.feature_calculators.mean_second_derivative_central(x)<br>$$<br>\frac{1}{n} \sum_{i=1}^{n-1}\frac{1}{2} (x_{i+2} - 2 \cdot x_{i+1} + x_i)<br>$$<br>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean_second_derivative_central</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the mean value of a central approximation of the second derivative</span></span><br><span class="line"><span class="string">    .. math::</span></span><br><span class="line"><span class="string">        \\frac&#123;1&#125;&#123;n&#125; \\sum_&#123;i=1,\ldots, n-1&#125;  \\frac&#123;1&#125;&#123;2&#125; (x_&#123;i+2&#125; - 2 \\cdot x_&#123;i+1&#125; + x_i)</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    diff = (_roll(x, <span class="number">1</span>) - <span class="number">2</span> * np.array(x) + _roll(x, <span class="number">-1</span>)) / <span class="number">2.0</span></span><br><span class="line">    <span class="keyword">return</span> np.mean(diff[<span class="number">1</span>:<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h4 id="40、时间序列中位数"><a href="#40、时间序列中位数" class="headerlink" title="40、时间序列中位数"></a>40、时间序列中位数</h4><p>函数：tsfresh.feature_extraction.feature_calculators.median(x)<br>$$<br>median = median{x_{i}}_{i=1}^{n}<br>$$<br>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the median of x</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.median(x)</span><br></pre></td></tr></table></figure>
<h4 id="41、时间序列最小值"><a href="#41、时间序列最小值" class="headerlink" title="41、时间序列最小值"></a>41、时间序列最小值</h4><p>函数：tsfresh.feature_extraction.feature_calculators.minimum(x)<br>$$<br>min = min{x_{i}}_{i=1}^{n}<br>$$<br>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Calculates the lowest value of the time series x.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.min(x)</span><br></pre></td></tr></table></figure>
<h4 id="42、时间序列的交叉次数"><a href="#42、时间序列的交叉次数" class="headerlink" title="42、时间序列的交叉次数"></a>42、时间序列的交叉次数</h4><p>函数：tsfresh.feature_extraction.feature_calculators.number_crossing_m(x, m)</p>
<p>这个特征通俗的讲：给定阀值m，查找时间序列中任意两个连续值组成的数值区间是否涵盖m值。例如时间序列[1,2,1,2,3]，对于给定的m=1.5，那么交叉数为3。</p>
<p>需要注意的：如果连续数值为a&lt;b，数值区间为[a,b)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">number_crossing_m</span><span class="params">(x, m)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Calculates the number of crossings of x on m. A crossing is defined as two sequential values where the first value is lower than m and the next is greater, or vice-versa. If you set m to zero, you will get the number of zero crossings.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param m: the threshold for the crossing</span></span><br><span class="line"><span class="string">    :type m: float</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line">    <span class="comment"># From https://stackoverflow.com/questions/3843017/efficiently-detect-sign-changes-in-python</span></span><br><span class="line">    positive = x &gt; m</span><br><span class="line">    <span class="keyword">return</span> np.where(np.bitwise_xor(positive[<span class="number">1</span>:], positive[:<span class="number">-1</span>]))[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure>
<h4 id="43、时间序列搜寻不同峰值"><a href="#43、时间序列搜寻不同峰值" class="headerlink" title="43、时间序列搜寻不同峰值"></a>43、时间序列搜寻不同峰值</h4><p>函数：tsfresh.feature_extraction.feature_calculators.number_cwt_peaks(x, n)</p>
<p>使用连续小波变换寻找时间序列中的波峰。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> cwt, find_peaks_cwt, ricker, welch</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">number_cwt_peaks</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    This feature calculator searches for different peaks in x. To do so, x is smoothed by a ricker wavelet and for widths ranging from 1 to n. This feature calculator returns the number of peaks that occur at enough width scales and with sufficiently high Signal-to-Noise-Ratio (SNR)</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param n: maximum width to consider</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> len(find_peaks_cwt(vector=x, widths=np.array(list(range(<span class="number">1</span>, n + <span class="number">1</span>))), wavelet=ricker))</span><br></pre></td></tr></table></figure>
<h4 id="44、时间序列领域支撑峰值数量"><a href="#44、时间序列领域支撑峰值数量" class="headerlink" title="44、时间序列领域支撑峰值数量"></a>44、时间序列领域支撑峰值数量</h4><p>函数：tsfresh.feature_extraction.feature_calculators.number_peaks(x, n)</p>
<p>对于给定的n值（整型），</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">number_peaks</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Calculates the number of peaks of at least support n in the time series x. A peak of support n is defined as a</span></span><br><span class="line"><span class="string">    subsequence of x where a value occurs, which is bigger than its n neighbours to the left and to the right.</span></span><br><span class="line"><span class="string">    Hence in the sequence</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x = [3, 0, 0, 4, 0, 0, 13]</span></span><br><span class="line"><span class="string">    4 is a peak of support 1 and 2 because in the subsequences</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; [0, 4, 0]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; [0, 0, 4, 0, 0]</span></span><br><span class="line"><span class="string">    4 is still the highest value. Here, 4 is not a peak of support 3 because 13 is the 3th neighbour to the right of 4</span></span><br><span class="line"><span class="string">    and its bigger than 4.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param n: the support of the peak</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    x_reduced = x[n:-n]</span><br><span class="line"></span><br><span class="line">    res = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        result_first = (x_reduced &gt; _roll(x, i)[n:-n])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            res = result_first</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res &amp;= result_first</span><br><span class="line"></span><br><span class="line">        res &amp;= (x_reduced &gt; _roll(x, -i)[n:-n])</span><br><span class="line">    <span class="keyword">return</span> np.sum(res)</span><br></pre></td></tr></table></figure>
<h4 id="45、"><a href="#45、" class="headerlink" title="45、"></a>45、</h4><p>tsfresh.feature_extraction.feature_calculators.partial_autocorrelation(x, param)<br>$$<br>\alpha_k = \frac{ Cov(x_t, x_{t-k} | x_{t-1}, \ldots, x_{t-k+1})}<br>        {\sqrt{ Var(x_t | x_{t-1}, \ldots, x_{t-k+1}) Var(x_{t-k} | x_{t-1}, \ldots, x_{t-k+1} )}}<br>$$</p>
<h4 id="46、时间序列重复数字个数占比"><a href="#46、时间序列重复数字个数占比" class="headerlink" title="46、时间序列重复数字个数占比"></a>46、时间序列重复数字个数占比</h4><p>函数：tsfresh.feature_extraction.feature_calculators.percentage_of_reoccurring_datapoints_to_all_datapoints(x)</p>
<p>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">percentage_of_reoccurring_datapoints_to_all_datapoints</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the percentage of unique values, that are present in the time series</span></span><br><span class="line"><span class="string">    more than once.</span></span><br><span class="line"><span class="string">        len(different values occurring more than once) / len(different values)</span></span><br><span class="line"><span class="string">    This means the percentage is normalized to the number of unique values,</span></span><br><span class="line"><span class="string">    in contrast to the percentage_of_reoccurring_values_to_all_values.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(x) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> np.nan</span><br><span class="line"></span><br><span class="line">    unique, counts = np.unique(x, return_counts=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> counts.shape[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.sum(counts &gt; <span class="number">1</span>) / float(counts.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h4 id="47、时间序列重复数字占比"><a href="#47、时间序列重复数字占比" class="headerlink" title="47、时间序列重复数字占比"></a>47、时间序列重复数字占比</h4><p>tsfresh.feature_extraction.feature_calculators.percentage_of_reoccurring_values_to_all_values(x)</p>
<p>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">percentage_of_reoccurring_values_to_all_values</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the ratio of unique values, that are present in the time series</span></span><br><span class="line"><span class="string">    more than once.</span></span><br><span class="line"><span class="string">        # of data points occurring more than once / # of all data points</span></span><br><span class="line"><span class="string">    This means the ratio is normalized to the number of data points in the time series,</span></span><br><span class="line"><span class="string">    in contrast to the percentage_of_reoccurring_datapoints_to_all_datapoints.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, pd.Series):</span><br><span class="line">        x = pd.Series(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x.size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> np.nan</span><br><span class="line"></span><br><span class="line">    value_counts = x.value_counts()</span><br><span class="line">    reoccuring_values = value_counts[value_counts &gt; <span class="number">1</span>].sum()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> np.isnan(reoccuring_values):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reoccuring_values / x.size</span><br></pre></td></tr></table></figure>
<h4 id="48、时间序列分数位"><a href="#48、时间序列分数位" class="headerlink" title="48、时间序列分数位"></a>48、时间序列分数位</h4><p>函数：tsfresh.feature_extraction.feature_calculators.quantile(x, q)</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantile</span><span class="params">(x, q)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Calculates the q quantile of x. This is the value of x greater than q% of the ordered values from x.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param q: the quantile to calculate</span></span><br><span class="line"><span class="string">    :type q: float</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    x = pd.Series(x)</span><br><span class="line">    <span class="keyword">return</span> pd.Series.quantile(x, q)</span><br></pre></td></tr></table></figure>
<h4 id="49、时间序列指定区间数值个数"><a href="#49、时间序列指定区间数值个数" class="headerlink" title="49、时间序列指定区间数值个数"></a>49、时间序列指定区间数值个数</h4><p>函数：tsfresh.feature_extraction.feature_calculators.range_count(x, min, max)</p>
<p>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">range_count</span><span class="params">(x, min, max)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Count observed values within the interval [min, max).</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param min: the inclusive lower bound of the range</span></span><br><span class="line"><span class="string">    :type min: int or float</span></span><br><span class="line"><span class="string">    :param max: the exclusive upper bound of the range</span></span><br><span class="line"><span class="string">    :type max: int or float</span></span><br><span class="line"><span class="string">    :return: the count of values within the range</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.sum((x &gt;= min) &amp; (x &lt; max))</span><br></pre></td></tr></table></figure>
<h4 id="50、时间序列sigma原则"><a href="#50、时间序列sigma原则" class="headerlink" title="50、时间序列sigma原则"></a>50、时间序列sigma原则</h4><p>函数：tsfresh.feature_extraction.feature_calculators.ratio_beyond_r_sigma(x, r)</p>
<p>源码入下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ratio_beyond_r_sigma</span><span class="params">(x, r)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Ratio of values that are more than r*std(x) (so r sigma) away from the mean of x.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: iterable</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line">    <span class="keyword">return</span> np.sum(np.abs(x - np.mean(x)) &gt; r * np.std(x))/x.size</span><br></pre></td></tr></table></figure>
<h4 id="51、时间序列唯一值数量占整体的比例"><a href="#51、时间序列唯一值数量占整体的比例" class="headerlink" title="51、时间序列唯一值数量占整体的比例"></a>51、时间序列唯一值数量占整体的比例</h4><p>函数：tsfresh.feature_extraction.feature_calculators.ratio_value_number_to_time_series_length(x)</p>
<p>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ratio_value_number_to_time_series_length</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns a factor which is 1 if all values in the time series occur only once,</span></span><br><span class="line"><span class="string">    and below one if this is not the case.</span></span><br><span class="line"><span class="string">    In principle, it just returns</span></span><br><span class="line"><span class="string">        # unique values / # values</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line">    <span class="keyword">if</span> x.size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> np.nan</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.unique(x).size / x.size</span><br></pre></td></tr></table></figure>
<h4 id="52、时间序列样本熵"><a href="#52、时间序列样本熵" class="headerlink" title="52、时间序列样本熵"></a>52、时间序列样本熵</h4><p>函数：tsfresh.feature_extraction.feature_calculators.sample_entropy(x)</p>
<p>通过度量信号中<strong>产生新模式的概率大小</strong>来衡量<strong>时间序列复杂性</strong>，新模式产生的概率越大，序列的复杂性就越大。样本熵的值越低，序列自我相似性就越高；样本熵的值越大，样本序列就越复杂。</p>
<p>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_entropy</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Calculate and return sample entropy of x.</span></span><br><span class="line"><span class="string">    .. rubric:: References</span></span><br><span class="line"><span class="string">    |  [1] http://en.wikipedia.org/wiki/Sample_Entropy</span></span><br><span class="line"><span class="string">    |  [2] https://www.ncbi.nlm.nih.gov/pubmed/10843903?dopt=Abstract</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    x = np.array(x)</span><br><span class="line"></span><br><span class="line">    sample_length = <span class="number">1</span> <span class="comment"># number of sequential points of the time series</span></span><br><span class="line">    tolerance = <span class="number">0.2</span> * np.std(x) <span class="comment"># 0.2 is a common value for r - why?</span></span><br><span class="line"></span><br><span class="line">    n = len(x)</span><br><span class="line">    prev = np.zeros(n)</span><br><span class="line">    curr = np.zeros(n)</span><br><span class="line">    A = np.zeros((<span class="number">1</span>, <span class="number">1</span>))  <span class="comment"># number of matches for m = [1,...,template_length - 1]</span></span><br><span class="line">    B = np.zeros((<span class="number">1</span>, <span class="number">1</span>))  <span class="comment"># number of matches for m = [1,...,template_length]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        nj = n - i - <span class="number">1</span></span><br><span class="line">        ts1 = x[i]</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> range(nj):</span><br><span class="line">            j = jj + i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> abs(x[j] - ts1) &lt; tolerance:  <span class="comment"># distance between two vectors</span></span><br><span class="line">                curr[jj] = prev[jj] + <span class="number">1</span></span><br><span class="line">                temp_ts_length = min(sample_length, curr[jj])</span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> range(int(temp_ts_length)):</span><br><span class="line">                    A[m] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> j &lt; n - <span class="number">1</span>:</span><br><span class="line">                        B[m] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr[jj] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(nj):</span><br><span class="line">            prev[j] = curr[j]</span><br><span class="line"></span><br><span class="line">    N = n * (n - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    B = np.vstack(([N], B[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># sample entropy = -1 * (log (A/B))</span></span><br><span class="line">    similarity_ratio = A / B</span><br><span class="line">    se = <span class="number">-1</span> * np.log(similarity_ratio)</span><br><span class="line">    se = np.reshape(se, <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> se[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="53、"><a href="#53、" class="headerlink" title="53、"></a>53、</h4><p>tsfresh.feature_extraction.feature_calculators.set_property(key, value)</p>
<h4 id="54、时间序列分布偏度"><a href="#54、时间序列分布偏度" class="headerlink" title="54、时间序列分布偏度"></a>54、时间序列分布偏度</h4><p>函数：tsfresh.feature_extraction.feature_calculators.skewness(x)</p>
<p>偏度是统计数据分布偏斜方向和程度的度量，是统计数据分布非对称程度的数字特征。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skewness</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the sample skewness of x (calculated with the adjusted Fisher-Pearson standardized</span></span><br><span class="line"><span class="string">    moment coefficient G1).</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, pd.Series):</span><br><span class="line">        x = pd.Series(x)</span><br><span class="line">    <span class="keyword">return</span> pd.Series.skew(x)</span><br></pre></td></tr></table></figure>
<h4 id="55、"><a href="#55、" class="headerlink" title="55、"></a>55、</h4><p>tsfresh.feature_extraction.feature_calculators.spkt_welch_density(x, param)</p>
<h4 id="56、时间序列的标准方差"><a href="#56、时间序列的标准方差" class="headerlink" title="56、时间序列的标准方差"></a>56、时间序列的标准方差</h4><p>函数：tsfresh.feature_extraction.feature_calculators.standard_deviation(x)</p>
<p>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">standard_deviation</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the standard deviation of x</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.std(x)</span><br></pre></td></tr></table></figure>
<h4 id="57、时间序列重复数据的总个数"><a href="#57、时间序列重复数据的总个数" class="headerlink" title="57、时间序列重复数据的总个数"></a>57、时间序列重复数据的总个数</h4><p>函数：tsfresh.feature_extraction.feature_calculators.sum_of_reoccurring_data_points(x)</p>
<p>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_reoccurring_data_points</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the sum of all data points, that are present in the time series</span></span><br><span class="line"><span class="string">    more than once.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    unique, counts = np.unique(x, return_counts=<span class="keyword">True</span>)</span><br><span class="line">    counts[counts &lt; <span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(counts * unique)</span><br></pre></td></tr></table></figure>
<h4 id="58、时间序列重复数据的和"><a href="#58、时间序列重复数据的和" class="headerlink" title="58、时间序列重复数据的和"></a>58、时间序列重复数据的和</h4><p>函数：tsfresh.feature_extraction.feature_calculators.sum_of_reoccurring_values(x)</p>
<p>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_reoccurring_values</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the sum of all values, that are present in the time series</span></span><br><span class="line"><span class="string">    more than once.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    unique, counts = np.unique(x, return_counts=<span class="keyword">True</span>)</span><br><span class="line">    counts[counts &lt; <span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">    counts[counts &gt; <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(counts * unique)</span><br></pre></td></tr></table></figure>
<h4 id="59、时间序列和"><a href="#59、时间序列和" class="headerlink" title="59、时间序列和"></a>59、时间序列和</h4><p>函数：tsfresh.feature_extraction.feature_calculators.sum_values(x)</p>
<p>该特征为时间序列和。<br>$$<br>SUM = \sum_{i=1}^{n} x_{i}^{2}<br>$$<br>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_values</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Calculates the sum over the time series values</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(x) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.sum(x)</span><br></pre></td></tr></table></figure>
<h4 id="60、"><a href="#60、" class="headerlink" title="60、"></a>60、</h4><p>tsfresh.feature_extraction.feature_calculators.symmetry_looking(x, param)</p>
<h4 id="61、"><a href="#61、" class="headerlink" title="61、"></a>61、</h4><p>tsfresh.feature_extraction.feature_calculators.time_reversal_asymmetry_statistic(x, lag)</p>
<h4 id="62、时间序列某个值的个数"><a href="#62、时间序列某个值的个数" class="headerlink" title="62、时间序列某个值的个数"></a>62、时间序列某个值的个数</h4><p>函数：tsfresh.feature_extraction.feature_calculators.value_count(x, value)</p>
<p>源代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">value_count</span><span class="params">(x, value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Count occurrences of `value` in time series x.</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :param value: the value to be counted</span></span><br><span class="line"><span class="string">    :type value: int or float</span></span><br><span class="line"><span class="string">    :return: the count</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (np.ndarray, pd.Series)):</span><br><span class="line">        x = np.asarray(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> np.isnan(value):</span><br><span class="line">        <span class="keyword">return</span> np.isnan(x).sum()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x[x == value].size</span><br></pre></td></tr></table></figure>
<h4 id="63、时间序列方差"><a href="#63、时间序列方差" class="headerlink" title="63、时间序列方差"></a>63、时间序列方差</h4><p>函数：tsfresh.feature_extraction.feature_calculators.variance(x)</p>
<p>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variance</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the variance of x</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: float</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.var(x)</span><br></pre></td></tr></table></figure>
<h4 id="64、时间序列方差是否大于标准方差"><a href="#64、时间序列方差是否大于标准方差" class="headerlink" title="64、时间序列方差是否大于标准方差"></a>64、时间序列方差是否大于标准方差</h4><p>函数：tsfresh.feature_extraction.feature_calculators.variance_larger_than_standard_deviation(x)</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variance_larger_than_standard_deviation</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Boolean variable denoting if the variance of x is greater than its standard deviation. Is equal to variance of x</span></span><br><span class="line"><span class="string">    being larger than 1</span></span><br><span class="line"><span class="string">    :param x: the time series to calculate the feature of</span></span><br><span class="line"><span class="string">    :type x: numpy.ndarray</span></span><br><span class="line"><span class="string">    :return: the value of this feature</span></span><br><span class="line"><span class="string">    :return type: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    y = np.var(x)</span><br><span class="line">    <span class="keyword">return</span> y &gt; np.sqrt(y)</span><br></pre></td></tr></table></figure>
<h4 id="65、"><a href="#65、" class="headerlink" title="65、"></a>65、</h4><p>tsfresh.feature_extraction.feature_calculators.linear_trend_timewise(x, param)</p>
<h3 id="第三部分-特征参数设置"><a href="#第三部分-特征参数设置" class="headerlink" title="第三部分   特征参数设置"></a>第三部分   特征参数设置</h3><h3 id="第四部分-特征选择和过滤"><a href="#第四部分-特征选择和过滤" class="headerlink" title="第四部分   特征选择和过滤"></a>第四部分   特征选择和过滤</h3><p><a href="https://gitmemories.com/cuge1995/awesome-time-series" target="_blank" rel="noopener">https://gitmemories.com/cuge1995/awesome-time-series</a></p>
<h2 id="第五部分-附录"><a href="#第五部分-附录" class="headerlink" title="第五部分 附录"></a>第五部分 附录</h2><p>案例数据下载：</p>
<p><a href="https://bj.bcebos.com/v1/ai-studio-online/85b5cb4eea5a4f259766f42a448e2c04a7499c43e1ae4cc28fbdee8e087e2385?responseContentDisposition=attachment%3B%20filename%3Dwtbdata_245days.csv&amp;authorization=bce-auth-v1%2F0ef6765c1e494918bc0d4c3ca3e5c6d1%2F2022-05-05T14%3A17%3A03Z%2F-1%2F%2F5932bfb6aa3af1bcfb467bf2a4a6877f8823fe96c6f4fd0d4a3caa722354e3ac" target="_blank" rel="noopener">https://bj.bcebos.com/v1/ai-studio-online/85b5cb4eea5a4f259766f42a448e2c04a7499c43e1ae4cc28fbdee8e087e2385?responseContentDisposition=attachment%3B%20filename%3Dwtbdata_245days.csv&amp;authorization=bce-auth-v1%2F0ef6765c1e494918bc0d4c3ca3e5c6d1%2F2022-05-05T14%3A17%3A03Z%2F-1%2F%2F5932bfb6aa3af1bcfb467bf2a4a6877f8823fe96c6f4fd0d4a3caa722354e3ac</a></p>
<h2 id="参考文献及资料"><a href="#参考文献及资料" class="headerlink" title="参考文献及资料"></a>参考文献及资料</h2><p>1、<a href="https://blog.csdn.net/qq_39478403/article/details/115057005" target="_blank" rel="noopener">https://blog.csdn.net/qq_39478403/article/details/115057005</a></p>
<p>2、<a href="https://tsfresh.readthedocs.io/en/latest/text/quick_start.html" target="_blank" rel="noopener">https://tsfresh.readthedocs.io/en/latest/text/quick_start.html</a></p>

      
    </div>

    

    <div>
      
        
      
    </div>
    
    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/176a937a/" rel="next" title="外网环境访问内网（NAT）Kafka集群介绍">
                <i class="fa fa-chevron-left"></i> 外网环境访问内网（NAT）Kafka集群介绍
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/3d4d8914/" rel="prev" title="Linux系统中用户相关操作总结">
                Linux系统中用户相关操作总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar/person.png" alt="rong xiang">
            
              <p class="site-author-name" itemprop="name">rong xiang</p>
              <p class="site-description motion-element" itemprop="description">Keep a Pure Curiosity</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">311</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">80</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/zjrongxiang" title="GitHub &rarr; https://github.com/zjrongxiang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:rongxiang1986@163.com" title="E-Mail &rarr; mailto:rongxiang1986@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="http://weibo.com/u/1971060643" title="Weibo &rarr; http://weibo.com/u/1971060643" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Link
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://weibo.com/fly51fly?refer_flag=1005055010_" title="https://weibo.com/fly51fly?refer_flag=1005055010_" rel="noopener" target="_blank">爱生活爱可可</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#目录"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#背景"><span class="nav-number">2.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第一部分-tsfresh包安装"><span class="nav-number">3.</span> <span class="nav-text">第一部分   tsfresh包安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第一部分-项目结构"><span class="nav-number">4.</span> <span class="nav-text">第一部分 项目结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二部分-特征提取及介绍"><span class="nav-number">5.</span> <span class="nav-text">第二部分 特征提取及介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、时间序列平方和"><span class="nav-number">5.1.</span> <span class="nav-text">1、时间序列平方和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2、时间序列一阶差分绝对和"><span class="nav-number">5.1.1.</span> <span class="nav-text">2、时间序列一阶差分绝对和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、时间序列各阶自相关系数的聚合统计特征"><span class="nav-number">5.1.2.</span> <span class="nav-text">3、时间序列各阶自相关系数的聚合统计特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、时间序列基于分块时序聚合值的线性回归"><span class="nav-number">5.1.3.</span> <span class="nav-text">4、时间序列基于分块时序聚合值的线性回归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、时间序列近似熵"><span class="nav-number">5.1.4.</span> <span class="nav-text">5、时间序列近似熵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、时间序列自回归系数"><span class="nav-number">5.1.5.</span> <span class="nav-text">6、时间序列自回归系数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7、时间序列ADF检验"><span class="nav-number">5.1.6.</span> <span class="nav-text">7、时间序列ADF检验</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8、时间序列lag阶自相关性"><span class="nav-number">5.1.7.</span> <span class="nav-text">8、时间序列lag阶自相关性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9、时间序列分组熵"><span class="nav-number">5.1.8.</span> <span class="nav-text">9、时间序列分组熵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10、时序数据非线性度量"><span class="nav-number">5.1.9.</span> <span class="nav-text">10、时序数据非线性度量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11、时间序列给定区间的统计量"><span class="nav-number">5.1.10.</span> <span class="nav-text">11、时间序列给定区间的统计量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12、时间序列复杂度"><span class="nav-number">5.1.11.</span> <span class="nav-text">12、时间序列复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13、时间序列高于均值个数"><span class="nav-number">5.1.12.</span> <span class="nav-text">13、时间序列高于均值个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14、时间序列低于均值个数"><span class="nav-number">5.1.13.</span> <span class="nav-text">14、时间序列低于均值个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15、时间序列Ricker小波分析"><span class="nav-number">5.1.14.</span> <span class="nav-text">15、时间序列Ricker小波分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16、时间序列分块局部熵比率"><span class="nav-number">5.1.15.</span> <span class="nav-text">16、时间序列分块局部熵比率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17、时间序列绝对傅里叶变换的谱统计量"><span class="nav-number">5.1.16.</span> <span class="nav-text">17、时间序列绝对傅里叶变换的谱统计量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18、时间序列傅里叶变换系数"><span class="nav-number">5.1.17.</span> <span class="nav-text">18、时间序列傅里叶变换系数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19、时间序列第一个最大值位置"><span class="nav-number">5.1.18.</span> <span class="nav-text">19、时间序列第一个最大值位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20、时间序列第一个最小值位置"><span class="nav-number">5.1.19.</span> <span class="nav-text">20、时间序列第一个最小值位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21、时间序列Langevin模型拟合的多项式系数"><span class="nav-number">5.1.20.</span> <span class="nav-text">21、时间序列Langevin模型拟合的多项式系数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22、时间序列数值是否有重复"><span class="nav-number">5.1.21.</span> <span class="nav-text">22、时间序列数值是否有重复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23、时间序列最大值是否有重复"><span class="nav-number">5.1.22.</span> <span class="nav-text">23、时间序列最大值是否有重复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24、时间序列最小值是否有重复"><span class="nav-number">5.1.23.</span> <span class="nav-text">24、时间序列最小值是否有重复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25、时间序列分位数索引"><span class="nav-number">5.1.24.</span> <span class="nav-text">25、时间序列分位数索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26、时间序列峰度"><span class="nav-number">5.1.25.</span> <span class="nav-text">26、时间序列峰度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27、时间序列标准差是否大于r倍偏差"><span class="nav-number">5.1.26.</span> <span class="nav-text">27、时间序列标准差是否大于r倍偏差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28、时间序列最后一个最大值位置"><span class="nav-number">5.1.27.</span> <span class="nav-text">28、时间序列最后一个最大值位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29、时间序列最后一个最大值位置"><span class="nav-number">5.1.28.</span> <span class="nav-text">29、时间序列最后一个最大值位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30、时间序列的长度"><span class="nav-number">5.1.29.</span> <span class="nav-text">30、时间序列的长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31、时间序列线性回归分析"><span class="nav-number">5.1.30.</span> <span class="nav-text">31、时间序列线性回归分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32、时间序列均值上的最长连续自列长度"><span class="nav-number">5.1.31.</span> <span class="nav-text">32、时间序列均值上的最长连续自列长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33、时间序列均值下的最长连续自列长度"><span class="nav-number">5.1.32.</span> <span class="nav-text">33、时间序列均值下的最长连续自列长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34、时间序列最大langevin不动点"><span class="nav-number">5.1.33.</span> <span class="nav-text">34、时间序列最大langevin不动点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35、时间序列最大值"><span class="nav-number">5.1.34.</span> <span class="nav-text">35、时间序列最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#36、时间序列平均值"><span class="nav-number">5.1.35.</span> <span class="nav-text">36、时间序列平均值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#37、时间序列一阶差分绝对平均值"><span class="nav-number">5.1.36.</span> <span class="nav-text">37、时间序列一阶差分绝对平均值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#38、时间序列一阶差分平均值"><span class="nav-number">5.1.37.</span> <span class="nav-text">38、时间序列一阶差分平均值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#39、时间序列二阶导数的中心均值"><span class="nav-number">5.1.38.</span> <span class="nav-text">39、时间序列二阶导数的中心均值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#40、时间序列中位数"><span class="nav-number">5.1.39.</span> <span class="nav-text">40、时间序列中位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#41、时间序列最小值"><span class="nav-number">5.1.40.</span> <span class="nav-text">41、时间序列最小值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#42、时间序列的交叉次数"><span class="nav-number">5.1.41.</span> <span class="nav-text">42、时间序列的交叉次数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#43、时间序列搜寻不同峰值"><span class="nav-number">5.1.42.</span> <span class="nav-text">43、时间序列搜寻不同峰值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#44、时间序列领域支撑峰值数量"><span class="nav-number">5.1.43.</span> <span class="nav-text">44、时间序列领域支撑峰值数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#45、"><span class="nav-number">5.1.44.</span> <span class="nav-text">45、</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46、时间序列重复数字个数占比"><span class="nav-number">5.1.45.</span> <span class="nav-text">46、时间序列重复数字个数占比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#47、时间序列重复数字占比"><span class="nav-number">5.1.46.</span> <span class="nav-text">47、时间序列重复数字占比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#48、时间序列分数位"><span class="nav-number">5.1.47.</span> <span class="nav-text">48、时间序列分数位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#49、时间序列指定区间数值个数"><span class="nav-number">5.1.48.</span> <span class="nav-text">49、时间序列指定区间数值个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#50、时间序列sigma原则"><span class="nav-number">5.1.49.</span> <span class="nav-text">50、时间序列sigma原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#51、时间序列唯一值数量占整体的比例"><span class="nav-number">5.1.50.</span> <span class="nav-text">51、时间序列唯一值数量占整体的比例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#52、时间序列样本熵"><span class="nav-number">5.1.51.</span> <span class="nav-text">52、时间序列样本熵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53、"><span class="nav-number">5.1.52.</span> <span class="nav-text">53、</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#54、时间序列分布偏度"><span class="nav-number">5.1.53.</span> <span class="nav-text">54、时间序列分布偏度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#55、"><span class="nav-number">5.1.54.</span> <span class="nav-text">55、</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#56、时间序列的标准方差"><span class="nav-number">5.1.55.</span> <span class="nav-text">56、时间序列的标准方差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#57、时间序列重复数据的总个数"><span class="nav-number">5.1.56.</span> <span class="nav-text">57、时间序列重复数据的总个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#58、时间序列重复数据的和"><span class="nav-number">5.1.57.</span> <span class="nav-text">58、时间序列重复数据的和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#59、时间序列和"><span class="nav-number">5.1.58.</span> <span class="nav-text">59、时间序列和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#60、"><span class="nav-number">5.1.59.</span> <span class="nav-text">60、</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#61、"><span class="nav-number">5.1.60.</span> <span class="nav-text">61、</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#62、时间序列某个值的个数"><span class="nav-number">5.1.61.</span> <span class="nav-text">62、时间序列某个值的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#63、时间序列方差"><span class="nav-number">5.1.62.</span> <span class="nav-text">63、时间序列方差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64、时间序列方差是否大于标准方差"><span class="nav-number">5.1.63.</span> <span class="nav-text">64、时间序列方差是否大于标准方差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#65、"><span class="nav-number">5.1.64.</span> <span class="nav-text">65、</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三部分-特征参数设置"><span class="nav-number">5.2.</span> <span class="nav-text">第三部分   特征参数设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四部分-特征选择和过滤"><span class="nav-number">5.3.</span> <span class="nav-text">第四部分   特征选择和过滤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五部分-附录"><span class="nav-number">6.</span> <span class="nav-text">第五部分 附录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献及资料"><span class="nav-number">7.</span> <span class="nav-text">参考文献及资料</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2014 – <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rong xiang</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">940k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">14:15</span>
  
</div>






        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=6.7.0"></script>




  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  
  
    
  <script id="dsq-count-scr" src="https://https-zjrongxiang-github-io.disqus.com/count.js" async></script>


<script>
  var disqus_config = function () {
    this.page.url = "https://zjrongxiang.github.io/posts/1d1f5e4b/";
    this.page.identifier = "posts/1d1f5e4b/";
    this.page.title = 'Tsfresh时间序列特征提取包介绍';
    };
  function loadComments () {
    var d = document, s = d.createElement('script');
    s.src = 'https://https-zjrongxiang-github-io.disqus.com/embed.js';
    s.setAttribute('data-timestamp', '' + +new Date());
    (d.head || d.body).appendChild(s);
  }
  
    loadComments();
  
</script>

  





  

  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  
  

  


  

  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function () {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  
  

  
  

  


</body>
</html>
